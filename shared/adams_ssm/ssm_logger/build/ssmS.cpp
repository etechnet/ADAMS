// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.2.2
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/


// TAO_IDL - Generated from
// be/be_codegen.cpp:652

#ifndef _TAO_IDL_SSMS_8SBKFH_CPP_
#define _TAO_IDL_SSMS_8SBKFH_CPP_


#include "ssmS.h"
#include <tao/PortableServer/Operation_Table_Perfect_Hash.h>
#include <tao/PortableServer/Upcall_Command.h>
#include <tao/PortableServer/Upcall_Wrapper.h>
#include <tao/TAO_Server_Request.h>
#include <tao/ORB_Core.h>
#include <tao/Profile.h>
#include <tao/Stub.h>
#include <tao/IFR_Client_Adapter.h>
#include <tao/Object_T.h>
#include <tao/AnyTypeCode/TypeCode.h>
#include <tao/AnyTypeCode/DynamicC.h>
#include <tao/CDR.h>
#include <tao/operation_details.h>
#include <tao/PortableInterceptor.h>
#include <ace/Dynamic_Service.h>
#include <ace/Malloc_Allocator.h>

// TAO_IDL - Generated from
// be/be_interface.cpp:1868

class TAO_net_etech_SSM_ConfigMonitorServer_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_net_etech_SSM_ConfigMonitorServer_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_net_etech_SSM_ConfigMonitorServer_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30,  0, 30, 30, 30, 30,
     30, 30, 30,  0, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30,  0, 30,  0, 30,  0,
      5,  5, 30,  5, 30, 30, 30, 30, 30, 30,
      0, 30, 15, 30,  0,  0,  0, 30, 30, 10,
     30, 30, 30, 30, 30, 30, 30, 30,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_net_etech_SSM_ConfigMonitorServer_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 15,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 20,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 29,
      HASH_VALUE_RANGE = 25,
      DUPLICATES = 0,
      WORDLIST_SIZE = 20
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"ShutDown", &POA_net::etech::SSM::ConfigMonitorServer::ShutDown_skel, 0},
      {"",0,0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"SystemStart", &POA_net::etech::SSM::ConfigMonitorServer::SystemStart_skel, 0},
      {"",0,0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"",0,0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"KillOrbixProcess", &POA_net::etech::SSM::ConfigMonitorServer::KillOrbixProcess_skel, 0},
      {"refreshConfigBloc", &POA_net::etech::SSM::ConfigMonitorServer::refreshConfigBloc_skel, 0},
      {"deleteProcess", &POA_net::etech::SSM::ConfigMonitorServer::deleteProcess_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"refreshConfigProcess", &POA_net::etech::SSM::ConfigMonitorServer::refreshConfigProcess_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"deleteBlockLog", &POA_net::etech::SSM::ConfigMonitorServer::deleteBlockLog_skel, 0},
      {"SystemStop", &POA_net::etech::SSM::ConfigMonitorServer::SystemStop_skel, 0},
      {"",0,0},{"",0,0},
      {"writeModifyProcess", &POA_net::etech::SSM::ConfigMonitorServer::writeModifyProcess_skel, 0},
      {"writeModifyLog", &POA_net::etech::SSM::ConfigMonitorServer::writeModifyLog_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_net_etech_SSM_ConfigMonitorServer_Perfect_Hash_OpTable tao_net_etech_SSM_ConfigMonitorServer_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:93

POA_net::etech::SSM::ConfigMonitorServer::ConfigMonitorServer (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_net_etech_SSM_ConfigMonitorServer_optable;
}

POA_net::etech::SSM::ConfigMonitorServer::ConfigMonitorServer (const ConfigMonitorServer& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_net::etech::SSM::ConfigMonitorServer::~ConfigMonitorServer (void)
{
}

namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class KillOrbixProcess_ConfigMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline KillOrbixProcess_ConfigMonitorServer (
          POA_net::etech::SSM::ConfigMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->KillOrbixProcess (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::ConfigMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ConfigMonitorServer::KillOrbixProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_num_pid;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flag,
      &_tao_num_pid
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::ConfigMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ConfigMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  KillOrbixProcess_ConfigMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class refreshConfigProcess_ConfigMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline refreshConfigProcess_ConfigMonitorServer (
          POA_net::etech::SSM::ConfigMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::net::etech::CS_INFO_PROCSeq>::out_arg_type arg_2 =
            TAO::Portable_Server::get_out_arg< ::net::etech::CS_INFO_PROCSeq> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->refreshConfigProcess (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::ConfigMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ConfigMonitorServer::refreshConfigProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::CS_INFO_PROCSeq>::out_arg_val _tao_configProcesslList;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flag,
      &_tao_configProcesslList
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::ConfigMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ConfigMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  refreshConfigProcess_ConfigMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class refreshConfigBloc_ConfigMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline refreshConfigBloc_ConfigMonitorServer (
          POA_net::etech::SSM::ConfigMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::net::etech::CS_BLOCK_LOGSeq>::out_arg_type arg_2 =
            TAO::Portable_Server::get_out_arg< ::net::etech::CS_BLOCK_LOGSeq> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->refreshConfigBloc (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::ConfigMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ConfigMonitorServer::refreshConfigBloc_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::CS_BLOCK_LOGSeq>::out_arg_val _tao_configBloclList;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flag,
      &_tao_configBloclList
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::ConfigMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ConfigMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  refreshConfigBloc_ConfigMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class writeModifyProcess_ConfigMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline writeModifyProcess_ConfigMonitorServer (
          POA_net::etech::SSM::ConfigMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::net::etech::CS_INFO_PROC>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::net::etech::CS_INFO_PROC> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->writeModifyProcess (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::ConfigMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ConfigMonitorServer::writeModifyProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nomeProcesso;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::CS_INFO_PROC>::in_arg_val _tao_configProcess;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nomeProcesso,
      &_tao_flag,
      &_tao_configProcess
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::ConfigMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ConfigMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  writeModifyProcess_ConfigMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class writeModifyLog_ConfigMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline writeModifyLog_ConfigMonitorServer (
          POA_net::etech::SSM::ConfigMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::net::etech::CS_BLOCK_LOGSeq>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::net::etech::CS_BLOCK_LOGSeq> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->writeModifyLog (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::ConfigMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ConfigMonitorServer::writeModifyLog_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::CS_BLOCK_LOGSeq>::in_arg_val _tao_configBloclList;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flag,
      &_tao_configBloclList
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::ConfigMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ConfigMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  writeModifyLog_ConfigMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class deleteProcess_ConfigMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline deleteProcess_ConfigMonitorServer (
          POA_net::etech::SSM::ConfigMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->deleteProcess (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::ConfigMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ConfigMonitorServer::deleteProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nomeProcesso;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flag,
      &_tao_nomeProcesso
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::ConfigMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ConfigMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  deleteProcess_ConfigMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class deleteBlockLog_ConfigMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline deleteBlockLog_ConfigMonitorServer (
          POA_net::etech::SSM::ConfigMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->deleteBlockLog (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::ConfigMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ConfigMonitorServer::deleteBlockLog_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_idBlock;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flag,
      &_tao_idBlock
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::ConfigMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ConfigMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  deleteBlockLog_ConfigMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class SystemStart_ConfigMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline SystemStart_ConfigMonitorServer (
          POA_net::etech::SSM::ConfigMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          retval =
            this->servant_->SystemStart (
              arg_1);
        }
      
      private:
        POA_net::etech::SSM::ConfigMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ConfigMonitorServer::SystemStart_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flag
    };
  
  static size_t const nargs = 2;

  POA_net::etech::SSM::ConfigMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ConfigMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  SystemStart_ConfigMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class SystemStop_ConfigMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline SystemStop_ConfigMonitorServer (
          POA_net::etech::SSM::ConfigMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          retval =
            this->servant_->SystemStop (
              arg_1);
        }
      
      private:
        POA_net::etech::SSM::ConfigMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ConfigMonitorServer::SystemStop_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flag
    };
  
  static size_t const nargs = 2;

  POA_net::etech::SSM::ConfigMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ConfigMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  SystemStop_ConfigMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class ShutDown_ConfigMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline ShutDown_ConfigMonitorServer (
          POA_net::etech::SSM::ConfigMonitorServer * servant)
          : servant_ (servant)
        {
        }

        virtual void execute (void)
        {
          this->servant_->ShutDown ();
        }
      
      private:
        POA_net::etech::SSM::ConfigMonitorServer * const servant_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ConfigMonitorServer::ShutDown_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_net::etech::SSM::ConfigMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ConfigMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  ShutDown_ConfigMonitorServer command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:166



::CORBA::Boolean POA_net::etech::SSM::ConfigMonitorServer::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:net/etech/SSM/ConfigMonitorServer:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_net::etech::SSM::ConfigMonitorServer::_interface_repository_id (void) const
{
  return "IDL:net/etech/SSM/ConfigMonitorServer:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:426

void POA_net::etech::SSM::ConfigMonitorServer::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:373

net::etech::SSM::ConfigMonitorServer *
POA_net::etech::SSM::ConfigMonitorServer::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::net::etech::SSM::ConfigMonitorServer STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1868

class TAO_net_etech_SSM_ProcessMonitorServer_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_net_etech_SSM_ProcessMonitorServer_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_net_etech_SSM_ProcessMonitorServer_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
     25, 25, 25,  0, 25, 25, 25, 25, 25, 25,
     25, 25, 25, 25, 25,  0, 25,  0, 25,  0,
     10,  5, 25,  0, 25, 25, 25, 25, 25, 25,
      0, 25, 25, 25,  0,  0,  0, 25, 25, 25,
     25, 25, 25, 25, 25, 25, 25, 25,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_net_etech_SSM_ProcessMonitorServer_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 11,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 24,
      HASH_VALUE_RANGE = 20,
      DUPLICATES = 0,
      WORDLIST_SIZE = 16
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"ShutDown", &POA_net::etech::SSM::ProcessMonitorServer::ShutDown_skel, 0},
      {"",0,0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"checkStatus", &POA_net::etech::SSM::ProcessMonitorServer::checkStatus_skel, 0},
      {"",0,0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"",0,0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"getDeteilProcess", &POA_net::etech::SSM::ProcessMonitorServer::getDeteilProcess_skel, 0},
      {"getHistoryProcess", &POA_net::etech::SSM::ProcessMonitorServer::getHistoryProcess_skel, 0},
      {"",0,0},{"",0,0},
      {"resetField", &POA_net::etech::SSM::ProcessMonitorServer::resetField_skel, 0},
      {"refreshMonitorProcess", &POA_net::etech::SSM::ProcessMonitorServer::refreshMonitorProcess_skel, 0},
      {"",0,0},{"",0,0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_net_etech_SSM_ProcessMonitorServer_Perfect_Hash_OpTable tao_net_etech_SSM_ProcessMonitorServer_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:93

POA_net::etech::SSM::ProcessMonitorServer::ProcessMonitorServer (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_net_etech_SSM_ProcessMonitorServer_optable;
}

POA_net::etech::SSM::ProcessMonitorServer::ProcessMonitorServer (const ProcessMonitorServer& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_net::etech::SSM::ProcessMonitorServer::~ProcessMonitorServer (void)
{
}

namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class refreshMonitorProcess_ProcessMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline refreshMonitorProcess_ProcessMonitorServer (
          POA_net::etech::SSM::ProcessMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::net::etech::ProcesDetailSeq>::out_arg_type arg_1 =
            TAO::Portable_Server::get_out_arg< ::net::etech::ProcesDetailSeq> (
              this->operation_details_,
              this->args_,
              1);
            
          retval =
            this->servant_->refreshMonitorProcess (
              arg_1);
        }
      
      private:
        POA_net::etech::SSM::ProcessMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ProcessMonitorServer::refreshMonitorProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::net::etech::ProcesDetailSeq>::out_arg_val _tao_procesDetailList;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_procesDetailList
    };
  
  static size_t const nargs = 2;

  POA_net::etech::SSM::ProcessMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ProcessMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  refreshMonitorProcess_ProcessMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class checkStatus_ProcessMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline checkStatus_ProcessMonitorServer (
          POA_net::etech::SSM::ProcessMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::net::etech::ProcesDetailSeq>::out_arg_type arg_1 =
            TAO::Portable_Server::get_out_arg< ::net::etech::ProcesDetailSeq> (
              this->operation_details_,
              this->args_,
              1);
            
          retval =
            this->servant_->checkStatus (
              arg_1);
        }
      
      private:
        POA_net::etech::SSM::ProcessMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ProcessMonitorServer::checkStatus_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::net::etech::ProcesDetailSeq>::out_arg_val _tao_procesDetailList;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_procesDetailList
    };
  
  static size_t const nargs = 2;

  POA_net::etech::SSM::ProcessMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ProcessMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  checkStatus_ProcessMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class getDeteilProcess_ProcessMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline getDeteilProcess_ProcessMonitorServer (
          POA_net::etech::SSM::ProcessMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::net::etech::LogProcessSeq>::out_arg_type arg_3 =
            TAO::Portable_Server::get_out_arg< ::net::etech::LogProcessSeq> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->getDeteilProcess (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::ProcessMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ProcessMonitorServer::getDeteilProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flagDETAIL;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nomeProcesso;
  TAO::SArg_Traits< ::net::etech::LogProcessSeq>::out_arg_val _tao_logProcesso;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flagDETAIL,
      &_tao_nomeProcesso,
      &_tao_logProcesso
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::ProcessMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ProcessMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  getDeteilProcess_ProcessMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class getHistoryProcess_ProcessMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline getHistoryProcess_ProcessMonitorServer (
          POA_net::etech::SSM::ProcessMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_,
              3);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_4 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              4);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_5 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              5);
            
          TAO::SArg_Traits< ::net::etech::LogProcessSeq>::out_arg_type arg_6 =
            TAO::Portable_Server::get_out_arg< ::net::etech::LogProcessSeq> (
              this->operation_details_,
              this->args_,
              6);
            
          retval =
            this->servant_->getHistoryProcess (
              arg_1
              , arg_2
              , arg_3
              , arg_4
              , arg_5
              , arg_6);
        }
      
      private:
        POA_net::etech::SSM::ProcessMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ProcessMonitorServer::getHistoryProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flagWORK;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flagSINGLE_ALL_PROCESS;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_flagALLDOCUMENT;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nomeProcesso;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_data;
  TAO::SArg_Traits< ::net::etech::LogProcessSeq>::out_arg_val _tao_logProcesso;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flagWORK,
      &_tao_flagSINGLE_ALL_PROCESS,
      &_tao_flagALLDOCUMENT,
      &_tao_nomeProcesso,
      &_tao_data,
      &_tao_logProcesso
    };
  
  static size_t const nargs = 7;

  POA_net::etech::SSM::ProcessMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ProcessMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  getHistoryProcess_ProcessMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class resetField_ProcessMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline resetField_ProcessMonitorServer (
          POA_net::etech::SSM::ProcessMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->resetField (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::ProcessMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ProcessMonitorServer::resetField_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_field;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flagTIPORESET;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nomeProcesso;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_field,
      &_tao_flagTIPORESET,
      &_tao_nomeProcesso
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::ProcessMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ProcessMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  resetField_ProcessMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class ShutDown_ProcessMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline ShutDown_ProcessMonitorServer (
          POA_net::etech::SSM::ProcessMonitorServer * servant)
          : servant_ (servant)
        {
        }

        virtual void execute (void)
        {
          this->servant_->ShutDown ();
        }
      
      private:
        POA_net::etech::SSM::ProcessMonitorServer * const servant_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ProcessMonitorServer::ShutDown_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_net::etech::SSM::ProcessMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ProcessMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  ShutDown_ProcessMonitorServer command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:166



::CORBA::Boolean POA_net::etech::SSM::ProcessMonitorServer::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:net/etech/SSM/ProcessMonitorServer:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_net::etech::SSM::ProcessMonitorServer::_interface_repository_id (void) const
{
  return "IDL:net/etech/SSM/ProcessMonitorServer:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:426

void POA_net::etech::SSM::ProcessMonitorServer::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:373

net::etech::SSM::ProcessMonitorServer *
POA_net::etech::SSM::ProcessMonitorServer::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::net::etech::SSM::ProcessMonitorServer STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1868

class TAO_net_etech_SSM_ACQPebMGRServer_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_net_etech_SSM_ACQPebMGRServer_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_net_etech_SSM_ACQPebMGRServer_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20,  0,  0, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20,  0, 20,  0, 20, 20,
      5,  5, 20, 20, 20, 20, 20, 20, 20, 20,
      0, 20, 20, 20,  0, 20,  0, 20, 20,  0,
     20, 20, 20, 20, 20, 20, 20, 20,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_net_etech_SSM_ACQPebMGRServer_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 8,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 16,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 19,
      HASH_VALUE_RANGE = 15,
      DUPLICATES = 0,
      WORDLIST_SIZE = 13
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"ShutDown", &POA_net::etech::SSM::ACQPebMGRServer::ShutDown_skel, 0},
      {"",0,0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"writeACQPebMGR", &POA_net::etech::SSM::ACQPebMGRServer::writeACQPebMGR_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"refreshACQPebMGR", &POA_net::etech::SSM::ACQPebMGRServer::refreshACQPebMGR_skel, 0},
      {"",0,0},{"",0,0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_net_etech_SSM_ACQPebMGRServer_Perfect_Hash_OpTable tao_net_etech_SSM_ACQPebMGRServer_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:93

POA_net::etech::SSM::ACQPebMGRServer::ACQPebMGRServer (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_net_etech_SSM_ACQPebMGRServer_optable;
}

POA_net::etech::SSM::ACQPebMGRServer::ACQPebMGRServer (const ACQPebMGRServer& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_net::etech::SSM::ACQPebMGRServer::~ACQPebMGRServer (void)
{
}

namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class refreshACQPebMGR_ACQPebMGRServer
        : public TAO::Upcall_Command
      {
      public:
        inline refreshACQPebMGR_ACQPebMGRServer (
          POA_net::etech::SSM::ACQPebMGRServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::net::etech::ACQ_PEB_MGR>::out_arg_type arg_2 =
            TAO::Portable_Server::get_out_arg< ::net::etech::ACQ_PEB_MGR> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->refreshACQPebMGR (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::ACQPebMGRServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ACQPebMGRServer::refreshACQPebMGR_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::ACQ_PEB_MGR>::out_arg_val _tao_acqPebMgr;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flag,
      &_tao_acqPebMgr
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::ACQPebMGRServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ACQPebMGRServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  refreshACQPebMGR_ACQPebMGRServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class writeACQPebMGR_ACQPebMGRServer
        : public TAO::Upcall_Command
      {
      public:
        inline writeACQPebMGR_ACQPebMGRServer (
          POA_net::etech::SSM::ACQPebMGRServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::net::etech::ACQ_PEB_MGR>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::net::etech::ACQ_PEB_MGR> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->writeACQPebMGR (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::ACQPebMGRServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ACQPebMGRServer::writeACQPebMGR_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_cleanAll;
  TAO::SArg_Traits< ::net::etech::ACQ_PEB_MGR>::in_arg_val _tao_acqPebMgr;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_cleanAll,
      &_tao_acqPebMgr
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::ACQPebMGRServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ACQPebMGRServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  writeACQPebMGR_ACQPebMGRServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class ShutDown_ACQPebMGRServer
        : public TAO::Upcall_Command
      {
      public:
        inline ShutDown_ACQPebMGRServer (
          POA_net::etech::SSM::ACQPebMGRServer * servant)
          : servant_ (servant)
        {
        }

        virtual void execute (void)
        {
          this->servant_->ShutDown ();
        }
      
      private:
        POA_net::etech::SSM::ACQPebMGRServer * const servant_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ACQPebMGRServer::ShutDown_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_net::etech::SSM::ACQPebMGRServer * const impl =
    dynamic_cast<POA_net::etech::SSM::ACQPebMGRServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  ShutDown_ACQPebMGRServer command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:166



::CORBA::Boolean POA_net::etech::SSM::ACQPebMGRServer::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:net/etech/SSM/ACQPebMGRServer:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_net::etech::SSM::ACQPebMGRServer::_interface_repository_id (void) const
{
  return "IDL:net/etech/SSM/ACQPebMGRServer:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:426

void POA_net::etech::SSM::ACQPebMGRServer::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:373

net::etech::SSM::ACQPebMGRServer *
POA_net::etech::SSM::ACQPebMGRServer::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::net::etech::SSM::ACQPebMGRServer STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1868

class TAO_net_etech_SSM_GarbageMonitorServer_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_net_etech_SSM_GarbageMonitorServer_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_net_etech_SSM_GarbageMonitorServer_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20,  0, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20,  0, 20,  0, 20, 20,
      5,  0, 20, 20, 20, 20, 20, 20, 20, 20,
      0, 20, 20, 20,  0, 20,  5, 20, 20,  0,
     20, 20, 20, 20, 20, 20, 20, 20,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_net_etech_SSM_GarbageMonitorServer_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 8,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 19,
      HASH_VALUE_RANGE = 15,
      DUPLICATES = 0,
      WORDLIST_SIZE = 13
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"ShutDown", &POA_net::etech::SSM::GarbageMonitorServer::ShutDown_skel, 0},
      {"",0,0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"",0,0},
      {"writeGarbage", &POA_net::etech::SSM::GarbageMonitorServer::writeGarbage_skel, 0},
      {"",0,0},
      {"refreshGarbage", &POA_net::etech::SSM::GarbageMonitorServer::refreshGarbage_skel, 0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_net_etech_SSM_GarbageMonitorServer_Perfect_Hash_OpTable tao_net_etech_SSM_GarbageMonitorServer_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:93

POA_net::etech::SSM::GarbageMonitorServer::GarbageMonitorServer (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_net_etech_SSM_GarbageMonitorServer_optable;
}

POA_net::etech::SSM::GarbageMonitorServer::GarbageMonitorServer (const GarbageMonitorServer& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_net::etech::SSM::GarbageMonitorServer::~GarbageMonitorServer (void)
{
}

namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class refreshGarbage_GarbageMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline refreshGarbage_GarbageMonitorServer (
          POA_net::etech::SSM::GarbageMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::net::etech::GARBAGE_INFOSeq>::out_arg_type arg_1 =
            TAO::Portable_Server::get_out_arg< ::net::etech::GARBAGE_INFOSeq> (
              this->operation_details_,
              this->args_,
              1);
            
          retval =
            this->servant_->refreshGarbage (
              arg_1);
        }
      
      private:
        POA_net::etech::SSM::GarbageMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::GarbageMonitorServer::refreshGarbage_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::net::etech::GARBAGE_INFOSeq>::out_arg_val _tao_GarbageInfoOut;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_GarbageInfoOut
    };
  
  static size_t const nargs = 2;

  POA_net::etech::SSM::GarbageMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::GarbageMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  refreshGarbage_GarbageMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class writeGarbage_GarbageMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline writeGarbage_GarbageMonitorServer (
          POA_net::etech::SSM::GarbageMonitorServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::net::etech::GARBAGE_INFOSeq>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::net::etech::GARBAGE_INFOSeq> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->writeGarbage (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::GarbageMonitorServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::GarbageMonitorServer::writeGarbage_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_modify;
  TAO::SArg_Traits< ::net::etech::GARBAGE_INFOSeq>::in_arg_val _tao_GarbageInfoIn;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_modify,
      &_tao_GarbageInfoIn
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::GarbageMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::GarbageMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  writeGarbage_GarbageMonitorServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class ShutDown_GarbageMonitorServer
        : public TAO::Upcall_Command
      {
      public:
        inline ShutDown_GarbageMonitorServer (
          POA_net::etech::SSM::GarbageMonitorServer * servant)
          : servant_ (servant)
        {
        }

        virtual void execute (void)
        {
          this->servant_->ShutDown ();
        }
      
      private:
        POA_net::etech::SSM::GarbageMonitorServer * const servant_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::GarbageMonitorServer::ShutDown_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_net::etech::SSM::GarbageMonitorServer * const impl =
    dynamic_cast<POA_net::etech::SSM::GarbageMonitorServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  ShutDown_GarbageMonitorServer command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:166



::CORBA::Boolean POA_net::etech::SSM::GarbageMonitorServer::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:net/etech/SSM/GarbageMonitorServer:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_net::etech::SSM::GarbageMonitorServer::_interface_repository_id (void) const
{
  return "IDL:net/etech/SSM/GarbageMonitorServer:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:426

void POA_net::etech::SSM::GarbageMonitorServer::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:373

net::etech::SSM::GarbageMonitorServer *
POA_net::etech::SSM::GarbageMonitorServer::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::net::etech::SSM::GarbageMonitorServer STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1868

class TAO_net_etech_SSM_PsMonitorMasterServer_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_net_etech_SSM_PsMonitorMasterServer_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_net_etech_SSM_PsMonitorMasterServer_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 50, 50, 50,  0, 50,
     50, 50, 50, 50, 50, 25,  0, 50, 50, 50,
     50, 50, 10, 15, 50, 50, 50, 50, 50, 50,
     50, 50, 50, 50, 50, 20, 50, 10, 50,  5,
     15,  0, 50,  0, 50, 50, 50, 50, 50, 50,
      0, 50, 20, 50,  0,  0, 10, 50, 50, 20,
     50, 50, 50, 50, 50, 50, 50, 50,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_net_etech_SSM_PsMonitorMasterServer_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 28,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 27,
      MIN_HASH_VALUE = 11,
      MAX_HASH_VALUE = 49,
      HASH_VALUE_RANGE = 39,
      DUPLICATES = 0,
      WORDLIST_SIZE = 39
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"",0,0},{"",0,0},
      {"getFilePSWD", &POA_net::etech::SSM::PsMonitorMasterServer::getFilePSWD_skel, 0},
      {"",0,0},
      {"getSystemTime", &POA_net::etech::SSM::PsMonitorMasterServer::getSystemTime_skel, 0},
      {"refreshGarbage", &POA_net::etech::SSM::PsMonitorMasterServer::refreshGarbage_skel, 0},
      {"",0,0},
      {"getDeteilProcess", &POA_net::etech::SSM::PsMonitorMasterServer::getDeteilProcess_skel, 0},
      {"getHistoryProcess", &POA_net::etech::SSM::PsMonitorMasterServer::getHistoryProcess_skel, 0},
      {"createLogFile", &POA_net::etech::SSM::PsMonitorMasterServer::createLogFile_skel, 0},
      {"",0,0},
      {"refreshConfigProcess", &POA_net::etech::SSM::PsMonitorMasterServer::refreshConfigProcess_skel, 0},
      {"refreshMonitorProcess", &POA_net::etech::SSM::PsMonitorMasterServer::refreshMonitorProcess_skel, 0},
      {"refreshConfigBloc", &POA_net::etech::SSM::PsMonitorMasterServer::refreshConfigBloc_skel, 0},
      {"ShutDown", &POA_net::etech::SSM::PsMonitorMasterServer::ShutDown_skel, 0},
      {"",0,0},
      {"resetField", &POA_net::etech::SSM::PsMonitorMasterServer::resetField_skel, 0},
      {"refreshACQPebMGR", &POA_net::etech::SSM::PsMonitorMasterServer::refreshACQPebMGR_skel, 0},
      {"LaunchPsMonitorMasterServer", &POA_net::etech::SSM::PsMonitorMasterServer::LaunchPsMonitorMasterServer_skel, 0},
      {"deleteProcess", &POA_net::etech::SSM::PsMonitorMasterServer::deleteProcess_skel, 0},
      {"deleteBlockLog", &POA_net::etech::SSM::PsMonitorMasterServer::deleteBlockLog_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"putFilePSWD", &POA_net::etech::SSM::PsMonitorMasterServer::putFilePSWD_skel, 0},
      {"writeGarbage", &POA_net::etech::SSM::PsMonitorMasterServer::writeGarbage_skel, 0},
      {"",0,0},
      {"writeModifyLog", &POA_net::etech::SSM::PsMonitorMasterServer::writeModifyLog_skel, 0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"SystemStart", &POA_net::etech::SSM::PsMonitorMasterServer::SystemStart_skel, 0},
      {"",0,0},
      {"writeModifyProcess", &POA_net::etech::SSM::PsMonitorMasterServer::writeModifyProcess_skel, 0},
      {"",0,0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"KillOrbixProcess", &POA_net::etech::SSM::PsMonitorMasterServer::KillOrbixProcess_skel, 0},
      {"",0,0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"writeACQPebMGR", &POA_net::etech::SSM::PsMonitorMasterServer::writeACQPebMGR_skel, 0},
      {"SystemStop", &POA_net::etech::SSM::PsMonitorMasterServer::SystemStop_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_net_etech_SSM_PsMonitorMasterServer_Perfect_Hash_OpTable tao_net_etech_SSM_PsMonitorMasterServer_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:93

POA_net::etech::SSM::PsMonitorMasterServer::PsMonitorMasterServer (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_net_etech_SSM_PsMonitorMasterServer_optable;
}

POA_net::etech::SSM::PsMonitorMasterServer::PsMonitorMasterServer (const PsMonitorMasterServer& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_net::etech::SSM::PsMonitorMasterServer::~PsMonitorMasterServer (void)
{
}

namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class LaunchPsMonitorMasterServer_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline LaunchPsMonitorMasterServer_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::net::etech::CentralSeq>::out_arg_type arg_1 =
            TAO::Portable_Server::get_out_arg< ::net::etech::CentralSeq> (
              this->operation_details_,
              this->args_,
              1);
            
          retval =
            this->servant_->LaunchPsMonitorMasterServer (
              arg_1);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::LaunchPsMonitorMasterServer_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::net::etech::CentralSeq>::out_arg_val _tao_CEN;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_CEN
    };
  
  static size_t const nargs = 2;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  LaunchPsMonitorMasterServer_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class KillOrbixProcess_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline KillOrbixProcess_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->KillOrbixProcess (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::KillOrbixProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_num_pid;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_flag,
      &_tao_num_pid
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  KillOrbixProcess_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class refreshMonitorProcess_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline refreshMonitorProcess_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::net::etech::ProcesDetailSeq>::out_arg_type arg_3 =
            TAO::Portable_Server::get_out_arg< ::net::etech::ProcesDetailSeq> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->refreshMonitorProcess (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::refreshMonitorProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::ProcesDetailSeq>::out_arg_val _tao_procesDetailLis;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_flag,
      &_tao_procesDetailLis
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  refreshMonitorProcess_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class getDeteilProcess_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline getDeteilProcess_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              3);
            
          TAO::SArg_Traits< ::net::etech::LogProcessSeq>::out_arg_type arg_4 =
            TAO::Portable_Server::get_out_arg< ::net::etech::LogProcessSeq> (
              this->operation_details_,
              this->args_,
              4);
            
          retval =
            this->servant_->getDeteilProcess (
              arg_1
              , arg_2
              , arg_3
              , arg_4);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::getDeteilProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flagDETAIL;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nomeProcesso;
  TAO::SArg_Traits< ::net::etech::LogProcessSeq>::out_arg_val _tao_logProcesso;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flagDETAIL,
      &_tao_nameSwitch,
      &_tao_nomeProcesso,
      &_tao_logProcesso
    };
  
  static size_t const nargs = 5;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  getDeteilProcess_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class getSystemTime_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline getSystemTime_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::net::etech::LogProcessSeq>::out_arg_type arg_2 =
            TAO::Portable_Server::get_out_arg< ::net::etech::LogProcessSeq> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->getSystemTime (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::getSystemTime_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::net::etech::LogProcessSeq>::out_arg_val _tao_systemTime;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_systemTime
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  getSystemTime_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class getHistoryProcess_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline getHistoryProcess_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_,
              3);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_4 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              4);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_5 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              5);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_6 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              6);
            
          TAO::SArg_Traits< ::net::etech::LogProcessSeq>::out_arg_type arg_7 =
            TAO::Portable_Server::get_out_arg< ::net::etech::LogProcessSeq> (
              this->operation_details_,
              this->args_,
              7);
            
          retval =
            this->servant_->getHistoryProcess (
              arg_1
              , arg_2
              , arg_3
              , arg_4
              , arg_5
              , arg_6
              , arg_7);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::getHistoryProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flagWORK;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flagSINGLE_ALL_PROCESS;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_flagALLDOCUMENT;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nomeProcesso;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_data;
  TAO::SArg_Traits< ::net::etech::LogProcessSeq>::out_arg_val _tao_logProcesso;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_flagWORK,
      &_tao_flagSINGLE_ALL_PROCESS,
      &_tao_flagALLDOCUMENT,
      &_tao_nameSwitch,
      &_tao_nomeProcesso,
      &_tao_data,
      &_tao_logProcesso
    };
  
  static size_t const nargs = 8;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  getHistoryProcess_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class resetField_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline resetField_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              3);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_4 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              4);
            
          retval =
            this->servant_->resetField (
              arg_1
              , arg_2
              , arg_3
              , arg_4);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::resetField_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_field;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flagTIPORESET;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nomeProcesso;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_field,
      &_tao_flagTIPORESET,
      &_tao_nomeProcesso
    };
  
  static size_t const nargs = 5;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  resetField_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class refreshConfigProcess_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline refreshConfigProcess_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::net::etech::CS_INFO_PROCSeq>::out_arg_type arg_3 =
            TAO::Portable_Server::get_out_arg< ::net::etech::CS_INFO_PROCSeq> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->refreshConfigProcess (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::refreshConfigProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::CS_INFO_PROCSeq>::out_arg_val _tao_configProcesslList;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_flag,
      &_tao_configProcesslList
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  refreshConfigProcess_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class refreshConfigBloc_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline refreshConfigBloc_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::net::etech::CS_BLOCK_LOGSeq>::out_arg_type arg_3 =
            TAO::Portable_Server::get_out_arg< ::net::etech::CS_BLOCK_LOGSeq> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->refreshConfigBloc (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::refreshConfigBloc_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::CS_BLOCK_LOGSeq>::out_arg_val _tao_configBloclList;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_flag,
      &_tao_configBloclList
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  refreshConfigBloc_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class writeModifyProcess_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline writeModifyProcess_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              3);
            
          TAO::SArg_Traits< ::net::etech::CS_INFO_PROC>::in_arg_type arg_4 =
            TAO::Portable_Server::get_in_arg< ::net::etech::CS_INFO_PROC> (
              this->operation_details_,
              this->args_,
              4);
            
          retval =
            this->servant_->writeModifyProcess (
              arg_1
              , arg_2
              , arg_3
              , arg_4);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::writeModifyProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nomeProcesso;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::CS_INFO_PROC>::in_arg_val _tao_configProcess;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nomeProcesso,
      &_tao_nameSwitch,
      &_tao_flag,
      &_tao_configProcess
    };
  
  static size_t const nargs = 5;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  writeModifyProcess_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class writeModifyLog_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline writeModifyLog_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::net::etech::CS_BLOCK_LOGSeq>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::net::etech::CS_BLOCK_LOGSeq> (
              this->operation_details_,
              this->args_,
              3);
            
          TAO::SArg_Traits< ::net::etech::CentralSeq>::out_arg_type arg_4 =
            TAO::Portable_Server::get_out_arg< ::net::etech::CentralSeq> (
              this->operation_details_,
              this->args_,
              4);
            
          retval =
            this->servant_->writeModifyLog (
              arg_1
              , arg_2
              , arg_3
              , arg_4);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::writeModifyLog_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::CS_BLOCK_LOGSeq>::in_arg_val _tao_configBloclList;
  TAO::SArg_Traits< ::net::etech::CentralSeq>::out_arg_val _tao_switchSeq;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_flag,
      &_tao_configBloclList,
      &_tao_switchSeq
    };
  
  static size_t const nargs = 5;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  writeModifyLog_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class createLogFile_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline createLogFile_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->createLogFile (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::createLogFile_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_flag
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  createLogFile_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class deleteProcess_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline deleteProcess_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->deleteProcess (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::deleteProcess_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nomeProcesso;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_flag,
      &_tao_nomeProcesso
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  deleteProcess_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class deleteBlockLog_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline deleteBlockLog_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              3);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_4 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              4);
            
          retval =
            this->servant_->deleteBlockLog (
              arg_1
              , arg_2
              , arg_3
              , arg_4);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::deleteBlockLog_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_idBlock;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_idFep;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_flag,
      &_tao_idBlock,
      &_tao_idFep
    };
  
  static size_t const nargs = 5;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  deleteBlockLog_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class SystemStart_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline SystemStart_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->SystemStart (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::SystemStart_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_flag
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  SystemStart_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class SystemStop_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline SystemStop_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->SystemStop (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::SystemStop_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_flag
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  SystemStop_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class refreshACQPebMGR_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline refreshACQPebMGR_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::net::etech::ACQ_PEB_MGR>::out_arg_type arg_3 =
            TAO::Portable_Server::get_out_arg< ::net::etech::ACQ_PEB_MGR> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->refreshACQPebMGR (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::refreshACQPebMGR_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::ACQ_PEB_MGR>::out_arg_val _tao_acqPebMgr;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_flag,
      &_tao_acqPebMgr
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  refreshACQPebMGR_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class writeACQPebMGR_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline writeACQPebMGR_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::net::etech::ACQ_PEB_MGR>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::net::etech::ACQ_PEB_MGR> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->writeACQPebMGR (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::writeACQPebMGR_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_cleanAll;
  TAO::SArg_Traits< ::net::etech::ACQ_PEB_MGR>::in_arg_val _tao_acqPebMgr;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_cleanAll,
      &_tao_acqPebMgr
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  writeACQPebMGR_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class refreshGarbage_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline refreshGarbage_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::net::etech::GARBAGE_INFOSeq>::out_arg_type arg_2 =
            TAO::Portable_Server::get_out_arg< ::net::etech::GARBAGE_INFOSeq> (
              this->operation_details_,
              this->args_,
              2);
            
          retval =
            this->servant_->refreshGarbage (
              arg_1
              , arg_2);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::refreshGarbage_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::net::etech::GARBAGE_INFOSeq>::out_arg_val _tao_GarbageInfoOut;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_GarbageInfoOut
    };
  
  static size_t const nargs = 3;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  refreshGarbage_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class writeGarbage_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline writeGarbage_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::net::etech::GARBAGE_INFOSeq>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::net::etech::GARBAGE_INFOSeq> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->writeGarbage (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::writeGarbage_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_modify;
  TAO::SArg_Traits< ::net::etech::GARBAGE_INFOSeq>::in_arg_val _tao_GarbageInfoIn;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_modify,
      &_tao_GarbageInfoIn
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  writeGarbage_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class putFilePSWD_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline putFilePSWD_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              3);
            
          TAO::SArg_Traits< ::net::etech::GESTIONE_PSWDSeq>::in_arg_type arg_4 =
            TAO::Portable_Server::get_in_arg< ::net::etech::GESTIONE_PSWDSeq> (
              this->operation_details_,
              this->args_,
              4);
            
          retval =
            this->servant_->putFilePSWD (
              arg_1
              , arg_2
              , arg_3
              , arg_4);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::putFilePSWD_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameFile;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::GESTIONE_PSWDSeq>::in_arg_val _tao_pswdSequence;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_nameFile,
      &_tao_flag,
      &_tao_pswdSequence
    };
  
  static size_t const nargs = 5;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  putFilePSWD_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class getFilePSWD_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline getFilePSWD_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< char *>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              3);
            
          TAO::SArg_Traits< ::net::etech::GESTIONE_PSWDSeq>::out_arg_type arg_4 =
            TAO::Portable_Server::get_out_arg< ::net::etech::GESTIONE_PSWDSeq> (
              this->operation_details_,
              this->args_,
              4);
            
          retval =
            this->servant_->getFilePSWD (
              arg_1
              , arg_2
              , arg_3
              , arg_4);
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::getFilePSWD_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameSwitch;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameFile;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::GESTIONE_PSWDSeq>::out_arg_val _tao_pswdSequence;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameSwitch,
      &_tao_nameFile,
      &_tao_flag,
      &_tao_pswdSequence
    };
  
  static size_t const nargs = 5;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  getFilePSWD_PsMonitorMasterServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class ShutDown_PsMonitorMasterServer
        : public TAO::Upcall_Command
      {
      public:
        inline ShutDown_PsMonitorMasterServer (
          POA_net::etech::SSM::PsMonitorMasterServer * servant)
          : servant_ (servant)
        {
        }

        virtual void execute (void)
        {
          this->servant_->ShutDown ();
        }
      
      private:
        POA_net::etech::SSM::PsMonitorMasterServer * const servant_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::PsMonitorMasterServer::ShutDown_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_net::etech::SSM::PsMonitorMasterServer * const impl =
    dynamic_cast<POA_net::etech::SSM::PsMonitorMasterServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  ShutDown_PsMonitorMasterServer command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:166



::CORBA::Boolean POA_net::etech::SSM::PsMonitorMasterServer::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:net/etech/SSM/PsMonitorMasterServer:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_net::etech::SSM::PsMonitorMasterServer::_interface_repository_id (void) const
{
  return "IDL:net/etech/SSM/PsMonitorMasterServer:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:426

void POA_net::etech::SSM::PsMonitorMasterServer::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:373

net::etech::SSM::PsMonitorMasterServer *
POA_net::etech::SSM::PsMonitorMasterServer::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::net::etech::SSM::PsMonitorMasterServer STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1868

class TAO_net_etech_SSM_DBConfigurationServer_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_net_etech_SSM_DBConfigurationServer_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_net_etech_SSM_DBConfigurationServer_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19,  0, 19,
     19,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  5, 19,  5, 19, 19, 19, 19, 19, 19,
      0, 19,  0, 19,  0, 19,  0, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_net_etech_SSM_DBConfigurationServer_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 18,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0,
      WORDLIST_SIZE = 14
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"ShutDown", &POA_net::etech::SSM::DBConfigurationServer::ShutDown_skel, 0},
      {"",0,0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"putFilePSWD", &POA_net::etech::SSM::DBConfigurationServer::putFilePSWD_skel, 0},
      {"",0,0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"getFilePSWD", &POA_net::etech::SSM::DBConfigurationServer::getFilePSWD_skel, 0},
      {"",0,0},
      {"renameIndexTimeCFG", &POA_net::etech::SSM::DBConfigurationServer::renameIndexTimeCFG_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_net_etech_SSM_DBConfigurationServer_Perfect_Hash_OpTable tao_net_etech_SSM_DBConfigurationServer_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:93

POA_net::etech::SSM::DBConfigurationServer::DBConfigurationServer (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_net_etech_SSM_DBConfigurationServer_optable;
}

POA_net::etech::SSM::DBConfigurationServer::DBConfigurationServer (const DBConfigurationServer& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_net::etech::SSM::DBConfigurationServer::~DBConfigurationServer (void)
{
}

namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class renameIndexTimeCFG_DBConfigurationServer
        : public TAO::Upcall_Command
      {
      public:
        inline renameIndexTimeCFG_DBConfigurationServer (
          POA_net::etech::SSM::DBConfigurationServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          retval =
            this->servant_->renameIndexTimeCFG (
              arg_1);
        }
      
      private:
        POA_net::etech::SSM::DBConfigurationServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::DBConfigurationServer::renameIndexTimeCFG_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameFile;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameFile
    };
  
  static size_t const nargs = 2;

  POA_net::etech::SSM::DBConfigurationServer * const impl =
    dynamic_cast<POA_net::etech::SSM::DBConfigurationServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  renameIndexTimeCFG_DBConfigurationServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class putFilePSWD_DBConfigurationServer
        : public TAO::Upcall_Command
      {
      public:
        inline putFilePSWD_DBConfigurationServer (
          POA_net::etech::SSM::DBConfigurationServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::net::etech::GESTIONE_PSWDSeq>::in_arg_type arg_3 =
            TAO::Portable_Server::get_in_arg< ::net::etech::GESTIONE_PSWDSeq> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->putFilePSWD (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::DBConfigurationServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::DBConfigurationServer::putFilePSWD_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameFile;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::GESTIONE_PSWDSeq>::in_arg_val _tao_pswdSequence;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameFile,
      &_tao_flag,
      &_tao_pswdSequence
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::DBConfigurationServer * const impl =
    dynamic_cast<POA_net::etech::SSM::DBConfigurationServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  putFilePSWD_DBConfigurationServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class getFilePSWD_DBConfigurationServer
        : public TAO::Upcall_Command
      {
      public:
        inline getFilePSWD_DBConfigurationServer (
          POA_net::etech::SSM::DBConfigurationServer * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
            TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
              this->operation_details_,
              this->args_,
              2);
            
          TAO::SArg_Traits< ::net::etech::GESTIONE_PSWDSeq>::out_arg_type arg_3 =
            TAO::Portable_Server::get_out_arg< ::net::etech::GESTIONE_PSWDSeq> (
              this->operation_details_,
              this->args_,
              3);
            
          retval =
            this->servant_->getFilePSWD (
              arg_1
              , arg_2
              , arg_3);
        }
      
      private:
        POA_net::etech::SSM::DBConfigurationServer * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::DBConfigurationServer::getFilePSWD_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_nameFile;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_flag;
  TAO::SArg_Traits< ::net::etech::GESTIONE_PSWDSeq>::out_arg_val _tao_pswdSequence;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_nameFile,
      &_tao_flag,
      &_tao_pswdSequence
    };
  
  static size_t const nargs = 4;

  POA_net::etech::SSM::DBConfigurationServer * const impl =
    dynamic_cast<POA_net::etech::SSM::DBConfigurationServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  getFilePSWD_DBConfigurationServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class ShutDown_DBConfigurationServer
        : public TAO::Upcall_Command
      {
      public:
        inline ShutDown_DBConfigurationServer (
          POA_net::etech::SSM::DBConfigurationServer * servant)
          : servant_ (servant)
        {
        }

        virtual void execute (void)
        {
          this->servant_->ShutDown ();
        }
      
      private:
        POA_net::etech::SSM::DBConfigurationServer * const servant_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::DBConfigurationServer::ShutDown_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_net::etech::SSM::DBConfigurationServer * const impl =
    dynamic_cast<POA_net::etech::SSM::DBConfigurationServer *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  ShutDown_DBConfigurationServer command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:166



::CORBA::Boolean POA_net::etech::SSM::DBConfigurationServer::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:net/etech/SSM/DBConfigurationServer:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_net::etech::SSM::DBConfigurationServer::_interface_repository_id (void) const
{
  return "IDL:net/etech/SSM/DBConfigurationServer:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:426

void POA_net::etech::SSM::DBConfigurationServer::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:373

net::etech::SSM::DBConfigurationServer *
POA_net::etech::SSM::DBConfigurationServer::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::net::etech::SSM::DBConfigurationServer STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1868

class TAO_net_etech_SSM_ssm_scheduler_server_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_net_etech_SSM_ssm_scheduler_server_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_net_etech_SSM_ssm_scheduler_server_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28,  0, 28,  0, 28, 28,
      0, 10, 28, 28, 28,  5, 28, 28, 28, 28,
     28, 28,  0, 28, 28, 28,  0, 28, 28, 28,
     28, 10, 28, 28, 28, 28, 28, 28,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_net_etech_SSM_ssm_scheduler_server_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 27,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 27,
      HASH_VALUE_RANGE = 23,
      DUPLICATES = 0,
      WORDLIST_SIZE = 14
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"dummy", &POA_net::etech::SSM::ssm_scheduler_server::dummy_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"iniFileChanged", &POA_net::etech::SSM::ssm_scheduler_server::iniFileChanged_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"adamsConfigurationChanged", &POA_net::etech::SSM::ssm_scheduler_server::adamsConfigurationChanged_skel, 0},
      {"",0,0},
      {"processConfigurationChanged", &POA_net::etech::SSM::ssm_scheduler_server::processConfigurationChanged_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_net_etech_SSM_ssm_scheduler_server_Perfect_Hash_OpTable tao_net_etech_SSM_ssm_scheduler_server_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:93

POA_net::etech::SSM::ssm_scheduler_server::ssm_scheduler_server (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_net_etech_SSM_ssm_scheduler_server_optable;
}

POA_net::etech::SSM::ssm_scheduler_server::ssm_scheduler_server (const ssm_scheduler_server& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_net::etech::SSM::ssm_scheduler_server::~ssm_scheduler_server (void)
{
}

namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class adamsConfigurationChanged_ssm_scheduler_server
        : public TAO::Upcall_Command
      {
      public:
        inline adamsConfigurationChanged_ssm_scheduler_server (
          POA_net::etech::SSM::ssm_scheduler_server * servant)
          : servant_ (servant)
        {
        }

        virtual void execute (void)
        {
          this->servant_->adamsConfigurationChanged ();
        }
      
      private:
        POA_net::etech::SSM::ssm_scheduler_server * const servant_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ssm_scheduler_server::adamsConfigurationChanged_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_net::etech::SSM::ssm_scheduler_server * const impl =
    dynamic_cast<POA_net::etech::SSM::ssm_scheduler_server *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  adamsConfigurationChanged_ssm_scheduler_server command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class processConfigurationChanged_ssm_scheduler_server
        : public TAO::Upcall_Command
      {
      public:
        inline processConfigurationChanged_ssm_scheduler_server (
          POA_net::etech::SSM::ssm_scheduler_server * servant)
          : servant_ (servant)
        {
        }

        virtual void execute (void)
        {
          this->servant_->processConfigurationChanged ();
        }
      
      private:
        POA_net::etech::SSM::ssm_scheduler_server * const servant_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ssm_scheduler_server::processConfigurationChanged_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_net::etech::SSM::ssm_scheduler_server * const impl =
    dynamic_cast<POA_net::etech::SSM::ssm_scheduler_server *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  processConfigurationChanged_ssm_scheduler_server command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class iniFileChanged_ssm_scheduler_server
        : public TAO::Upcall_Command
      {
      public:
        inline iniFileChanged_ssm_scheduler_server (
          POA_net::etech::SSM::ssm_scheduler_server * servant)
          : servant_ (servant)
        {
        }

        virtual void execute (void)
        {
          this->servant_->iniFileChanged ();
        }
      
      private:
        POA_net::etech::SSM::ssm_scheduler_server * const servant_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ssm_scheduler_server::iniFileChanged_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_net::etech::SSM::ssm_scheduler_server * const impl =
    dynamic_cast<POA_net::etech::SSM::ssm_scheduler_server *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  iniFileChanged_ssm_scheduler_server command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class dummy_ssm_scheduler_server
        : public TAO::Upcall_Command
      {
      public:
        inline dummy_ssm_scheduler_server (
          POA_net::etech::SSM::ssm_scheduler_server * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          retval =
            this->servant_->dummy ();
        }
      
      private:
        POA_net::etech::SSM::ssm_scheduler_server * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ssm_scheduler_server::dummy_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_net::etech::SSM::ssm_scheduler_server * const impl =
    dynamic_cast<POA_net::etech::SSM::ssm_scheduler_server *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  dummy_ssm_scheduler_server command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:166



::CORBA::Boolean POA_net::etech::SSM::ssm_scheduler_server::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:net/etech/SSM/ssm_scheduler_server:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_net::etech::SSM::ssm_scheduler_server::_interface_repository_id (void) const
{
  return "IDL:net/etech/SSM/ssm_scheduler_server:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:426

void POA_net::etech::SSM::ssm_scheduler_server::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:373

net::etech::SSM::ssm_scheduler_server *
POA_net::etech::SSM::ssm_scheduler_server::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::net::etech::SSM::ssm_scheduler_server STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1868

class TAO_net_etech_SSM_ssm_logger_server_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_net_etech_SSM_ssm_logger_server_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_net_etech_SSM_ssm_logger_server_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16,  0, 16,  0, 16, 16,
      0,  5, 16,  0, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16,  0,  0, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_net_etech_SSM_ssm_logger_server_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 15,
      HASH_VALUE_RANGE = 11,
      DUPLICATES = 0,
      WORDLIST_SIZE = 11
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"get_logs", &POA_net::etech::SSM::ssm_logger_server::get_logs_skel, 0},
      {"",0,0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_net_etech_SSM_ssm_logger_server_Perfect_Hash_OpTable tao_net_etech_SSM_ssm_logger_server_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:93

POA_net::etech::SSM::ssm_logger_server::ssm_logger_server (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_net_etech_SSM_ssm_logger_server_optable;
}

POA_net::etech::SSM::ssm_logger_server::ssm_logger_server (const ssm_logger_server& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_net::etech::SSM::ssm_logger_server::~ssm_logger_server (void)
{
}

namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class get_logs_ssm_logger_server
        : public TAO::Upcall_Command
      {
      public:
        inline get_logs_ssm_logger_server (
          POA_net::etech::SSM::ssm_logger_server * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          TAO::SArg_Traits< char *>::in_arg_type arg_1 =
            TAO::Portable_Server::get_in_arg< char *> (
              this->operation_details_,
              this->args_,
              1);
            
          retval =
            this->servant_->get_logs (
              arg_1);
        }
      
      private:
        POA_net::etech::SSM::ssm_logger_server * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ssm_logger_server::get_logs_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< char *>::in_arg_val _tao_process_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_process_name
    };
  
  static size_t const nargs = 2;

  POA_net::etech::SSM::ssm_logger_server * const impl =
    dynamic_cast<POA_net::etech::SSM::ssm_logger_server *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  get_logs_ssm_logger_server command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:166



::CORBA::Boolean POA_net::etech::SSM::ssm_logger_server::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:net/etech/SSM/ssm_logger_server:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_net::etech::SSM::ssm_logger_server::_interface_repository_id (void) const
{
  return "IDL:net/etech/SSM/ssm_logger_server:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:426

void POA_net::etech::SSM::ssm_logger_server::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:373

net::etech::SSM::ssm_logger_server *
POA_net::etech::SSM::ssm_logger_server::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::net::etech::SSM::ssm_logger_server STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1868

class TAO_net_etech_SSM_ssm_garbage_server_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_net_etech_SSM_ssm_garbage_server_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_net_etech_SSM_ssm_garbage_server_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16,  0, 16,  2, 16, 16,
      0,  5, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16,  0, 16, 16, 16,
     16,  0, 16, 16, 16, 16, 16, 16,
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_net_etech_SSM_ssm_garbage_server_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 15,
      HASH_VALUE_RANGE = 11,
      DUPLICATES = 0,
      WORDLIST_SIZE = 11
    };

  static const TAO_operation_db_entry wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"dummy", &POA_net::etech::SSM::ssm_garbage_server::dummy_skel, 0},
      {"",0,0},
      {"_is_a", &TAO_ServantBase::_is_a_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"_component", &TAO_ServantBase::_component_thru_poa_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &TAO_ServantBase::_non_existent_thru_poa_skel, 0},
      {"_repository_id", &TAO_ServantBase::_repository_id_thru_poa_skel, 0},
      {"_interface", &TAO_ServantBase::_interface_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_net_etech_SSM_ssm_garbage_server_Perfect_Hash_OpTable tao_net_etech_SSM_ssm_garbage_server_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:93

POA_net::etech::SSM::ssm_garbage_server::ssm_garbage_server (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_net_etech_SSM_ssm_garbage_server_optable;
}

POA_net::etech::SSM::ssm_garbage_server::ssm_garbage_server (const ssm_garbage_server& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_net::etech::SSM::ssm_garbage_server::~ssm_garbage_server (void)
{
}

namespace POA_net
{
  
  namespace etech
  {
    
    namespace SSM
    {
      

      // TAO_IDL - Generated from
      // be/be_visitor_operation/upcall_command_ss.cpp:83

      class dummy_ssm_garbage_server
        : public TAO::Upcall_Command
      {
      public:
        inline dummy_ssm_garbage_server (
          POA_net::etech::SSM::ssm_garbage_server * servant,
          TAO_Operation_Details const * operation_details,
          TAO::Argument * const args[])
          : servant_ (servant)
            , operation_details_ (operation_details)
            , args_ (args)
        {
        }

        virtual void execute (void)
        {
          TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
            TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
              this->operation_details_,
              this->args_);
          
          retval =
            this->servant_->dummy ();
        }
      
      private:
        POA_net::etech::SSM::ssm_garbage_server * const servant_;
        TAO_Operation_Details const * const operation_details_;
        TAO::Argument * const * const args_;
      };
    }
  }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_ss.cpp:171

void POA_net::etech::SSM::ssm_garbage_server::dummy_skel (
  TAO_ServerRequest & server_request,
  TAO::Portable_Server::Servant_Upcall *TAO_INTERCEPTOR (servant_upcall),
  TAO_ServantBase *servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;

  POA_net::etech::SSM::ssm_garbage_server * const impl =
    dynamic_cast<POA_net::etech::SSM::ssm_garbage_server *> (servant);

  if (!impl)
    {
      throw ::CORBA::INTERNAL ();
    }

  dummy_ssm_garbage_server command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:166



::CORBA::Boolean POA_net::etech::SSM::ssm_garbage_server::_is_a (const char* value)
{
  return
    (
      ACE_OS::strcmp (
          value,
          "IDL:net/etech/SSM/ssm_garbage_server:1.0"
        ) == 0 ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_net::etech::SSM::ssm_garbage_server::_interface_repository_id (void) const
{
  return "IDL:net/etech/SSM/ssm_garbage_server:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:426

void POA_net::etech::SSM::ssm_garbage_server::_dispatch (
  TAO_ServerRequest & req,
  TAO::Portable_Server::Servant_Upcall* servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:373

net::etech::SSM::ssm_garbage_server *
POA_net::etech::SSM::ssm_garbage_server::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0);
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::net::etech::SSM::ssm_garbage_server STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in ());
}

#endif /* ifndef */

