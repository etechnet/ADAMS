// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.2.4
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:152

#ifndef _TAO_IDL_SSMC_1SBRSJ_H_
#define _TAO_IDL_SSMC_1SBRSJ_H_

#include /**/ "ace/pre.h"


#include /**/ <ace/config-all.h>

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#include <tao/ORB.h>
#include <tao/SystemException.h>
#include <tao/Basic_Types.h>
#include <tao/ORB_Constants.h>
#include <tao/Object.h>
#include <tao/Sequence_T.h>
#include <tao/Objref_VarOut_T.h>
#include <tao/Seq_Var_T.h>
#include <tao/Seq_Out_T.h>
#include <tao/VarOut_T.h>
#include <tao/Array_VarOut_T.h>
#include <tao/Arg_Traits_T.h>
#include <tao/Basic_Arguments.h>
#include <tao/Special_Basic_Arguments.h>
#include <tao/Any_Insert_Policy_T.h>
#include <tao/Fixed_Size_Argument_T.h>
#include <tao/Var_Size_Argument_T.h>
#include <tao/Object_Argument_T.h>
#include <tao/Special_Basic_Arguments.h>
#include <tao/UB_String_Arguments.h>
#include <tao/Fixed_Array_Argument_T.h>
#include <tao/Var_Array_Argument_T.h>
#include /**/ <tao/Version.h>
#include /**/ <tao/Versioned_Namespace.h>

#if TAO_MAJOR_VERSION != 2 || TAO_MINOR_VERSION != 2 || TAO_BETA_VERSION != 4
#error This file should be regenerated with TAO_IDL
#endif

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO 

// TAO_IDL - Generated from
// be/be_visitor_root/root_ch.cpp:160
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<typename T> class Narrow_Utils;
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:38

namespace net
{

  // TAO_IDL - Generated from
  // be/be_visitor_module/module_ch.cpp:38

  namespace etech
  {

    // TAO_IDL - Generated from
    // be/be_type.cpp:261

    struct DATA_CENTRALI;

    typedef
      ::TAO_Fixed_Var_T<
          DATA_CENTRALI
        >
      DATA_CENTRALI_var;

    typedef
      DATA_CENTRALI &
      DATA_CENTRALI_out;

    // TAO_IDL - Generated from
    // be/be_visitor_structure/structure_ch.cpp:51

    struct  DATA_CENTRALI
    {

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef DATA_CENTRALI_var _var_type;
      typedef DATA_CENTRALI_out _out_type;
      
      ::CORBA::Long IdCentrale;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _Descrizione[30];
      typedef ::CORBA::Char _Descrizione_slice;
      struct _Descrizione_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _Descrizione,
            _Descrizione_slice,
            _Descrizione_tag
          >
        _Descrizione_forany;

      static _Descrizione_slice *
      _Descrizione_alloc (void);

      static void
      _Descrizione_free (
          _Descrizione_slice *_tao_slice);
      
      static _Descrizione_slice *
      _Descrizione_dup (
          const _Descrizione_slice *_tao_slice);
      
      static void
      _Descrizione_copy (
          _Descrizione_slice *_tao_to,
          const _Descrizione_slice *_tao_from
        );

      _Descrizione Descrizione;
    };

    // TAO_IDL - Generated from
    // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_NET_ETECH_CENTRALSEQ_CH_)
#define _NET_ETECH_CENTRALSEQ_CH_

    class CentralSeq;

    typedef
      ::TAO_FixedSeq_Var_T<
          CentralSeq
        >
      CentralSeq_var;

    typedef
      ::TAO_Seq_Out_T<
          CentralSeq
        >
      CentralSeq_out;

    class  CentralSeq
      : public
          ::TAO::unbounded_value_sequence<
              DATA_CENTRALI
            >
    {
    public:
      CentralSeq (void);
      CentralSeq ( ::CORBA::ULong max);
      CentralSeq (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        DATA_CENTRALI* buffer,
        ::CORBA::Boolean release = false);
      CentralSeq (const CentralSeq &);
      virtual ~CentralSeq (void);
      

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef CentralSeq_var _var_type;
      typedef CentralSeq_out _out_type;
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // be/be_type.cpp:261

    struct logProcess;

    typedef
      ::TAO_Fixed_Var_T<
          logProcess
        >
      logProcess_var;

    typedef
      logProcess &
      logProcess_out;

    // TAO_IDL - Generated from
    // be/be_visitor_structure/structure_ch.cpp:51

    struct  logProcess
    {

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef logProcess_var _var_type;
      typedef logProcess_out _out_type;
      
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _descr[250];
      typedef ::CORBA::Char _descr_slice;
      struct _descr_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _descr,
            _descr_slice,
            _descr_tag
          >
        _descr_forany;

      static _descr_slice *
      _descr_alloc (void);

      static void
      _descr_free (
          _descr_slice *_tao_slice);
      
      static _descr_slice *
      _descr_dup (
          const _descr_slice *_tao_slice);
      
      static void
      _descr_copy (
          _descr_slice *_tao_to,
          const _descr_slice *_tao_from
        );

      _descr descr;
    };

    // TAO_IDL - Generated from
    // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_NET_ETECH_LOGPROCESSSEQ_CH_)
#define _NET_ETECH_LOGPROCESSSEQ_CH_

    class LogProcessSeq;

    typedef
      ::TAO_FixedSeq_Var_T<
          LogProcessSeq
        >
      LogProcessSeq_var;

    typedef
      ::TAO_Seq_Out_T<
          LogProcessSeq
        >
      LogProcessSeq_out;

    class  LogProcessSeq
      : public
          ::TAO::unbounded_value_sequence<
              logProcess
            >
    {
    public:
      LogProcessSeq (void);
      LogProcessSeq ( ::CORBA::ULong max);
      LogProcessSeq (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        logProcess* buffer,
        ::CORBA::Boolean release = false);
      LogProcessSeq (const LogProcessSeq &);
      virtual ~LogProcessSeq (void);
      

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef LogProcessSeq_var _var_type;
      typedef LogProcessSeq_out _out_type;
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_NET_ETECH_PARAMSEQSEQ_CH_)
#define _NET_ETECH_PARAMSEQSEQ_CH_

    class ParamSeqSeq;

    typedef
      ::TAO_FixedSeq_Var_T<
          ParamSeqSeq
        >
      ParamSeqSeq_var;

    typedef
      ::TAO_Seq_Out_T<
          ParamSeqSeq
        >
      ParamSeqSeq_out;

    class  ParamSeqSeq
      : public
          ::TAO::unbounded_value_sequence<
              ::CORBA::Long
            >
    {
    public:
      ParamSeqSeq (void);
      ParamSeqSeq ( ::CORBA::ULong max);
      ParamSeqSeq (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        ::CORBA::Long* buffer,
        ::CORBA::Boolean release = false);
      ParamSeqSeq (const ParamSeqSeq &);
      virtual ~ParamSeqSeq (void);
      

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef ParamSeqSeq_var _var_type;
      typedef ParamSeqSeq_out _out_type;
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // be/be_type.cpp:261

    struct ProcesDetail;

    typedef
      ::TAO_Var_Var_T<
          ProcesDetail
        >
      ProcesDetail_var;

    typedef
      ::TAO_Out_T<
          ProcesDetail
        >
      ProcesDetail_out;

    // TAO_IDL - Generated from
    // be/be_visitor_structure/structure_ch.cpp:51

    struct  ProcesDetail
    {

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef ProcesDetail_var _var_type;
      typedef ProcesDetail_out _out_type;
      
      ::CORBA::Long idProcesso;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _tipoProcesso[10];
      typedef ::CORBA::Char _tipoProcesso_slice;
      struct _tipoProcesso_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _tipoProcesso,
            _tipoProcesso_slice,
            _tipoProcesso_tag
          >
        _tipoProcesso_forany;

      static _tipoProcesso_slice *
      _tipoProcesso_alloc (void);

      static void
      _tipoProcesso_free (
          _tipoProcesso_slice *_tao_slice);
      
      static _tipoProcesso_slice *
      _tipoProcesso_dup (
          const _tipoProcesso_slice *_tao_slice);
      
      static void
      _tipoProcesso_copy (
          _tipoProcesso_slice *_tao_to,
          const _tipoProcesso_slice *_tao_from
        );

      _tipoProcesso tipoProcesso;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _nomeProcesso[100];
      typedef ::CORBA::Char _nomeProcesso_slice;
      struct _nomeProcesso_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _nomeProcesso,
            _nomeProcesso_slice,
            _nomeProcesso_tag
          >
        _nomeProcesso_forany;

      static _nomeProcesso_slice *
      _nomeProcesso_alloc (void);

      static void
      _nomeProcesso_free (
          _nomeProcesso_slice *_tao_slice);
      
      static _nomeProcesso_slice *
      _nomeProcesso_dup (
          const _nomeProcesso_slice *_tao_slice);
      
      static void
      _nomeProcesso_copy (
          _nomeProcesso_slice *_tao_to,
          const _nomeProcesso_slice *_tao_from
        );

      _nomeProcesso nomeProcesso;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _colorBKnomeProcesso[10];
      typedef ::CORBA::Char _colorBKnomeProcesso_slice;
      struct _colorBKnomeProcesso_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _colorBKnomeProcesso,
            _colorBKnomeProcesso_slice,
            _colorBKnomeProcesso_tag
          >
        _colorBKnomeProcesso_forany;

      static _colorBKnomeProcesso_slice *
      _colorBKnomeProcesso_alloc (void);

      static void
      _colorBKnomeProcesso_free (
          _colorBKnomeProcesso_slice *_tao_slice);
      
      static _colorBKnomeProcesso_slice *
      _colorBKnomeProcesso_dup (
          const _colorBKnomeProcesso_slice *_tao_slice);
      
      static void
      _colorBKnomeProcesso_copy (
          _colorBKnomeProcesso_slice *_tao_to,
          const _colorBKnomeProcesso_slice *_tao_from
        );

      _colorBKnomeProcesso colorBKnomeProcesso;
      net::etech::ParamSeqSeq param;
      ::CORBA::Long statusProcesso;
      ::CORBA::Long numRestartTime;
      ::CORBA::Boolean flagSched;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _msgProcesso[150];
      typedef ::CORBA::Char _msgProcesso_slice;
      struct _msgProcesso_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _msgProcesso,
            _msgProcesso_slice,
            _msgProcesso_tag
          >
        _msgProcesso_forany;

      static _msgProcesso_slice *
      _msgProcesso_alloc (void);

      static void
      _msgProcesso_free (
          _msgProcesso_slice *_tao_slice);
      
      static _msgProcesso_slice *
      _msgProcesso_dup (
          const _msgProcesso_slice *_tao_slice);
      
      static void
      _msgProcesso_copy (
          _msgProcesso_slice *_tao_to,
          const _msgProcesso_slice *_tao_from
        );

      _msgProcesso msgProcesso;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _colorBKmsgProcesso[10];
      typedef ::CORBA::Char _colorBKmsgProcesso_slice;
      struct _colorBKmsgProcesso_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _colorBKmsgProcesso,
            _colorBKmsgProcesso_slice,
            _colorBKmsgProcesso_tag
          >
        _colorBKmsgProcesso_forany;

      static _colorBKmsgProcesso_slice *
      _colorBKmsgProcesso_alloc (void);

      static void
      _colorBKmsgProcesso_free (
          _colorBKmsgProcesso_slice *_tao_slice);
      
      static _colorBKmsgProcesso_slice *
      _colorBKmsgProcesso_dup (
          const _colorBKmsgProcesso_slice *_tao_slice);
      
      static void
      _colorBKmsgProcesso_copy (
          _colorBKmsgProcesso_slice *_tao_to,
          const _colorBKmsgProcesso_slice *_tao_from
        );

      _colorBKmsgProcesso colorBKmsgProcesso;
    };

    // TAO_IDL - Generated from
    // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_NET_ETECH_PROCESDETAILSEQ_CH_)
#define _NET_ETECH_PROCESDETAILSEQ_CH_

    class ProcesDetailSeq;

    typedef
      ::TAO_VarSeq_Var_T<
          ProcesDetailSeq
        >
      ProcesDetailSeq_var;

    typedef
      ::TAO_Seq_Out_T<
          ProcesDetailSeq
        >
      ProcesDetailSeq_out;

    class  ProcesDetailSeq
      : public
          ::TAO::unbounded_value_sequence<
              ProcesDetail
            >
    {
    public:
      ProcesDetailSeq (void);
      ProcesDetailSeq ( ::CORBA::ULong max);
      ProcesDetailSeq (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        ProcesDetail* buffer,
        ::CORBA::Boolean release = false);
      ProcesDetailSeq (const ProcesDetailSeq &);
      virtual ~ProcesDetailSeq (void);
      

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef ProcesDetailSeq_var _var_type;
      typedef ProcesDetailSeq_out _out_type;
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // be/be_type.cpp:261

    struct tempoRis;

    typedef
      ::TAO_Fixed_Var_T<
          tempoRis
        >
      tempoRis_var;

    typedef
      tempoRis &
      tempoRis_out;

    // TAO_IDL - Generated from
    // be/be_visitor_structure/structure_ch.cpp:51

    struct  tempoRis
    {

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef tempoRis_var _var_type;
      typedef tempoRis_out _out_type;
      
      ::CORBA::Long giorno;
      ::CORBA::Long mese;
      ::CORBA::Long anno;
      ::CORBA::Long ore;
      ::CORBA::Long min;
    };

    // TAO_IDL - Generated from
    // be/be_type.cpp:261

    struct CS_INFO_PROC;

    typedef
      ::TAO_Fixed_Var_T<
          CS_INFO_PROC
        >
      CS_INFO_PROC_var;

    typedef
      CS_INFO_PROC &
      CS_INFO_PROC_out;

    // TAO_IDL - Generated from
    // be/be_visitor_structure/structure_ch.cpp:51

    struct  CS_INFO_PROC
    {

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef CS_INFO_PROC_var _var_type;
      typedef CS_INFO_PROC_out _out_type;
      
      net::etech::tempoRis tempo_proc;
      ::CORBA::Long flag_attiv;
      ::CORBA::Long flag_sched;
      ::CORBA::Long num_proc;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Long _legami[10];
      typedef ::CORBA::Long _legami_slice;
      struct _legami_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _legami,
            _legami_slice,
            _legami_tag
          >
        _legami_forany;

      static _legami_slice *
      _legami_alloc (void);

      static void
      _legami_free (
          _legami_slice *_tao_slice);
      
      static _legami_slice *
      _legami_dup (
          const _legami_slice *_tao_slice);
      
      static void
      _legami_copy (
          _legami_slice *_tao_to,
          const _legami_slice *_tao_from
        );

      _legami legami;
      ::CORBA::Long tipo_proc;
      ::CORBA::Long LastRestartTime;
      ::CORBA::Long NumRestartTimes;
      ::CORBA::ULong ProcessPID;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _nome_proc[11];
      typedef ::CORBA::Char _nome_proc_slice;
      struct _nome_proc_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _nome_proc,
            _nome_proc_slice,
            _nome_proc_tag
          >
        _nome_proc_forany;

      static _nome_proc_slice *
      _nome_proc_alloc (void);

      static void
      _nome_proc_free (
          _nome_proc_slice *_tao_slice);
      
      static _nome_proc_slice *
      _nome_proc_dup (
          const _nome_proc_slice *_tao_slice);
      
      static void
      _nome_proc_copy (
          _nome_proc_slice *_tao_to,
          const _nome_proc_slice *_tao_from
        );

      _nome_proc nome_proc;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _cmd_start[50];
      typedef ::CORBA::Char _cmd_start_slice;
      struct _cmd_start_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _cmd_start,
            _cmd_start_slice,
            _cmd_start_tag
          >
        _cmd_start_forany;

      static _cmd_start_slice *
      _cmd_start_alloc (void);

      static void
      _cmd_start_free (
          _cmd_start_slice *_tao_slice);
      
      static _cmd_start_slice *
      _cmd_start_dup (
          const _cmd_start_slice *_tao_slice);
      
      static void
      _cmd_start_copy (
          _cmd_start_slice *_tao_to,
          const _cmd_start_slice *_tao_from
        );

      _cmd_start cmd_start;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _nome_fep[10];
      typedef ::CORBA::Char _nome_fep_slice;
      struct _nome_fep_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _nome_fep,
            _nome_fep_slice,
            _nome_fep_tag
          >
        _nome_fep_forany;

      static _nome_fep_slice *
      _nome_fep_alloc (void);

      static void
      _nome_fep_free (
          _nome_fep_slice *_tao_slice);
      
      static _nome_fep_slice *
      _nome_fep_dup (
          const _nome_fep_slice *_tao_slice);
      
      static void
      _nome_fep_copy (
          _nome_fep_slice *_tao_to,
          const _nome_fep_slice *_tao_from
        );

      _nome_fep nome_fep;
      ::CORBA::Long idFep;
    };

    // TAO_IDL - Generated from
    // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_NET_ETECH_CS_INFO_PROCSEQ_CH_)
#define _NET_ETECH_CS_INFO_PROCSEQ_CH_

    class CS_INFO_PROCSeq;

    typedef
      ::TAO_FixedSeq_Var_T<
          CS_INFO_PROCSeq
        >
      CS_INFO_PROCSeq_var;

    typedef
      ::TAO_Seq_Out_T<
          CS_INFO_PROCSeq
        >
      CS_INFO_PROCSeq_out;

    class  CS_INFO_PROCSeq
      : public
          ::TAO::unbounded_value_sequence<
              CS_INFO_PROC
            >
    {
    public:
      CS_INFO_PROCSeq (void);
      CS_INFO_PROCSeq ( ::CORBA::ULong max);
      CS_INFO_PROCSeq (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        CS_INFO_PROC* buffer,
        ::CORBA::Boolean release = false);
      CS_INFO_PROCSeq (const CS_INFO_PROCSeq &);
      virtual ~CS_INFO_PROCSeq (void);
      

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef CS_INFO_PROCSeq_var _var_type;
      typedef CS_INFO_PROCSeq_out _out_type;
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // be/be_type.cpp:261

    struct CS_BLOCK_LOG;

    typedef
      ::TAO_Fixed_Var_T<
          CS_BLOCK_LOG
        >
      CS_BLOCK_LOG_var;

    typedef
      CS_BLOCK_LOG &
      CS_BLOCK_LOG_out;

    // TAO_IDL - Generated from
    // be/be_visitor_structure/structure_ch.cpp:51

    struct  CS_BLOCK_LOG
    {

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef CS_BLOCK_LOG_var _var_type;
      typedef CS_BLOCK_LOG_out _out_type;
      
      ::CORBA::Long item;
      ::CORBA::Long block;
      ::CORBA::Long cod_err;
      ::CORBA::Long urgenza;
      ::CORBA::Long priorita;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _msg[132];
      typedef ::CORBA::Char _msg_slice;
      struct _msg_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _msg,
            _msg_slice,
            _msg_tag
          >
        _msg_forany;

      static _msg_slice *
      _msg_alloc (void);

      static void
      _msg_free (
          _msg_slice *_tao_slice);
      
      static _msg_slice *
      _msg_dup (
          const _msg_slice *_tao_slice);
      
      static void
      _msg_copy (
          _msg_slice *_tao_to,
          const _msg_slice *_tao_from
        );

      _msg msg;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _nome[40];
      typedef ::CORBA::Char _nome_slice;
      struct _nome_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _nome,
            _nome_slice,
            _nome_tag
          >
        _nome_forany;

      static _nome_slice *
      _nome_alloc (void);

      static void
      _nome_free (
          _nome_slice *_tao_slice);
      
      static _nome_slice *
      _nome_dup (
          const _nome_slice *_tao_slice);
      
      static void
      _nome_copy (
          _nome_slice *_tao_to,
          const _nome_slice *_tao_from
        );

      _nome nome;
      ::CORBA::Long idFep;
    };

    // TAO_IDL - Generated from
    // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_NET_ETECH_CS_BLOCK_LOGSEQ_CH_)
#define _NET_ETECH_CS_BLOCK_LOGSEQ_CH_

    class CS_BLOCK_LOGSeq;

    typedef
      ::TAO_FixedSeq_Var_T<
          CS_BLOCK_LOGSeq
        >
      CS_BLOCK_LOGSeq_var;

    typedef
      ::TAO_Seq_Out_T<
          CS_BLOCK_LOGSeq
        >
      CS_BLOCK_LOGSeq_out;

    class  CS_BLOCK_LOGSeq
      : public
          ::TAO::unbounded_value_sequence<
              CS_BLOCK_LOG
            >
    {
    public:
      CS_BLOCK_LOGSeq (void);
      CS_BLOCK_LOGSeq ( ::CORBA::ULong max);
      CS_BLOCK_LOGSeq (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        CS_BLOCK_LOG* buffer,
        ::CORBA::Boolean release = false);
      CS_BLOCK_LOGSeq (const CS_BLOCK_LOGSeq &);
      virtual ~CS_BLOCK_LOGSeq (void);
      

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef CS_BLOCK_LOGSeq_var _var_type;
      typedef CS_BLOCK_LOGSeq_out _out_type;
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // be/be_type.cpp:261

    struct GARBAGE_INFO;

    typedef
      ::TAO_Fixed_Var_T<
          GARBAGE_INFO
        >
      GARBAGE_INFO_var;

    typedef
      GARBAGE_INFO &
      GARBAGE_INFO_out;

    // TAO_IDL - Generated from
    // be/be_visitor_structure/structure_ch.cpp:51

    struct  GARBAGE_INFO
    {

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef GARBAGE_INFO_var _var_type;
      typedef GARBAGE_INFO_out _out_type;
      
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _user[10];
      typedef ::CORBA::Char _user_slice;
      struct _user_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _user,
            _user_slice,
            _user_tag
          >
        _user_forany;

      static _user_slice *
      _user_alloc (void);

      static void
      _user_free (
          _user_slice *_tao_slice);
      
      static _user_slice *
      _user_dup (
          const _user_slice *_tao_slice);
      
      static void
      _user_copy (
          _user_slice *_tao_to,
          const _user_slice *_tao_from
        );

      _user user;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _path[257];
      typedef ::CORBA::Char _path_slice;
      struct _path_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _path,
            _path_slice,
            _path_tag
          >
        _path_forany;

      static _path_slice *
      _path_alloc (void);

      static void
      _path_free (
          _path_slice *_tao_slice);
      
      static _path_slice *
      _path_dup (
          const _path_slice *_tao_slice);
      
      static void
      _path_copy (
          _path_slice *_tao_to,
          const _path_slice *_tao_from
        );

      _path path;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _filter[15];
      typedef ::CORBA::Char _filter_slice;
      struct _filter_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _filter,
            _filter_slice,
            _filter_tag
          >
        _filter_forany;

      static _filter_slice *
      _filter_alloc (void);

      static void
      _filter_free (
          _filter_slice *_tao_slice);
      
      static _filter_slice *
      _filter_dup (
          const _filter_slice *_tao_slice);
      
      static void
      _filter_copy (
          _filter_slice *_tao_to,
          const _filter_slice *_tao_from
        );

      _filter filter;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _frequence[5];
      typedef ::CORBA::Char _frequence_slice;
      struct _frequence_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _frequence,
            _frequence_slice,
            _frequence_tag
          >
        _frequence_forany;

      static _frequence_slice *
      _frequence_alloc (void);

      static void
      _frequence_free (
          _frequence_slice *_tao_slice);
      
      static _frequence_slice *
      _frequence_dup (
          const _frequence_slice *_tao_slice);
      
      static void
      _frequence_copy (
          _frequence_slice *_tao_to,
          const _frequence_slice *_tao_from
        );

      _frequence frequence;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _path_log[257];
      typedef ::CORBA::Char _path_log_slice;
      struct _path_log_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _path_log,
            _path_log_slice,
            _path_log_tag
          >
        _path_log_forany;

      static _path_log_slice *
      _path_log_alloc (void);

      static void
      _path_log_free (
          _path_log_slice *_tao_slice);
      
      static _path_log_slice *
      _path_log_dup (
          const _path_log_slice *_tao_slice);
      
      static void
      _path_log_copy (
          _path_log_slice *_tao_to,
          const _path_log_slice *_tao_from
        );

      _path_log path_log;
    };

    // TAO_IDL - Generated from
    // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_NET_ETECH_GARBAGE_INFOSEQ_CH_)
#define _NET_ETECH_GARBAGE_INFOSEQ_CH_

    class GARBAGE_INFOSeq;

    typedef
      ::TAO_FixedSeq_Var_T<
          GARBAGE_INFOSeq
        >
      GARBAGE_INFOSeq_var;

    typedef
      ::TAO_Seq_Out_T<
          GARBAGE_INFOSeq
        >
      GARBAGE_INFOSeq_out;

    class  GARBAGE_INFOSeq
      : public
          ::TAO::unbounded_value_sequence<
              GARBAGE_INFO
            >
    {
    public:
      GARBAGE_INFOSeq (void);
      GARBAGE_INFOSeq ( ::CORBA::ULong max);
      GARBAGE_INFOSeq (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        GARBAGE_INFO* buffer,
        ::CORBA::Boolean release = false);
      GARBAGE_INFOSeq (const GARBAGE_INFOSeq &);
      virtual ~GARBAGE_INFOSeq (void);
      

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef GARBAGE_INFOSeq_var _var_type;
      typedef GARBAGE_INFOSeq_out _out_type;
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // be/be_type.cpp:261

    struct ACQ_CAT;

    typedef
      ::TAO_Fixed_Var_T<
          ACQ_CAT
        >
      ACQ_CAT_var;

    typedef
      ACQ_CAT &
      ACQ_CAT_out;

    // TAO_IDL - Generated from
    // be/be_visitor_structure/structure_ch.cpp:51

    struct  ACQ_CAT
    {

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef ACQ_CAT_var _var_type;
      typedef ACQ_CAT_out _out_type;
      
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _name[29];
      typedef ::CORBA::Char _name_slice;
      struct _name_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _name,
            _name_slice,
            _name_tag
          >
        _name_forany;

      static _name_slice *
      _name_alloc (void);

      static void
      _name_free (
          _name_slice *_tao_slice);
      
      static _name_slice *
      _name_dup (
          const _name_slice *_tao_slice);
      
      static void
      _name_copy (
          _name_slice *_tao_to,
          const _name_slice *_tao_from
        );

      _name name;
      ::CORBA::Boolean processedOK;
    };

    // TAO_IDL - Generated from
    // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_NET_ETECH_ACQ_CATSEQ_CH_)
#define _NET_ETECH_ACQ_CATSEQ_CH_

    class ACQ_CATSeq;

    typedef
      ::TAO_FixedSeq_Var_T<
          ACQ_CATSeq
        >
      ACQ_CATSeq_var;

    typedef
      ::TAO_Seq_Out_T<
          ACQ_CATSeq
        >
      ACQ_CATSeq_out;

    class  ACQ_CATSeq
      : public
          ::TAO::unbounded_value_sequence<
              ACQ_CAT
            >
    {
    public:
      ACQ_CATSeq (void);
      ACQ_CATSeq ( ::CORBA::ULong max);
      ACQ_CATSeq (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        ACQ_CAT* buffer,
        ::CORBA::Boolean release = false);
      ACQ_CATSeq (const ACQ_CATSeq &);
      virtual ~ACQ_CATSeq (void);
      

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef ACQ_CATSeq_var _var_type;
      typedef ACQ_CATSeq_out _out_type;
    };

#endif /* end #if !defined */

    // TAO_IDL - Generated from
    // be/be_type.cpp:261

    struct ACQ_PEB_MGR;

    typedef
      ::TAO_Var_Var_T<
          ACQ_PEB_MGR
        >
      ACQ_PEB_MGR_var;

    typedef
      ::TAO_Out_T<
          ACQ_PEB_MGR
        >
      ACQ_PEB_MGR_out;

    // TAO_IDL - Generated from
    // be/be_visitor_structure/structure_ch.cpp:51

    struct  ACQ_PEB_MGR
    {

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef ACQ_PEB_MGR_var _var_type;
      typedef ACQ_PEB_MGR_out _out_type;
      
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _processing[29];
      typedef ::CORBA::Char _processing_slice;
      struct _processing_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _processing,
            _processing_slice,
            _processing_tag
          >
        _processing_forany;

      static _processing_slice *
      _processing_alloc (void);

      static void
      _processing_free (
          _processing_slice *_tao_slice);
      
      static _processing_slice *
      _processing_dup (
          const _processing_slice *_tao_slice);
      
      static void
      _processing_copy (
          _processing_slice *_tao_to,
          const _processing_slice *_tao_from
        );

      _processing processing;
      ::CORBA::Long drFileProg;
      ::CORBA::Long drFileRemaining;
      ::CORBA::Boolean startWithRestart;
      ::CORBA::Boolean restartWithCacheFlush;
      ::CORBA::Boolean pauseAcqCat;
      ::CORBA::Boolean twoDaysRun;
      ::CORBA::Long acqCatPid;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _PEBName[128];
      typedef ::CORBA::Char _PEBName_slice;
      struct _PEBName_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _PEBName,
            _PEBName_slice,
            _PEBName_tag
          >
        _PEBName_forany;

      static _PEBName_slice *
      _PEBName_alloc (void);

      static void
      _PEBName_free (
          _PEBName_slice *_tao_slice);
      
      static _PEBName_slice *
      _PEBName_dup (
          const _PEBName_slice *_tao_slice);
      
      static void
      _PEBName_copy (
          _PEBName_slice *_tao_to,
          const _PEBName_slice *_tao_from
        );

      _PEBName PEBName;
      net::etech::ACQ_CATSeq processedVector;
    };

    // TAO_IDL - Generated from
    // be/be_type.cpp:261

    struct GESTIONE_PSWD;

    typedef
      ::TAO_Fixed_Var_T<
          GESTIONE_PSWD
        >
      GESTIONE_PSWD_var;

    typedef
      GESTIONE_PSWD &
      GESTIONE_PSWD_out;

    // TAO_IDL - Generated from
    // be/be_visitor_structure/structure_ch.cpp:51

    struct  GESTIONE_PSWD
    {

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef GESTIONE_PSWD_var _var_type;
      typedef GESTIONE_PSWD_out _out_type;
      
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _nomeNodo[50];
      typedef ::CORBA::Char _nomeNodo_slice;
      struct _nomeNodo_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _nomeNodo,
            _nomeNodo_slice,
            _nomeNodo_tag
          >
        _nomeNodo_forany;

      static _nomeNodo_slice *
      _nomeNodo_alloc (void);

      static void
      _nomeNodo_free (
          _nomeNodo_slice *_tao_slice);
      
      static _nomeNodo_slice *
      _nomeNodo_dup (
          const _nomeNodo_slice *_tao_slice);
      
      static void
      _nomeNodo_copy (
          _nomeNodo_slice *_tao_to,
          const _nomeNodo_slice *_tao_from
        );

      _nomeNodo nomeNodo;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _oggetto[100];
      typedef ::CORBA::Char _oggetto_slice;
      struct _oggetto_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _oggetto,
            _oggetto_slice,
            _oggetto_tag
          >
        _oggetto_forany;

      static _oggetto_slice *
      _oggetto_alloc (void);

      static void
      _oggetto_free (
          _oggetto_slice *_tao_slice);
      
      static _oggetto_slice *
      _oggetto_dup (
          const _oggetto_slice *_tao_slice);
      
      static void
      _oggetto_copy (
          _oggetto_slice *_tao_to,
          const _oggetto_slice *_tao_from
        );

      _oggetto oggetto;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _login[50];
      typedef ::CORBA::Char _login_slice;
      struct _login_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _login,
            _login_slice,
            _login_tag
          >
        _login_forany;

      static _login_slice *
      _login_alloc (void);

      static void
      _login_free (
          _login_slice *_tao_slice);
      
      static _login_slice *
      _login_dup (
          const _login_slice *_tao_slice);
      
      static void
      _login_copy (
          _login_slice *_tao_to,
          const _login_slice *_tao_from
        );

      _login login;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _pswd[50];
      typedef ::CORBA::Char _pswd_slice;
      struct _pswd_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _pswd,
            _pswd_slice,
            _pswd_tag
          >
        _pswd_forany;

      static _pswd_slice *
      _pswd_alloc (void);

      static void
      _pswd_free (
          _pswd_slice *_tao_slice);
      
      static _pswd_slice *
      _pswd_dup (
          const _pswd_slice *_tao_slice);
      
      static void
      _pswd_copy (
          _pswd_slice *_tao_to,
          const _pswd_slice *_tao_from
        );

      _pswd pswd;
      ::CORBA::Char validita;
      

      // TAO_IDL - Generated from
      // be/be_visitor_array/array_ch.cpp:54

      typedef ::CORBA::Char _dataScadenza[9];
      typedef ::CORBA::Char _dataScadenza_slice;
      struct _dataScadenza_tag {};
      

      typedef
        TAO_Array_Forany_T<
            _dataScadenza,
            _dataScadenza_slice,
            _dataScadenza_tag
          >
        _dataScadenza_forany;

      static _dataScadenza_slice *
      _dataScadenza_alloc (void);

      static void
      _dataScadenza_free (
          _dataScadenza_slice *_tao_slice);
      
      static _dataScadenza_slice *
      _dataScadenza_dup (
          const _dataScadenza_slice *_tao_slice);
      
      static void
      _dataScadenza_copy (
          _dataScadenza_slice *_tao_to,
          const _dataScadenza_slice *_tao_from
        );

      _dataScadenza dataScadenza;
      ::CORBA::Char flag;
    };

    // TAO_IDL - Generated from
    // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_NET_ETECH_GESTIONE_PSWDSEQ_CH_)
#define _NET_ETECH_GESTIONE_PSWDSEQ_CH_

    class GESTIONE_PSWDSeq;

    typedef
      ::TAO_FixedSeq_Var_T<
          GESTIONE_PSWDSeq
        >
      GESTIONE_PSWDSeq_var;

    typedef
      ::TAO_Seq_Out_T<
          GESTIONE_PSWDSeq
        >
      GESTIONE_PSWDSeq_out;

    class  GESTIONE_PSWDSeq
      : public
          ::TAO::unbounded_value_sequence<
              GESTIONE_PSWD
            >
    {
    public:
      GESTIONE_PSWDSeq (void);
      GESTIONE_PSWDSeq ( ::CORBA::ULong max);
      GESTIONE_PSWDSeq (
        ::CORBA::ULong max,
        ::CORBA::ULong length,
        GESTIONE_PSWD* buffer,
        ::CORBA::Boolean release = false);
      GESTIONE_PSWDSeq (const GESTIONE_PSWDSeq &);
      virtual ~GESTIONE_PSWDSeq (void);
      

      // TAO_IDL - Generated from
      // be/be_type.cpp:307

      
      typedef GESTIONE_PSWDSeq_var _var_type;
      typedef GESTIONE_PSWDSeq_out _out_type;
    };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_module/module_ch.cpp:67
  
  } // module net::etech

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:67

} // module net

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:38

namespace net
{

  // TAO_IDL - Generated from
  // be/be_visitor_module/module_ch.cpp:38

  namespace etech
  {

    // TAO_IDL - Generated from
    // be/be_visitor_module/module_ch.cpp:38

    namespace SSM
    {

      // TAO_IDL - Generated from
      // be/be_interface.cpp:751

#if !defined (_NET_ETECH_SSM_CONFIGMONITORSERVER__VAR_OUT_CH_)
#define _NET_ETECH_SSM_CONFIGMONITORSERVER__VAR_OUT_CH_

      class ConfigMonitorServer;
      typedef ConfigMonitorServer *ConfigMonitorServer_ptr;

      typedef
        TAO_Objref_Var_T<
            ConfigMonitorServer
          >
        ConfigMonitorServer_var;
      
      typedef
        TAO_Objref_Out_T<
            ConfigMonitorServer
          >
        ConfigMonitorServer_out;

#endif /* end #if !defined */

      // TAO_IDL - Generated from
      // be/be_visitor_interface/interface_ch.cpp:43

      class  ConfigMonitorServer
        : public virtual ::CORBA::Object
      {
      public:
        friend class TAO::Narrow_Utils<ConfigMonitorServer>;

        // TAO_IDL - Generated from
        // be/be_type.cpp:307

        typedef ConfigMonitorServer_ptr _ptr_type;
        typedef ConfigMonitorServer_var _var_type;
        typedef ConfigMonitorServer_out _out_type;

        // The static operations.
        static ConfigMonitorServer_ptr _duplicate (ConfigMonitorServer_ptr obj);

        static void _tao_release (ConfigMonitorServer_ptr obj);

        static ConfigMonitorServer_ptr _narrow (::CORBA::Object_ptr obj);
        static ConfigMonitorServer_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
        static ConfigMonitorServer_ptr _nil (void);

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eCMS = 1;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eCMS1 = 1;

        virtual ::CORBA::Boolean KillOrbixProcess (
          ::CORBA::Long flag,
          ::CORBA::Long num_pid);

        virtual ::CORBA::Boolean refreshConfigProcess (
          ::CORBA::Long flag,
          ::net::etech::CS_INFO_PROCSeq_out configProcesslList);

        virtual ::CORBA::Boolean refreshConfigBloc (
          ::CORBA::Long flag,
          ::net::etech::CS_BLOCK_LOGSeq_out configBloclList);

        virtual ::CORBA::Long writeModifyProcess (
          const char * nomeProcesso,
          ::CORBA::Long flag,
          const ::net::etech::CS_INFO_PROC & configProcess);

        virtual ::CORBA::Long writeModifyLog (
          ::CORBA::Long flag,
          const ::net::etech::CS_BLOCK_LOGSeq & configBloclList);

        virtual ::CORBA::Long deleteProcess (
          ::CORBA::Long flag,
          const char * nomeProcesso);

        virtual ::CORBA::Long deleteBlockLog (
          ::CORBA::Long flag,
          ::CORBA::Long idBlock);

        virtual ::CORBA::Long SystemStart (
          ::CORBA::Long flag);

        virtual ::CORBA::Long SystemStop (
          ::CORBA::Long flag);

        virtual void shutDown (
          void);

        // TAO_IDL - Generated from
        // be/be_visitor_interface/interface_ch.cpp:140

        virtual ::CORBA::Boolean _is_a (const char *type_id);
        virtual const char* _interface_repository_id (void) const;
        virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
      
      protected:
        // Concrete interface only.
        ConfigMonitorServer (void);

        // Concrete non-local interface only.
        ConfigMonitorServer (
            ::IOP::IOR *ior,
            TAO_ORB_Core *orb_core);
        
        // Non-local interface only.
        ConfigMonitorServer (
            TAO_Stub *objref,
            ::CORBA::Boolean _tao_collocated = false,
            TAO_Abstract_ServantBase *servant = 0,
            TAO_ORB_Core *orb_core = 0);

        virtual ~ConfigMonitorServer (void);
      
      private:
        // Private and unimplemented for concrete interfaces.
        ConfigMonitorServer (const ConfigMonitorServer &);

        void operator= (const ConfigMonitorServer &);
      };

      // TAO_IDL - Generated from
      // be/be_interface.cpp:751

#if !defined (_NET_ETECH_SSM_PROCESSMONITORSERVER__VAR_OUT_CH_)
#define _NET_ETECH_SSM_PROCESSMONITORSERVER__VAR_OUT_CH_

      class ProcessMonitorServer;
      typedef ProcessMonitorServer *ProcessMonitorServer_ptr;

      typedef
        TAO_Objref_Var_T<
            ProcessMonitorServer
          >
        ProcessMonitorServer_var;
      
      typedef
        TAO_Objref_Out_T<
            ProcessMonitorServer
          >
        ProcessMonitorServer_out;

#endif /* end #if !defined */

      // TAO_IDL - Generated from
      // be/be_visitor_interface/interface_ch.cpp:43

      class  ProcessMonitorServer
        : public virtual ::CORBA::Object
      {
      public:
        friend class TAO::Narrow_Utils<ProcessMonitorServer>;

        // TAO_IDL - Generated from
        // be/be_type.cpp:307

        typedef ProcessMonitorServer_ptr _ptr_type;
        typedef ProcessMonitorServer_var _var_type;
        typedef ProcessMonitorServer_out _out_type;

        // The static operations.
        static ProcessMonitorServer_ptr _duplicate (ProcessMonitorServer_ptr obj);

        static void _tao_release (ProcessMonitorServer_ptr obj);

        static ProcessMonitorServer_ptr _narrow (::CORBA::Object_ptr obj);
        static ProcessMonitorServer_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
        static ProcessMonitorServer_ptr _nil (void);

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eHELP = 1;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eMACRO = 2;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long ePS_ORBIX = 3;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long ePS_ORBIX_HELP = 4;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eSINGLE_PROCESS = 1;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eALL_PROCESS = 2;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eMAX_DESCRITTORE_PROCESS_LEN = 250;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eMAX_NOME_PROCESSO_LEN = 100;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eMAX_COLOR_LEN = 10;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eMAX_TIPO_PROCESSO_LEN = 10;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eMAX_MSG_PRROCESSO_LEN = 150;

        virtual ::CORBA::Boolean refreshMonitorProcess (
          ::net::etech::ProcesDetailSeq_out procesDetailList);

        virtual ::CORBA::Boolean checkStatus (
          ::net::etech::ProcesDetailSeq_out procesDetailList);

        virtual ::CORBA::Boolean getDeteilProcess (
          ::CORBA::Long flagDETAIL,
          const char * nomeProcesso,
          ::net::etech::LogProcessSeq_out logProcesso);

        virtual ::CORBA::Long getHistoryProcess (
          ::CORBA::Long flagWORK,
          ::CORBA::Long flagSINGLE_ALL_PROCESS,
          ::CORBA::Boolean flagALLDOCUMENT,
          const char * nomeProcesso,
          ::CORBA::Long data,
          ::net::etech::LogProcessSeq_out logProcesso);

        virtual ::CORBA::Long resetField (
          ::CORBA::Long field,
          ::CORBA::Long flagTIPORESET,
          const char * nomeProcesso);

        virtual void shutDown (
          void);

        // TAO_IDL - Generated from
        // be/be_visitor_interface/interface_ch.cpp:140

        virtual ::CORBA::Boolean _is_a (const char *type_id);
        virtual const char* _interface_repository_id (void) const;
        virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
      
      protected:
        // Concrete interface only.
        ProcessMonitorServer (void);

        // Concrete non-local interface only.
        ProcessMonitorServer (
            ::IOP::IOR *ior,
            TAO_ORB_Core *orb_core);
        
        // Non-local interface only.
        ProcessMonitorServer (
            TAO_Stub *objref,
            ::CORBA::Boolean _tao_collocated = false,
            TAO_Abstract_ServantBase *servant = 0,
            TAO_ORB_Core *orb_core = 0);

        virtual ~ProcessMonitorServer (void);
      
      private:
        // Private and unimplemented for concrete interfaces.
        ProcessMonitorServer (const ProcessMonitorServer &);

        void operator= (const ProcessMonitorServer &);
      };

      // TAO_IDL - Generated from
      // be/be_interface.cpp:751

#if !defined (_NET_ETECH_SSM_ACQPEBMGRSERVER__VAR_OUT_CH_)
#define _NET_ETECH_SSM_ACQPEBMGRSERVER__VAR_OUT_CH_

      class ACQPebMGRServer;
      typedef ACQPebMGRServer *ACQPebMGRServer_ptr;

      typedef
        TAO_Objref_Var_T<
            ACQPebMGRServer
          >
        ACQPebMGRServer_var;
      
      typedef
        TAO_Objref_Out_T<
            ACQPebMGRServer
          >
        ACQPebMGRServer_out;

#endif /* end #if !defined */

      // TAO_IDL - Generated from
      // be/be_visitor_interface/interface_ch.cpp:43

      class  ACQPebMGRServer
        : public virtual ::CORBA::Object
      {
      public:
        friend class TAO::Narrow_Utils<ACQPebMGRServer>;

        // TAO_IDL - Generated from
        // be/be_type.cpp:307

        typedef ACQPebMGRServer_ptr _ptr_type;
        typedef ACQPebMGRServer_var _var_type;
        typedef ACQPebMGRServer_out _out_type;

        // The static operations.
        static ACQPebMGRServer_ptr _duplicate (ACQPebMGRServer_ptr obj);

        static void _tao_release (ACQPebMGRServer_ptr obj);

        static ACQPebMGRServer_ptr _narrow (::CORBA::Object_ptr obj);
        static ACQPebMGRServer_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
        static ACQPebMGRServer_ptr _nil (void);

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eCAT_NAME_DIM = 29;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long ePEB_NAME_DIM = 128;

        virtual ::CORBA::Long refreshACQPebMGR (
          ::CORBA::Long flag,
          ::net::etech::ACQ_PEB_MGR_out acqPebMgr);

        virtual ::CORBA::Long writeACQPebMGR (
          ::CORBA::Boolean cleanAll,
          const ::net::etech::ACQ_PEB_MGR & acqPebMgr);

        virtual void shutDown (
          void);

        // TAO_IDL - Generated from
        // be/be_visitor_interface/interface_ch.cpp:140

        virtual ::CORBA::Boolean _is_a (const char *type_id);
        virtual const char* _interface_repository_id (void) const;
        virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
      
      protected:
        // Concrete interface only.
        ACQPebMGRServer (void);

        // Concrete non-local interface only.
        ACQPebMGRServer (
            ::IOP::IOR *ior,
            TAO_ORB_Core *orb_core);
        
        // Non-local interface only.
        ACQPebMGRServer (
            TAO_Stub *objref,
            ::CORBA::Boolean _tao_collocated = false,
            TAO_Abstract_ServantBase *servant = 0,
            TAO_ORB_Core *orb_core = 0);

        virtual ~ACQPebMGRServer (void);
      
      private:
        // Private and unimplemented for concrete interfaces.
        ACQPebMGRServer (const ACQPebMGRServer &);

        void operator= (const ACQPebMGRServer &);
      };

      // TAO_IDL - Generated from
      // be/be_interface.cpp:751

#if !defined (_NET_ETECH_SSM_GARBAGEMONITORSERVER__VAR_OUT_CH_)
#define _NET_ETECH_SSM_GARBAGEMONITORSERVER__VAR_OUT_CH_

      class GarbageMonitorServer;
      typedef GarbageMonitorServer *GarbageMonitorServer_ptr;

      typedef
        TAO_Objref_Var_T<
            GarbageMonitorServer
          >
        GarbageMonitorServer_var;
      
      typedef
        TAO_Objref_Out_T<
            GarbageMonitorServer
          >
        GarbageMonitorServer_out;

#endif /* end #if !defined */

      // TAO_IDL - Generated from
      // be/be_visitor_interface/interface_ch.cpp:43

      class  GarbageMonitorServer
        : public virtual ::CORBA::Object
      {
      public:
        friend class TAO::Narrow_Utils<GarbageMonitorServer>;

        // TAO_IDL - Generated from
        // be/be_type.cpp:307

        typedef GarbageMonitorServer_ptr _ptr_type;
        typedef GarbageMonitorServer_var _var_type;
        typedef GarbageMonitorServer_out _out_type;

        // The static operations.
        static GarbageMonitorServer_ptr _duplicate (GarbageMonitorServer_ptr obj);

        static void _tao_release (GarbageMonitorServer_ptr obj);

        static GarbageMonitorServer_ptr _narrow (::CORBA::Object_ptr obj);
        static GarbageMonitorServer_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
        static GarbageMonitorServer_ptr _nil (void);

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eGB_LENUSER = 10;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eGB_LENPATH = 257;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eGB_LENPATH_LOG = 257;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eGB_LENFILTER = 15;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eGB_LENFREQUENCE = 5;

        virtual ::CORBA::Long refreshGarbage (
          ::net::etech::GARBAGE_INFOSeq_out GarbageInfoOut);

        virtual ::CORBA::Long writeGarbage (
          ::CORBA::Boolean modify,
          const ::net::etech::GARBAGE_INFOSeq & GarbageInfoIn);

        virtual void shutDown (
          void);

        // TAO_IDL - Generated from
        // be/be_visitor_interface/interface_ch.cpp:140

        virtual ::CORBA::Boolean _is_a (const char *type_id);
        virtual const char* _interface_repository_id (void) const;
        virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
      
      protected:
        // Concrete interface only.
        GarbageMonitorServer (void);

        // Concrete non-local interface only.
        GarbageMonitorServer (
            ::IOP::IOR *ior,
            TAO_ORB_Core *orb_core);
        
        // Non-local interface only.
        GarbageMonitorServer (
            TAO_Stub *objref,
            ::CORBA::Boolean _tao_collocated = false,
            TAO_Abstract_ServantBase *servant = 0,
            TAO_ORB_Core *orb_core = 0);

        virtual ~GarbageMonitorServer (void);
      
      private:
        // Private and unimplemented for concrete interfaces.
        GarbageMonitorServer (const GarbageMonitorServer &);

        void operator= (const GarbageMonitorServer &);
      };

      // TAO_IDL - Generated from
      // be/be_interface.cpp:751

#if !defined (_NET_ETECH_SSM_PSMONITORMASTERSERVER__VAR_OUT_CH_)
#define _NET_ETECH_SSM_PSMONITORMASTERSERVER__VAR_OUT_CH_

      class PsMonitorMasterServer;
      typedef PsMonitorMasterServer *PsMonitorMasterServer_ptr;

      typedef
        TAO_Objref_Var_T<
            PsMonitorMasterServer
          >
        PsMonitorMasterServer_var;
      
      typedef
        TAO_Objref_Out_T<
            PsMonitorMasterServer
          >
        PsMonitorMasterServer_out;

#endif /* end #if !defined */

      // TAO_IDL - Generated from
      // be/be_visitor_interface/interface_ch.cpp:43

      class  PsMonitorMasterServer
        : public virtual ::CORBA::Object
      {
      public:
        friend class TAO::Narrow_Utils<PsMonitorMasterServer>;

        // TAO_IDL - Generated from
        // be/be_type.cpp:307

        typedef PsMonitorMasterServer_ptr _ptr_type;
        typedef PsMonitorMasterServer_var _var_type;
        typedef PsMonitorMasterServer_out _out_type;

        // The static operations.
        static PsMonitorMasterServer_ptr _duplicate (PsMonitorMasterServer_ptr obj);

        static void _tao_release (PsMonitorMasterServer_ptr obj);

        static PsMonitorMasterServer_ptr _narrow (::CORBA::Object_ptr obj);
        static PsMonitorMasterServer_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
        static PsMonitorMasterServer_ptr _nil (void);

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long ePSM = 1;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eCOMP = 1;

        virtual ::CORBA::Boolean LaunchPsMonitorMasterServer (
          ::net::etech::CentralSeq_out CEN);

        virtual ::CORBA::Boolean KillOrbixProcess (
          const char * nameSwitch,
          ::CORBA::Long flag,
          ::CORBA::Long num_pid);

        virtual ::CORBA::Boolean refreshMonitorProcess (
          const char * nameSwitch,
          ::CORBA::Long flag,
          ::net::etech::ProcesDetailSeq_out procesDetailLis);

        virtual ::CORBA::Boolean getDeteilProcess (
          ::CORBA::Long flagDETAIL,
          const char * nameSwitch,
          const char * nomeProcesso,
          ::net::etech::LogProcessSeq_out logProcesso);

        virtual ::CORBA::Boolean getSystemTime (
          const char * nameSwitch,
          ::net::etech::LogProcessSeq_out systemTime);

        virtual ::CORBA::Long getHistoryProcess (
          ::CORBA::Long flagWORK,
          ::CORBA::Long flagSINGLE_ALL_PROCESS,
          ::CORBA::Boolean flagALLDOCUMENT,
          const char * nameSwitch,
          const char * nomeProcesso,
          ::CORBA::Long data,
          ::net::etech::LogProcessSeq_out logProcesso);

        virtual ::CORBA::Long resetField (
          const char * nameSwitch,
          ::CORBA::Long field,
          ::CORBA::Long flagTIPORESET,
          const char * nomeProcesso);

        virtual ::CORBA::Boolean refreshConfigProcess (
          const char * nameSwitch,
          ::CORBA::Long flag,
          ::net::etech::CS_INFO_PROCSeq_out configProcesslList);

        virtual ::CORBA::Boolean refreshConfigBloc (
          const char * nameSwitch,
          ::CORBA::Long flag,
          ::net::etech::CS_BLOCK_LOGSeq_out configBloclList);

        virtual ::CORBA::Long writeModifyProcess (
          const char * nomeProcesso,
          const char * nameSwitch,
          ::CORBA::Long flag,
          const ::net::etech::CS_INFO_PROC & configProcess);

        virtual ::CORBA::Long writeModifyLog (
          const char * nameSwitch,
          ::CORBA::Long flag,
          const ::net::etech::CS_BLOCK_LOGSeq & configBloclList,
          ::net::etech::CentralSeq_out switchSeq);

        virtual ::CORBA::Long createLogFile (
          const char * nameSwitch,
          ::CORBA::Long flag);

        virtual ::CORBA::Long deleteProcess (
          const char * nameSwitch,
          ::CORBA::Long flag,
          const char * nomeProcesso);

        virtual ::CORBA::Long deleteBlockLog (
          const char * nameSwitch,
          ::CORBA::Long flag,
          ::CORBA::Long idBlock,
          ::CORBA::Long idFep);

        virtual ::CORBA::Long SystemStart (
          const char * nameSwitch,
          ::CORBA::Long flag);

        virtual ::CORBA::Long SystemStop (
          const char * nameSwitch,
          ::CORBA::Long flag);

        virtual ::CORBA::Long refreshACQPebMGR (
          const char * nameSwitch,
          ::CORBA::Long flag,
          ::net::etech::ACQ_PEB_MGR_out acqPebMgr);

        virtual ::CORBA::Long writeACQPebMGR (
          const char * nameSwitch,
          ::CORBA::Boolean cleanAll,
          const ::net::etech::ACQ_PEB_MGR & acqPebMgr);

        virtual ::CORBA::Long refreshGarbage (
          const char * nameSwitch,
          ::net::etech::GARBAGE_INFOSeq_out GarbageInfoOut);

        virtual ::CORBA::Long writeGarbage (
          const char * nameSwitch,
          ::CORBA::Boolean modify,
          const ::net::etech::GARBAGE_INFOSeq & GarbageInfoIn);

        virtual ::CORBA::Long putFilePSWD (
          const char * nameSwitch,
          const char * nameFile,
          ::CORBA::Long flag,
          const ::net::etech::GESTIONE_PSWDSeq & pswdSequence);

        virtual ::CORBA::Long getFilePSWD (
          const char * nameSwitch,
          const char * nameFile,
          ::CORBA::Long flag,
          ::net::etech::GESTIONE_PSWDSeq_out pswdSequence);

        virtual void shutDown (
          void);

        // TAO_IDL - Generated from
        // be/be_visitor_interface/interface_ch.cpp:140

        virtual ::CORBA::Boolean _is_a (const char *type_id);
        virtual const char* _interface_repository_id (void) const;
        virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
      
      protected:
        // Concrete interface only.
        PsMonitorMasterServer (void);

        // Concrete non-local interface only.
        PsMonitorMasterServer (
            ::IOP::IOR *ior,
            TAO_ORB_Core *orb_core);
        
        // Non-local interface only.
        PsMonitorMasterServer (
            TAO_Stub *objref,
            ::CORBA::Boolean _tao_collocated = false,
            TAO_Abstract_ServantBase *servant = 0,
            TAO_ORB_Core *orb_core = 0);

        virtual ~PsMonitorMasterServer (void);
      
      private:
        // Private and unimplemented for concrete interfaces.
        PsMonitorMasterServer (const PsMonitorMasterServer &);

        void operator= (const PsMonitorMasterServer &);
      };

      // TAO_IDL - Generated from
      // be/be_interface.cpp:751

#if !defined (_NET_ETECH_SSM_DBCONFIGURATIONSERVER__VAR_OUT_CH_)
#define _NET_ETECH_SSM_DBCONFIGURATIONSERVER__VAR_OUT_CH_

      class DBConfigurationServer;
      typedef DBConfigurationServer *DBConfigurationServer_ptr;

      typedef
        TAO_Objref_Var_T<
            DBConfigurationServer
          >
        DBConfigurationServer_var;
      
      typedef
        TAO_Objref_Out_T<
            DBConfigurationServer
          >
        DBConfigurationServer_out;

#endif /* end #if !defined */

      // TAO_IDL - Generated from
      // be/be_visitor_interface/interface_ch.cpp:43

      class  DBConfigurationServer
        : public virtual ::CORBA::Object
      {
      public:
        friend class TAO::Narrow_Utils<DBConfigurationServer>;

        // TAO_IDL - Generated from
        // be/be_type.cpp:307

        typedef DBConfigurationServer_ptr _ptr_type;
        typedef DBConfigurationServer_var _var_type;
        typedef DBConfigurationServer_out _out_type;

        // The static operations.
        static DBConfigurationServer_ptr _duplicate (DBConfigurationServer_ptr obj);

        static void _tao_release (DBConfigurationServer_ptr obj);

        static DBConfigurationServer_ptr _narrow (::CORBA::Object_ptr obj);
        static DBConfigurationServer_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
        static DBConfigurationServer_ptr _nil (void);

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eDBCS = 3;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eBLOCK_SIZE = 1;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const char *const eCHIAVE;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eDIM_PSWD_NOME_NODO = 50;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eDIM_PSWD_OGGETTO = 100;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eDIM_PSWD_LOGIN = 50;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eDIM_PSWD_PASSWORD = 50;

        // TAO_IDL - Generated from
        // be/be_visitor_constant/constant_ch.cpp:38

        static const CORBA::Long eDIM_PSWD_DATA_SCADENZA = 9;

        virtual ::CORBA::Long renameIndexTimeCFG (
          const char * nameFile);

        virtual ::CORBA::Long putFilePSWD (
          const char * nameFile,
          ::CORBA::Long flag,
          const ::net::etech::GESTIONE_PSWDSeq & pswdSequence);

        virtual ::CORBA::Long getFilePSWD (
          const char * nameFile,
          ::CORBA::Long flag,
          ::net::etech::GESTIONE_PSWDSeq_out pswdSequence);

        virtual void shutDown (
          void);

        // TAO_IDL - Generated from
        // be/be_visitor_interface/interface_ch.cpp:140

        virtual ::CORBA::Boolean _is_a (const char *type_id);
        virtual const char* _interface_repository_id (void) const;
        virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
      
      protected:
        // Concrete interface only.
        DBConfigurationServer (void);

        // Concrete non-local interface only.
        DBConfigurationServer (
            ::IOP::IOR *ior,
            TAO_ORB_Core *orb_core);
        
        // Non-local interface only.
        DBConfigurationServer (
            TAO_Stub *objref,
            ::CORBA::Boolean _tao_collocated = false,
            TAO_Abstract_ServantBase *servant = 0,
            TAO_ORB_Core *orb_core = 0);

        virtual ~DBConfigurationServer (void);
      
      private:
        // Private and unimplemented for concrete interfaces.
        DBConfigurationServer (const DBConfigurationServer &);

        void operator= (const DBConfigurationServer &);
      };

      // TAO_IDL - Generated from
      // be/be_interface.cpp:751

#if !defined (_NET_ETECH_SSM_SSM_SCHEDULER_SERVER__VAR_OUT_CH_)
#define _NET_ETECH_SSM_SSM_SCHEDULER_SERVER__VAR_OUT_CH_

      class ssm_scheduler_server;
      typedef ssm_scheduler_server *ssm_scheduler_server_ptr;

      typedef
        TAO_Objref_Var_T<
            ssm_scheduler_server
          >
        ssm_scheduler_server_var;
      
      typedef
        TAO_Objref_Out_T<
            ssm_scheduler_server
          >
        ssm_scheduler_server_out;

#endif /* end #if !defined */

      // TAO_IDL - Generated from
      // be/be_visitor_interface/interface_ch.cpp:43

      class  ssm_scheduler_server
        : public virtual ::CORBA::Object
      {
      public:
        friend class TAO::Narrow_Utils<ssm_scheduler_server>;

        // TAO_IDL - Generated from
        // be/be_type.cpp:307

        typedef ssm_scheduler_server_ptr _ptr_type;
        typedef ssm_scheduler_server_var _var_type;
        typedef ssm_scheduler_server_out _out_type;

        // The static operations.
        static ssm_scheduler_server_ptr _duplicate (ssm_scheduler_server_ptr obj);

        static void _tao_release (ssm_scheduler_server_ptr obj);

        static ssm_scheduler_server_ptr _narrow (::CORBA::Object_ptr obj);
        static ssm_scheduler_server_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
        static ssm_scheduler_server_ptr _nil (void);

        virtual void adamsConfigurationChanged (
          void);

        virtual void processConfigurationChanged (
          void);

        virtual void iniFileChanged (
          void);

        virtual ::CORBA::Boolean dummy (
          void);

        // TAO_IDL - Generated from
        // be/be_visitor_interface/interface_ch.cpp:140

        virtual ::CORBA::Boolean _is_a (const char *type_id);
        virtual const char* _interface_repository_id (void) const;
        virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
      
      protected:
        // Concrete interface only.
        ssm_scheduler_server (void);

        // Concrete non-local interface only.
        ssm_scheduler_server (
            ::IOP::IOR *ior,
            TAO_ORB_Core *orb_core);
        
        // Non-local interface only.
        ssm_scheduler_server (
            TAO_Stub *objref,
            ::CORBA::Boolean _tao_collocated = false,
            TAO_Abstract_ServantBase *servant = 0,
            TAO_ORB_Core *orb_core = 0);

        virtual ~ssm_scheduler_server (void);
      
      private:
        // Private and unimplemented for concrete interfaces.
        ssm_scheduler_server (const ssm_scheduler_server &);

        void operator= (const ssm_scheduler_server &);
      };

      // TAO_IDL - Generated from
      // be/be_interface.cpp:751

#if !defined (_NET_ETECH_SSM_SSM_LOGGER_SERVER__VAR_OUT_CH_)
#define _NET_ETECH_SSM_SSM_LOGGER_SERVER__VAR_OUT_CH_

      class ssm_logger_server;
      typedef ssm_logger_server *ssm_logger_server_ptr;

      typedef
        TAO_Objref_Var_T<
            ssm_logger_server
          >
        ssm_logger_server_var;
      
      typedef
        TAO_Objref_Out_T<
            ssm_logger_server
          >
        ssm_logger_server_out;

#endif /* end #if !defined */

      // TAO_IDL - Generated from
      // be/be_visitor_interface/interface_ch.cpp:43

      class  ssm_logger_server
        : public virtual ::CORBA::Object
      {
      public:
        friend class TAO::Narrow_Utils<ssm_logger_server>;

        // TAO_IDL - Generated from
        // be/be_type.cpp:307

        typedef ssm_logger_server_ptr _ptr_type;
        typedef ssm_logger_server_var _var_type;
        typedef ssm_logger_server_out _out_type;

        // The static operations.
        static ssm_logger_server_ptr _duplicate (ssm_logger_server_ptr obj);

        static void _tao_release (ssm_logger_server_ptr obj);

        static ssm_logger_server_ptr _narrow (::CORBA::Object_ptr obj);
        static ssm_logger_server_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
        static ssm_logger_server_ptr _nil (void);

        virtual ::CORBA::Boolean get_logs (
          const char * process_name);

        // TAO_IDL - Generated from
        // be/be_visitor_interface/interface_ch.cpp:140

        virtual ::CORBA::Boolean _is_a (const char *type_id);
        virtual const char* _interface_repository_id (void) const;
        virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
      
      protected:
        // Concrete interface only.
        ssm_logger_server (void);

        // Concrete non-local interface only.
        ssm_logger_server (
            ::IOP::IOR *ior,
            TAO_ORB_Core *orb_core);
        
        // Non-local interface only.
        ssm_logger_server (
            TAO_Stub *objref,
            ::CORBA::Boolean _tao_collocated = false,
            TAO_Abstract_ServantBase *servant = 0,
            TAO_ORB_Core *orb_core = 0);

        virtual ~ssm_logger_server (void);
      
      private:
        // Private and unimplemented for concrete interfaces.
        ssm_logger_server (const ssm_logger_server &);

        void operator= (const ssm_logger_server &);
      };

      // TAO_IDL - Generated from
      // be/be_interface.cpp:751

#if !defined (_NET_ETECH_SSM_SSM_GARBAGE_SERVER__VAR_OUT_CH_)
#define _NET_ETECH_SSM_SSM_GARBAGE_SERVER__VAR_OUT_CH_

      class ssm_garbage_server;
      typedef ssm_garbage_server *ssm_garbage_server_ptr;

      typedef
        TAO_Objref_Var_T<
            ssm_garbage_server
          >
        ssm_garbage_server_var;
      
      typedef
        TAO_Objref_Out_T<
            ssm_garbage_server
          >
        ssm_garbage_server_out;

#endif /* end #if !defined */

      // TAO_IDL - Generated from
      // be/be_visitor_interface/interface_ch.cpp:43

      class  ssm_garbage_server
        : public virtual ::CORBA::Object
      {
      public:
        friend class TAO::Narrow_Utils<ssm_garbage_server>;

        // TAO_IDL - Generated from
        // be/be_type.cpp:307

        typedef ssm_garbage_server_ptr _ptr_type;
        typedef ssm_garbage_server_var _var_type;
        typedef ssm_garbage_server_out _out_type;

        // The static operations.
        static ssm_garbage_server_ptr _duplicate (ssm_garbage_server_ptr obj);

        static void _tao_release (ssm_garbage_server_ptr obj);

        static ssm_garbage_server_ptr _narrow (::CORBA::Object_ptr obj);
        static ssm_garbage_server_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
        static ssm_garbage_server_ptr _nil (void);

        virtual ::CORBA::Boolean dummy (
          void);

        // TAO_IDL - Generated from
        // be/be_visitor_interface/interface_ch.cpp:140

        virtual ::CORBA::Boolean _is_a (const char *type_id);
        virtual const char* _interface_repository_id (void) const;
        virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
      
      protected:
        // Concrete interface only.
        ssm_garbage_server (void);

        // Concrete non-local interface only.
        ssm_garbage_server (
            ::IOP::IOR *ior,
            TAO_ORB_Core *orb_core);
        
        // Non-local interface only.
        ssm_garbage_server (
            TAO_Stub *objref,
            ::CORBA::Boolean _tao_collocated = false,
            TAO_Abstract_ServantBase *servant = 0,
            TAO_ORB_Core *orb_core = 0);

        virtual ~ssm_garbage_server (void);
      
      private:
        // Private and unimplemented for concrete interfaces.
        ssm_garbage_server (const ssm_garbage_server &);

        void operator= (const ssm_garbage_server &);
      };

      // TAO_IDL - Generated from
      // be/be_interface.cpp:751

#if !defined (_NET_ETECH_SSM_SSM_DEPLOYER_SERVER__VAR_OUT_CH_)
#define _NET_ETECH_SSM_SSM_DEPLOYER_SERVER__VAR_OUT_CH_

      class ssm_deployer_server;
      typedef ssm_deployer_server *ssm_deployer_server_ptr;

      typedef
        TAO_Objref_Var_T<
            ssm_deployer_server
          >
        ssm_deployer_server_var;
      
      typedef
        TAO_Objref_Out_T<
            ssm_deployer_server
          >
        ssm_deployer_server_out;

#endif /* end #if !defined */

      // TAO_IDL - Generated from
      // be/be_visitor_interface/interface_ch.cpp:43

      class  ssm_deployer_server
        : public virtual ::CORBA::Object
      {
      public:
        friend class TAO::Narrow_Utils<ssm_deployer_server>;

        // TAO_IDL - Generated from
        // be/be_type.cpp:307

        typedef ssm_deployer_server_ptr _ptr_type;
        typedef ssm_deployer_server_var _var_type;
        typedef ssm_deployer_server_out _out_type;

        // The static operations.
        static ssm_deployer_server_ptr _duplicate (ssm_deployer_server_ptr obj);

        static void _tao_release (ssm_deployer_server_ptr obj);

        static ssm_deployer_server_ptr _narrow (::CORBA::Object_ptr obj);
        static ssm_deployer_server_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
        static ssm_deployer_server_ptr _nil (void);

        virtual ::CORBA::Boolean dummy (
          void);

        // TAO_IDL - Generated from
        // be/be_visitor_interface/interface_ch.cpp:140

        virtual ::CORBA::Boolean _is_a (const char *type_id);
        virtual const char* _interface_repository_id (void) const;
        virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
      
      protected:
        // Concrete interface only.
        ssm_deployer_server (void);

        // Concrete non-local interface only.
        ssm_deployer_server (
            ::IOP::IOR *ior,
            TAO_ORB_Core *orb_core);
        
        // Non-local interface only.
        ssm_deployer_server (
            TAO_Stub *objref,
            ::CORBA::Boolean _tao_collocated = false,
            TAO_Abstract_ServantBase *servant = 0,
            TAO_ORB_Core *orb_core = 0);

        virtual ~ssm_deployer_server (void);
      
      private:
        // Private and unimplemented for concrete interfaces.
        ssm_deployer_server (const ssm_deployer_server &);

        void operator= (const ssm_deployer_server &);
      };
    
    // TAO_IDL - Generated from
    // be/be_visitor_module/module_ch.cpp:67
    
    } // module net::etech::SSM
  
  // TAO_IDL - Generated from
  // be/be_visitor_module/module_ch.cpp:67
  
  } // module net::etech

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:67

} // module net

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:68

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::net::etech::DATA_CENTRALI>
    : public
        Fixed_Size_Arg_Traits_T<
            ::net::etech::DATA_CENTRALI,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::net::etech::CentralSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::net::etech::CentralSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::net::etech::logProcess>
    : public
        Fixed_Size_Arg_Traits_T<
            ::net::etech::logProcess,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::net::etech::LogProcessSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::net::etech::LogProcessSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::net::etech::ParamSeqSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::net::etech::ParamSeqSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::net::etech::ProcesDetail>
    : public
        Var_Size_Arg_Traits_T<
            ::net::etech::ProcesDetail,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::net::etech::ProcesDetailSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::net::etech::ProcesDetailSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::net::etech::tempoRis>
    : public
        Fixed_Size_Arg_Traits_T<
            ::net::etech::tempoRis,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::net::etech::CS_INFO_PROC>
    : public
        Fixed_Size_Arg_Traits_T<
            ::net::etech::CS_INFO_PROC,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::net::etech::CS_INFO_PROCSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::net::etech::CS_INFO_PROCSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::net::etech::CS_BLOCK_LOG>
    : public
        Fixed_Size_Arg_Traits_T<
            ::net::etech::CS_BLOCK_LOG,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::net::etech::CS_BLOCK_LOGSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::net::etech::CS_BLOCK_LOGSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::net::etech::GARBAGE_INFO>
    : public
        Fixed_Size_Arg_Traits_T<
            ::net::etech::GARBAGE_INFO,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::net::etech::GARBAGE_INFOSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::net::etech::GARBAGE_INFOSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::net::etech::ACQ_CAT>
    : public
        Fixed_Size_Arg_Traits_T<
            ::net::etech::ACQ_CAT,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::net::etech::ACQ_CATSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::net::etech::ACQ_CATSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::net::etech::ACQ_PEB_MGR>
    : public
        Var_Size_Arg_Traits_T<
            ::net::etech::ACQ_PEB_MGR,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::net::etech::GESTIONE_PSWD>
    : public
        Fixed_Size_Arg_Traits_T<
            ::net::etech::GESTIONE_PSWD,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::net::etech::GESTIONE_PSWDSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::net::etech::GESTIONE_PSWDSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_NET_ETECH_SSM_CONFIGMONITORSERVER__ARG_TRAITS_)
#define _NET_ETECH_SSM_CONFIGMONITORSERVER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::net::etech::SSM::ConfigMonitorServer>
    : public
        Object_Arg_Traits_T<
            ::net::etech::SSM::ConfigMonitorServer_ptr,
            ::net::etech::SSM::ConfigMonitorServer_var,
            ::net::etech::SSM::ConfigMonitorServer_out,
            TAO::Objref_Traits<net::etech::SSM::ConfigMonitorServer>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_NET_ETECH_SSM_PROCESSMONITORSERVER__ARG_TRAITS_)
#define _NET_ETECH_SSM_PROCESSMONITORSERVER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::net::etech::SSM::ProcessMonitorServer>
    : public
        Object_Arg_Traits_T<
            ::net::etech::SSM::ProcessMonitorServer_ptr,
            ::net::etech::SSM::ProcessMonitorServer_var,
            ::net::etech::SSM::ProcessMonitorServer_out,
            TAO::Objref_Traits<net::etech::SSM::ProcessMonitorServer>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_NET_ETECH_SSM_ACQPEBMGRSERVER__ARG_TRAITS_)
#define _NET_ETECH_SSM_ACQPEBMGRSERVER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::net::etech::SSM::ACQPebMGRServer>
    : public
        Object_Arg_Traits_T<
            ::net::etech::SSM::ACQPebMGRServer_ptr,
            ::net::etech::SSM::ACQPebMGRServer_var,
            ::net::etech::SSM::ACQPebMGRServer_out,
            TAO::Objref_Traits<net::etech::SSM::ACQPebMGRServer>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_NET_ETECH_SSM_GARBAGEMONITORSERVER__ARG_TRAITS_)
#define _NET_ETECH_SSM_GARBAGEMONITORSERVER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::net::etech::SSM::GarbageMonitorServer>
    : public
        Object_Arg_Traits_T<
            ::net::etech::SSM::GarbageMonitorServer_ptr,
            ::net::etech::SSM::GarbageMonitorServer_var,
            ::net::etech::SSM::GarbageMonitorServer_out,
            TAO::Objref_Traits<net::etech::SSM::GarbageMonitorServer>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_NET_ETECH_SSM_PSMONITORMASTERSERVER__ARG_TRAITS_)
#define _NET_ETECH_SSM_PSMONITORMASTERSERVER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::net::etech::SSM::PsMonitorMasterServer>
    : public
        Object_Arg_Traits_T<
            ::net::etech::SSM::PsMonitorMasterServer_ptr,
            ::net::etech::SSM::PsMonitorMasterServer_var,
            ::net::etech::SSM::PsMonitorMasterServer_out,
            TAO::Objref_Traits<net::etech::SSM::PsMonitorMasterServer>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_NET_ETECH_SSM_DBCONFIGURATIONSERVER__ARG_TRAITS_)
#define _NET_ETECH_SSM_DBCONFIGURATIONSERVER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::net::etech::SSM::DBConfigurationServer>
    : public
        Object_Arg_Traits_T<
            ::net::etech::SSM::DBConfigurationServer_ptr,
            ::net::etech::SSM::DBConfigurationServer_var,
            ::net::etech::SSM::DBConfigurationServer_out,
            TAO::Objref_Traits<net::etech::SSM::DBConfigurationServer>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_NET_ETECH_SSM_SSM_SCHEDULER_SERVER__ARG_TRAITS_)
#define _NET_ETECH_SSM_SSM_SCHEDULER_SERVER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::net::etech::SSM::ssm_scheduler_server>
    : public
        Object_Arg_Traits_T<
            ::net::etech::SSM::ssm_scheduler_server_ptr,
            ::net::etech::SSM::ssm_scheduler_server_var,
            ::net::etech::SSM::ssm_scheduler_server_out,
            TAO::Objref_Traits<net::etech::SSM::ssm_scheduler_server>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_NET_ETECH_SSM_SSM_LOGGER_SERVER__ARG_TRAITS_)
#define _NET_ETECH_SSM_SSM_LOGGER_SERVER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::net::etech::SSM::ssm_logger_server>
    : public
        Object_Arg_Traits_T<
            ::net::etech::SSM::ssm_logger_server_ptr,
            ::net::etech::SSM::ssm_logger_server_var,
            ::net::etech::SSM::ssm_logger_server_out,
            TAO::Objref_Traits<net::etech::SSM::ssm_logger_server>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_NET_ETECH_SSM_SSM_GARBAGE_SERVER__ARG_TRAITS_)
#define _NET_ETECH_SSM_SSM_GARBAGE_SERVER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::net::etech::SSM::ssm_garbage_server>
    : public
        Object_Arg_Traits_T<
            ::net::etech::SSM::ssm_garbage_server_ptr,
            ::net::etech::SSM::ssm_garbage_server_var,
            ::net::etech::SSM::ssm_garbage_server_out,
            TAO::Objref_Traits<net::etech::SSM::ssm_garbage_server>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_NET_ETECH_SSM_SSM_DEPLOYER_SERVER__ARG_TRAITS_)
#define _NET_ETECH_SSM_SSM_DEPLOYER_SERVER__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::net::etech::SSM::ssm_deployer_server>
    : public
        Object_Arg_Traits_T<
            ::net::etech::SSM::ssm_deployer_server_ptr,
            ::net::etech::SSM::ssm_deployer_server_var,
            ::net::etech::SSM::ssm_deployer_server_out,
            TAO::Objref_Traits<net::etech::SSM::ssm_deployer_server>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_traits.cpp:62

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations.
namespace TAO
{
  template<>
  struct  Array_Traits<
      net::etech::DATA_CENTRALI::_Descrizione_forany
    >
  {
    static void free (
        net::etech::DATA_CENTRALI::_Descrizione_slice * _tao_slice);
    static net::etech::DATA_CENTRALI::_Descrizione_slice * dup (
        const net::etech::DATA_CENTRALI::_Descrizione_slice * _tao_slice);
    static void copy (
        net::etech::DATA_CENTRALI::_Descrizione_slice * _tao_to,
        const net::etech::DATA_CENTRALI::_Descrizione_slice * _tao_from);
    static net::etech::DATA_CENTRALI::_Descrizione_slice * alloc (void);
    static void zero (
        net::etech::DATA_CENTRALI::_Descrizione_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::logProcess::_descr_forany
    >
  {
    static void free (
        net::etech::logProcess::_descr_slice * _tao_slice);
    static net::etech::logProcess::_descr_slice * dup (
        const net::etech::logProcess::_descr_slice * _tao_slice);
    static void copy (
        net::etech::logProcess::_descr_slice * _tao_to,
        const net::etech::logProcess::_descr_slice * _tao_from);
    static net::etech::logProcess::_descr_slice * alloc (void);
    static void zero (
        net::etech::logProcess::_descr_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::ProcesDetail::_tipoProcesso_forany
    >
  {
    static void free (
        net::etech::ProcesDetail::_tipoProcesso_slice * _tao_slice);
    static net::etech::ProcesDetail::_tipoProcesso_slice * dup (
        const net::etech::ProcesDetail::_tipoProcesso_slice * _tao_slice);
    static void copy (
        net::etech::ProcesDetail::_tipoProcesso_slice * _tao_to,
        const net::etech::ProcesDetail::_tipoProcesso_slice * _tao_from);
    static net::etech::ProcesDetail::_tipoProcesso_slice * alloc (void);
    static void zero (
        net::etech::ProcesDetail::_tipoProcesso_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::ProcesDetail::_nomeProcesso_forany
    >
  {
    static void free (
        net::etech::ProcesDetail::_nomeProcesso_slice * _tao_slice);
    static net::etech::ProcesDetail::_nomeProcesso_slice * dup (
        const net::etech::ProcesDetail::_nomeProcesso_slice * _tao_slice);
    static void copy (
        net::etech::ProcesDetail::_nomeProcesso_slice * _tao_to,
        const net::etech::ProcesDetail::_nomeProcesso_slice * _tao_from);
    static net::etech::ProcesDetail::_nomeProcesso_slice * alloc (void);
    static void zero (
        net::etech::ProcesDetail::_nomeProcesso_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::ProcesDetail::_colorBKnomeProcesso_forany
    >
  {
    static void free (
        net::etech::ProcesDetail::_colorBKnomeProcesso_slice * _tao_slice);
    static net::etech::ProcesDetail::_colorBKnomeProcesso_slice * dup (
        const net::etech::ProcesDetail::_colorBKnomeProcesso_slice * _tao_slice);
    static void copy (
        net::etech::ProcesDetail::_colorBKnomeProcesso_slice * _tao_to,
        const net::etech::ProcesDetail::_colorBKnomeProcesso_slice * _tao_from);
    static net::etech::ProcesDetail::_colorBKnomeProcesso_slice * alloc (void);
    static void zero (
        net::etech::ProcesDetail::_colorBKnomeProcesso_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::ProcesDetail::_msgProcesso_forany
    >
  {
    static void free (
        net::etech::ProcesDetail::_msgProcesso_slice * _tao_slice);
    static net::etech::ProcesDetail::_msgProcesso_slice * dup (
        const net::etech::ProcesDetail::_msgProcesso_slice * _tao_slice);
    static void copy (
        net::etech::ProcesDetail::_msgProcesso_slice * _tao_to,
        const net::etech::ProcesDetail::_msgProcesso_slice * _tao_from);
    static net::etech::ProcesDetail::_msgProcesso_slice * alloc (void);
    static void zero (
        net::etech::ProcesDetail::_msgProcesso_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::ProcesDetail::_colorBKmsgProcesso_forany
    >
  {
    static void free (
        net::etech::ProcesDetail::_colorBKmsgProcesso_slice * _tao_slice);
    static net::etech::ProcesDetail::_colorBKmsgProcesso_slice * dup (
        const net::etech::ProcesDetail::_colorBKmsgProcesso_slice * _tao_slice);
    static void copy (
        net::etech::ProcesDetail::_colorBKmsgProcesso_slice * _tao_to,
        const net::etech::ProcesDetail::_colorBKmsgProcesso_slice * _tao_from);
    static net::etech::ProcesDetail::_colorBKmsgProcesso_slice * alloc (void);
    static void zero (
        net::etech::ProcesDetail::_colorBKmsgProcesso_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::CS_INFO_PROC::_legami_forany
    >
  {
    static void free (
        net::etech::CS_INFO_PROC::_legami_slice * _tao_slice);
    static net::etech::CS_INFO_PROC::_legami_slice * dup (
        const net::etech::CS_INFO_PROC::_legami_slice * _tao_slice);
    static void copy (
        net::etech::CS_INFO_PROC::_legami_slice * _tao_to,
        const net::etech::CS_INFO_PROC::_legami_slice * _tao_from);
    static net::etech::CS_INFO_PROC::_legami_slice * alloc (void);
    static void zero (
        net::etech::CS_INFO_PROC::_legami_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::CS_INFO_PROC::_nome_proc_forany
    >
  {
    static void free (
        net::etech::CS_INFO_PROC::_nome_proc_slice * _tao_slice);
    static net::etech::CS_INFO_PROC::_nome_proc_slice * dup (
        const net::etech::CS_INFO_PROC::_nome_proc_slice * _tao_slice);
    static void copy (
        net::etech::CS_INFO_PROC::_nome_proc_slice * _tao_to,
        const net::etech::CS_INFO_PROC::_nome_proc_slice * _tao_from);
    static net::etech::CS_INFO_PROC::_nome_proc_slice * alloc (void);
    static void zero (
        net::etech::CS_INFO_PROC::_nome_proc_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::CS_INFO_PROC::_cmd_start_forany
    >
  {
    static void free (
        net::etech::CS_INFO_PROC::_cmd_start_slice * _tao_slice);
    static net::etech::CS_INFO_PROC::_cmd_start_slice * dup (
        const net::etech::CS_INFO_PROC::_cmd_start_slice * _tao_slice);
    static void copy (
        net::etech::CS_INFO_PROC::_cmd_start_slice * _tao_to,
        const net::etech::CS_INFO_PROC::_cmd_start_slice * _tao_from);
    static net::etech::CS_INFO_PROC::_cmd_start_slice * alloc (void);
    static void zero (
        net::etech::CS_INFO_PROC::_cmd_start_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::CS_INFO_PROC::_nome_fep_forany
    >
  {
    static void free (
        net::etech::CS_INFO_PROC::_nome_fep_slice * _tao_slice);
    static net::etech::CS_INFO_PROC::_nome_fep_slice * dup (
        const net::etech::CS_INFO_PROC::_nome_fep_slice * _tao_slice);
    static void copy (
        net::etech::CS_INFO_PROC::_nome_fep_slice * _tao_to,
        const net::etech::CS_INFO_PROC::_nome_fep_slice * _tao_from);
    static net::etech::CS_INFO_PROC::_nome_fep_slice * alloc (void);
    static void zero (
        net::etech::CS_INFO_PROC::_nome_fep_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::CS_BLOCK_LOG::_msg_forany
    >
  {
    static void free (
        net::etech::CS_BLOCK_LOG::_msg_slice * _tao_slice);
    static net::etech::CS_BLOCK_LOG::_msg_slice * dup (
        const net::etech::CS_BLOCK_LOG::_msg_slice * _tao_slice);
    static void copy (
        net::etech::CS_BLOCK_LOG::_msg_slice * _tao_to,
        const net::etech::CS_BLOCK_LOG::_msg_slice * _tao_from);
    static net::etech::CS_BLOCK_LOG::_msg_slice * alloc (void);
    static void zero (
        net::etech::CS_BLOCK_LOG::_msg_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::CS_BLOCK_LOG::_nome_forany
    >
  {
    static void free (
        net::etech::CS_BLOCK_LOG::_nome_slice * _tao_slice);
    static net::etech::CS_BLOCK_LOG::_nome_slice * dup (
        const net::etech::CS_BLOCK_LOG::_nome_slice * _tao_slice);
    static void copy (
        net::etech::CS_BLOCK_LOG::_nome_slice * _tao_to,
        const net::etech::CS_BLOCK_LOG::_nome_slice * _tao_from);
    static net::etech::CS_BLOCK_LOG::_nome_slice * alloc (void);
    static void zero (
        net::etech::CS_BLOCK_LOG::_nome_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::GARBAGE_INFO::_user_forany
    >
  {
    static void free (
        net::etech::GARBAGE_INFO::_user_slice * _tao_slice);
    static net::etech::GARBAGE_INFO::_user_slice * dup (
        const net::etech::GARBAGE_INFO::_user_slice * _tao_slice);
    static void copy (
        net::etech::GARBAGE_INFO::_user_slice * _tao_to,
        const net::etech::GARBAGE_INFO::_user_slice * _tao_from);
    static net::etech::GARBAGE_INFO::_user_slice * alloc (void);
    static void zero (
        net::etech::GARBAGE_INFO::_user_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::GARBAGE_INFO::_path_forany
    >
  {
    static void free (
        net::etech::GARBAGE_INFO::_path_slice * _tao_slice);
    static net::etech::GARBAGE_INFO::_path_slice * dup (
        const net::etech::GARBAGE_INFO::_path_slice * _tao_slice);
    static void copy (
        net::etech::GARBAGE_INFO::_path_slice * _tao_to,
        const net::etech::GARBAGE_INFO::_path_slice * _tao_from);
    static net::etech::GARBAGE_INFO::_path_slice * alloc (void);
    static void zero (
        net::etech::GARBAGE_INFO::_path_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::GARBAGE_INFO::_filter_forany
    >
  {
    static void free (
        net::etech::GARBAGE_INFO::_filter_slice * _tao_slice);
    static net::etech::GARBAGE_INFO::_filter_slice * dup (
        const net::etech::GARBAGE_INFO::_filter_slice * _tao_slice);
    static void copy (
        net::etech::GARBAGE_INFO::_filter_slice * _tao_to,
        const net::etech::GARBAGE_INFO::_filter_slice * _tao_from);
    static net::etech::GARBAGE_INFO::_filter_slice * alloc (void);
    static void zero (
        net::etech::GARBAGE_INFO::_filter_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::GARBAGE_INFO::_frequence_forany
    >
  {
    static void free (
        net::etech::GARBAGE_INFO::_frequence_slice * _tao_slice);
    static net::etech::GARBAGE_INFO::_frequence_slice * dup (
        const net::etech::GARBAGE_INFO::_frequence_slice * _tao_slice);
    static void copy (
        net::etech::GARBAGE_INFO::_frequence_slice * _tao_to,
        const net::etech::GARBAGE_INFO::_frequence_slice * _tao_from);
    static net::etech::GARBAGE_INFO::_frequence_slice * alloc (void);
    static void zero (
        net::etech::GARBAGE_INFO::_frequence_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::GARBAGE_INFO::_path_log_forany
    >
  {
    static void free (
        net::etech::GARBAGE_INFO::_path_log_slice * _tao_slice);
    static net::etech::GARBAGE_INFO::_path_log_slice * dup (
        const net::etech::GARBAGE_INFO::_path_log_slice * _tao_slice);
    static void copy (
        net::etech::GARBAGE_INFO::_path_log_slice * _tao_to,
        const net::etech::GARBAGE_INFO::_path_log_slice * _tao_from);
    static net::etech::GARBAGE_INFO::_path_log_slice * alloc (void);
    static void zero (
        net::etech::GARBAGE_INFO::_path_log_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::ACQ_CAT::_name_forany
    >
  {
    static void free (
        net::etech::ACQ_CAT::_name_slice * _tao_slice);
    static net::etech::ACQ_CAT::_name_slice * dup (
        const net::etech::ACQ_CAT::_name_slice * _tao_slice);
    static void copy (
        net::etech::ACQ_CAT::_name_slice * _tao_to,
        const net::etech::ACQ_CAT::_name_slice * _tao_from);
    static net::etech::ACQ_CAT::_name_slice * alloc (void);
    static void zero (
        net::etech::ACQ_CAT::_name_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::ACQ_PEB_MGR::_processing_forany
    >
  {
    static void free (
        net::etech::ACQ_PEB_MGR::_processing_slice * _tao_slice);
    static net::etech::ACQ_PEB_MGR::_processing_slice * dup (
        const net::etech::ACQ_PEB_MGR::_processing_slice * _tao_slice);
    static void copy (
        net::etech::ACQ_PEB_MGR::_processing_slice * _tao_to,
        const net::etech::ACQ_PEB_MGR::_processing_slice * _tao_from);
    static net::etech::ACQ_PEB_MGR::_processing_slice * alloc (void);
    static void zero (
        net::etech::ACQ_PEB_MGR::_processing_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::ACQ_PEB_MGR::_PEBName_forany
    >
  {
    static void free (
        net::etech::ACQ_PEB_MGR::_PEBName_slice * _tao_slice);
    static net::etech::ACQ_PEB_MGR::_PEBName_slice * dup (
        const net::etech::ACQ_PEB_MGR::_PEBName_slice * _tao_slice);
    static void copy (
        net::etech::ACQ_PEB_MGR::_PEBName_slice * _tao_to,
        const net::etech::ACQ_PEB_MGR::_PEBName_slice * _tao_from);
    static net::etech::ACQ_PEB_MGR::_PEBName_slice * alloc (void);
    static void zero (
        net::etech::ACQ_PEB_MGR::_PEBName_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::GESTIONE_PSWD::_nomeNodo_forany
    >
  {
    static void free (
        net::etech::GESTIONE_PSWD::_nomeNodo_slice * _tao_slice);
    static net::etech::GESTIONE_PSWD::_nomeNodo_slice * dup (
        const net::etech::GESTIONE_PSWD::_nomeNodo_slice * _tao_slice);
    static void copy (
        net::etech::GESTIONE_PSWD::_nomeNodo_slice * _tao_to,
        const net::etech::GESTIONE_PSWD::_nomeNodo_slice * _tao_from);
    static net::etech::GESTIONE_PSWD::_nomeNodo_slice * alloc (void);
    static void zero (
        net::etech::GESTIONE_PSWD::_nomeNodo_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::GESTIONE_PSWD::_oggetto_forany
    >
  {
    static void free (
        net::etech::GESTIONE_PSWD::_oggetto_slice * _tao_slice);
    static net::etech::GESTIONE_PSWD::_oggetto_slice * dup (
        const net::etech::GESTIONE_PSWD::_oggetto_slice * _tao_slice);
    static void copy (
        net::etech::GESTIONE_PSWD::_oggetto_slice * _tao_to,
        const net::etech::GESTIONE_PSWD::_oggetto_slice * _tao_from);
    static net::etech::GESTIONE_PSWD::_oggetto_slice * alloc (void);
    static void zero (
        net::etech::GESTIONE_PSWD::_oggetto_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::GESTIONE_PSWD::_login_forany
    >
  {
    static void free (
        net::etech::GESTIONE_PSWD::_login_slice * _tao_slice);
    static net::etech::GESTIONE_PSWD::_login_slice * dup (
        const net::etech::GESTIONE_PSWD::_login_slice * _tao_slice);
    static void copy (
        net::etech::GESTIONE_PSWD::_login_slice * _tao_to,
        const net::etech::GESTIONE_PSWD::_login_slice * _tao_from);
    static net::etech::GESTIONE_PSWD::_login_slice * alloc (void);
    static void zero (
        net::etech::GESTIONE_PSWD::_login_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::GESTIONE_PSWD::_pswd_forany
    >
  {
    static void free (
        net::etech::GESTIONE_PSWD::_pswd_slice * _tao_slice);
    static net::etech::GESTIONE_PSWD::_pswd_slice * dup (
        const net::etech::GESTIONE_PSWD::_pswd_slice * _tao_slice);
    static void copy (
        net::etech::GESTIONE_PSWD::_pswd_slice * _tao_to,
        const net::etech::GESTIONE_PSWD::_pswd_slice * _tao_from);
    static net::etech::GESTIONE_PSWD::_pswd_slice * alloc (void);
    static void zero (
        net::etech::GESTIONE_PSWD::_pswd_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      net::etech::GESTIONE_PSWD::_dataScadenza_forany
    >
  {
    static void free (
        net::etech::GESTIONE_PSWD::_dataScadenza_slice * _tao_slice);
    static net::etech::GESTIONE_PSWD::_dataScadenza_slice * dup (
        const net::etech::GESTIONE_PSWD::_dataScadenza_slice * _tao_slice);
    static void copy (
        net::etech::GESTIONE_PSWD::_dataScadenza_slice * _tao_to,
        const net::etech::GESTIONE_PSWD::_dataScadenza_slice * _tao_from);
    static net::etech::GESTIONE_PSWD::_dataScadenza_slice * alloc (void);
    static void zero (
        net::etech::GESTIONE_PSWD::_dataScadenza_slice * _tao_slice);
  };

#if !defined (_NET_ETECH_SSM_CONFIGMONITORSERVER__TRAITS_)
#define _NET_ETECH_SSM_CONFIGMONITORSERVER__TRAITS_

  template<>
  struct  Objref_Traits< ::net::etech::SSM::ConfigMonitorServer>
  {
    static ::net::etech::SSM::ConfigMonitorServer_ptr duplicate (
        ::net::etech::SSM::ConfigMonitorServer_ptr p);
    static void release (
        ::net::etech::SSM::ConfigMonitorServer_ptr p);
    static ::net::etech::SSM::ConfigMonitorServer_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::net::etech::SSM::ConfigMonitorServer_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_NET_ETECH_SSM_PROCESSMONITORSERVER__TRAITS_)
#define _NET_ETECH_SSM_PROCESSMONITORSERVER__TRAITS_

  template<>
  struct  Objref_Traits< ::net::etech::SSM::ProcessMonitorServer>
  {
    static ::net::etech::SSM::ProcessMonitorServer_ptr duplicate (
        ::net::etech::SSM::ProcessMonitorServer_ptr p);
    static void release (
        ::net::etech::SSM::ProcessMonitorServer_ptr p);
    static ::net::etech::SSM::ProcessMonitorServer_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::net::etech::SSM::ProcessMonitorServer_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_NET_ETECH_SSM_ACQPEBMGRSERVER__TRAITS_)
#define _NET_ETECH_SSM_ACQPEBMGRSERVER__TRAITS_

  template<>
  struct  Objref_Traits< ::net::etech::SSM::ACQPebMGRServer>
  {
    static ::net::etech::SSM::ACQPebMGRServer_ptr duplicate (
        ::net::etech::SSM::ACQPebMGRServer_ptr p);
    static void release (
        ::net::etech::SSM::ACQPebMGRServer_ptr p);
    static ::net::etech::SSM::ACQPebMGRServer_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::net::etech::SSM::ACQPebMGRServer_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_NET_ETECH_SSM_GARBAGEMONITORSERVER__TRAITS_)
#define _NET_ETECH_SSM_GARBAGEMONITORSERVER__TRAITS_

  template<>
  struct  Objref_Traits< ::net::etech::SSM::GarbageMonitorServer>
  {
    static ::net::etech::SSM::GarbageMonitorServer_ptr duplicate (
        ::net::etech::SSM::GarbageMonitorServer_ptr p);
    static void release (
        ::net::etech::SSM::GarbageMonitorServer_ptr p);
    static ::net::etech::SSM::GarbageMonitorServer_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::net::etech::SSM::GarbageMonitorServer_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_NET_ETECH_SSM_PSMONITORMASTERSERVER__TRAITS_)
#define _NET_ETECH_SSM_PSMONITORMASTERSERVER__TRAITS_

  template<>
  struct  Objref_Traits< ::net::etech::SSM::PsMonitorMasterServer>
  {
    static ::net::etech::SSM::PsMonitorMasterServer_ptr duplicate (
        ::net::etech::SSM::PsMonitorMasterServer_ptr p);
    static void release (
        ::net::etech::SSM::PsMonitorMasterServer_ptr p);
    static ::net::etech::SSM::PsMonitorMasterServer_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::net::etech::SSM::PsMonitorMasterServer_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_NET_ETECH_SSM_DBCONFIGURATIONSERVER__TRAITS_)
#define _NET_ETECH_SSM_DBCONFIGURATIONSERVER__TRAITS_

  template<>
  struct  Objref_Traits< ::net::etech::SSM::DBConfigurationServer>
  {
    static ::net::etech::SSM::DBConfigurationServer_ptr duplicate (
        ::net::etech::SSM::DBConfigurationServer_ptr p);
    static void release (
        ::net::etech::SSM::DBConfigurationServer_ptr p);
    static ::net::etech::SSM::DBConfigurationServer_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::net::etech::SSM::DBConfigurationServer_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_NET_ETECH_SSM_SSM_SCHEDULER_SERVER__TRAITS_)
#define _NET_ETECH_SSM_SSM_SCHEDULER_SERVER__TRAITS_

  template<>
  struct  Objref_Traits< ::net::etech::SSM::ssm_scheduler_server>
  {
    static ::net::etech::SSM::ssm_scheduler_server_ptr duplicate (
        ::net::etech::SSM::ssm_scheduler_server_ptr p);
    static void release (
        ::net::etech::SSM::ssm_scheduler_server_ptr p);
    static ::net::etech::SSM::ssm_scheduler_server_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::net::etech::SSM::ssm_scheduler_server_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_NET_ETECH_SSM_SSM_LOGGER_SERVER__TRAITS_)
#define _NET_ETECH_SSM_SSM_LOGGER_SERVER__TRAITS_

  template<>
  struct  Objref_Traits< ::net::etech::SSM::ssm_logger_server>
  {
    static ::net::etech::SSM::ssm_logger_server_ptr duplicate (
        ::net::etech::SSM::ssm_logger_server_ptr p);
    static void release (
        ::net::etech::SSM::ssm_logger_server_ptr p);
    static ::net::etech::SSM::ssm_logger_server_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::net::etech::SSM::ssm_logger_server_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_NET_ETECH_SSM_SSM_GARBAGE_SERVER__TRAITS_)
#define _NET_ETECH_SSM_SSM_GARBAGE_SERVER__TRAITS_

  template<>
  struct  Objref_Traits< ::net::etech::SSM::ssm_garbage_server>
  {
    static ::net::etech::SSM::ssm_garbage_server_ptr duplicate (
        ::net::etech::SSM::ssm_garbage_server_ptr p);
    static void release (
        ::net::etech::SSM::ssm_garbage_server_ptr p);
    static ::net::etech::SSM::ssm_garbage_server_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::net::etech::SSM::ssm_garbage_server_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_NET_ETECH_SSM_SSM_DEPLOYER_SERVER__TRAITS_)
#define _NET_ETECH_SSM_SSM_DEPLOYER_SERVER__TRAITS_

  template<>
  struct  Objref_Traits< ::net::etech::SSM::ssm_deployer_server>
  {
    static ::net::etech::SSM::ssm_deployer_server_ptr duplicate (
        ::net::etech::SSM::ssm_deployer_server_ptr p);
    static void release (
        ::net::etech::SSM::ssm_deployer_server_ptr p);
    static ::net::etech::SSM::ssm_deployer_server_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::net::etech::SSM::ssm_deployer_server_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::DATA_CENTRALI &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::DATA_CENTRALI &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::DATA_CENTRALI::_Descrizione_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::DATA_CENTRALI::_Descrizione_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_net_etech_CentralSeq_H_
#define _TAO_CDR_OP_net_etech_CentralSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const net::etech::CentralSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    net::etech::CentralSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_net_etech_CentralSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::logProcess &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::logProcess &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::logProcess::_descr_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::logProcess::_descr_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_net_etech_LogProcessSeq_H_
#define _TAO_CDR_OP_net_etech_LogProcessSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const net::etech::LogProcessSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    net::etech::LogProcessSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_net_etech_LogProcessSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_net_etech_ParamSeqSeq_H_
#define _TAO_CDR_OP_net_etech_ParamSeqSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const net::etech::ParamSeqSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    net::etech::ParamSeqSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_net_etech_ParamSeqSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::ProcesDetail &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::ProcesDetail &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::ProcesDetail::_tipoProcesso_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::ProcesDetail::_tipoProcesso_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::ProcesDetail::_nomeProcesso_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::ProcesDetail::_nomeProcesso_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::ProcesDetail::_colorBKnomeProcesso_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::ProcesDetail::_colorBKnomeProcesso_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::ProcesDetail::_msgProcesso_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::ProcesDetail::_msgProcesso_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::ProcesDetail::_colorBKmsgProcesso_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::ProcesDetail::_colorBKmsgProcesso_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_net_etech_ProcesDetailSeq_H_
#define _TAO_CDR_OP_net_etech_ProcesDetailSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const net::etech::ProcesDetailSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    net::etech::ProcesDetailSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_net_etech_ProcesDetailSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::tempoRis &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::tempoRis &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::CS_INFO_PROC &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::CS_INFO_PROC &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::CS_INFO_PROC::_legami_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::CS_INFO_PROC::_legami_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::CS_INFO_PROC::_nome_proc_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::CS_INFO_PROC::_nome_proc_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::CS_INFO_PROC::_cmd_start_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::CS_INFO_PROC::_cmd_start_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::CS_INFO_PROC::_nome_fep_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::CS_INFO_PROC::_nome_fep_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_net_etech_CS_INFO_PROCSeq_H_
#define _TAO_CDR_OP_net_etech_CS_INFO_PROCSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const net::etech::CS_INFO_PROCSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    net::etech::CS_INFO_PROCSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_net_etech_CS_INFO_PROCSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::CS_BLOCK_LOG &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::CS_BLOCK_LOG &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::CS_BLOCK_LOG::_msg_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::CS_BLOCK_LOG::_msg_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::CS_BLOCK_LOG::_nome_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::CS_BLOCK_LOG::_nome_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_net_etech_CS_BLOCK_LOGSeq_H_
#define _TAO_CDR_OP_net_etech_CS_BLOCK_LOGSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const net::etech::CS_BLOCK_LOGSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    net::etech::CS_BLOCK_LOGSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_net_etech_CS_BLOCK_LOGSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::GARBAGE_INFO &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::GARBAGE_INFO &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::GARBAGE_INFO::_user_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::GARBAGE_INFO::_user_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::GARBAGE_INFO::_path_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::GARBAGE_INFO::_path_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::GARBAGE_INFO::_filter_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::GARBAGE_INFO::_filter_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::GARBAGE_INFO::_frequence_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::GARBAGE_INFO::_frequence_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::GARBAGE_INFO::_path_log_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::GARBAGE_INFO::_path_log_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_net_etech_GARBAGE_INFOSeq_H_
#define _TAO_CDR_OP_net_etech_GARBAGE_INFOSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const net::etech::GARBAGE_INFOSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    net::etech::GARBAGE_INFOSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_net_etech_GARBAGE_INFOSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::ACQ_CAT &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::ACQ_CAT &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::ACQ_CAT::_name_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::ACQ_CAT::_name_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_net_etech_ACQ_CATSeq_H_
#define _TAO_CDR_OP_net_etech_ACQ_CATSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const net::etech::ACQ_CATSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    net::etech::ACQ_CATSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_net_etech_ACQ_CATSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::ACQ_PEB_MGR &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::ACQ_PEB_MGR &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::ACQ_PEB_MGR::_processing_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::ACQ_PEB_MGR::_processing_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::ACQ_PEB_MGR::_PEBName_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::ACQ_PEB_MGR::_PEBName_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::GESTIONE_PSWD &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::GESTIONE_PSWD &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::GESTIONE_PSWD::_nomeNodo_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::GESTIONE_PSWD::_nomeNodo_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::GESTIONE_PSWD::_oggetto_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::GESTIONE_PSWD::_oggetto_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::GESTIONE_PSWD::_login_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::GESTIONE_PSWD::_login_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::GESTIONE_PSWD::_pswd_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::GESTIONE_PSWD::_pswd_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const net::etech::GESTIONE_PSWD::_dataScadenza_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::GESTIONE_PSWD::_dataScadenza_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_net_etech_GESTIONE_PSWDSeq_H_
#define _TAO_CDR_OP_net_etech_GESTIONE_PSWDSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const net::etech::GESTIONE_PSWDSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    net::etech::GESTIONE_PSWDSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_net_etech_GESTIONE_PSWDSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::SSM::ConfigMonitorServer_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::SSM::ConfigMonitorServer_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::SSM::ProcessMonitorServer_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::SSM::ProcessMonitorServer_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::SSM::ACQPebMGRServer_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::SSM::ACQPebMGRServer_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::SSM::GarbageMonitorServer_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::SSM::GarbageMonitorServer_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::SSM::PsMonitorMasterServer_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::SSM::PsMonitorMasterServer_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::SSM::DBConfigurationServer_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::SSM::DBConfigurationServer_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::SSM::ssm_scheduler_server_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::SSM::ssm_scheduler_server_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::SSM::ssm_logger_server_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::SSM::ssm_logger_server_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::SSM::ssm_garbage_server_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::SSM::ssm_garbage_server_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const net::etech::SSM::ssm_deployer_server_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, net::etech::SSM::ssm_deployer_server_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_codegen.cpp:1703
#if defined (__ACE_INLINE__)
#include "ssmC.inl"
#endif /* defined INLINE */

#include /**/ "ace/post.h"

#endif /* ifndef */

