
//----------------------------------------------------
// The following code was generated by CUP v0.9e
// Sun Aug 19 14:54:20 BST 2012
//----------------------------------------------------

package org.jacorb.idl;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Stack;
import java.util.Vector;
import org.jacorb.idl.util.IDLLogger;

public class parser extends org.jacorb.idl.runtime.lr_parser {

  /** constructor */
  public parser() {super();}

  /** production table */
  protected static final short _production_table[][] = {
        {0, 2},     {99, 0},     {7, 2},     {7, 1},     {9, 2}, 
        {9, 1},     {8, 2},     {8, 2},     {8, 2},     {8, 2}, 
        {8, 2},     {8, 2},     {8, 2},     {10, 5},     {11, 5}, 
        {12, 6},     {12, 7},     {12, 7},     {12, 7},     {12, 2}, 
        {12, 3},     {12, 3},     {12, 3},     {13, 2},     {13, 1}, 
        {14, 2},     {14, 2},     {14, 2},     {14, 2},     {14, 2}, 
        {96, 2},     {96, 1},     {96, 1},     {93, 3},     {93, 1}, 
        {15, 1},     {15, 2},     {15, 3},     {15, 1},     {17, 1}, 
        {17, 1},     {17, 1},     {18, 3},     {20, 7},     {20, 3}, 
        {21, 2},     {21, 1},     {19, 7},     {19, 2},     {19, 6}, 
        {22, 3},     {22, 2},     {22, 2},     {22, 5},     {22, 4}, 
        {22, 1},     {22, 1},     {16, 1},     {23, 2},     {23, 1}, 
        {24, 1},     {24, 1},     {24, 1},     {25, 4},     {25, 4}, 
        {26, 7},     {26, 6},     {91, 1},     {91, 3},     {27, 3}, 
        {28, 5},     {29, 1},     {29, 1},     {29, 1},     {29, 1}, 
        {29, 1},     {29, 1},     {29, 1},     {29, 1},     {30, 1}, 
        {32, 1},     {32, 3},     {33, 1},     {33, 3},     {34, 1}, 
        {34, 3},     {35, 1},     {35, 3},     {35, 3},     {36, 1}, 
        {36, 3},     {36, 3},     {37, 1},     {37, 3},     {37, 3}, 
        {37, 3},     {38, 2},     {38, 1},     {6, 1},     {6, 1}, 
        {6, 1},     {39, 1},     {39, 1},     {39, 3},     {75, 1}, 
        {75, 1},     {75, 3},     {75, 1},     {75, 1},     {75, 1}, 
        {75, 1},     {75, 1},     {76, 3},     {76, 6},     {76, 2}, 
        {76, 3},     {76, 6},     {76, 2},     {31, 1},     {40, 1}, 
        {40, 1},     {40, 1},     {40, 1},     {40, 1},     {46, 2}, 
        {41, 2},     {42, 1},     {42, 1},     {47, 1},     {47, 1}, 
        {47, 1},     {58, 1},     {58, 1},     {58, 1},     {58, 1}, 
        {58, 1},     {58, 1},     {58, 1},     {48, 1},     {48, 1}, 
        {48, 1},     {49, 1},     {49, 1},     {49, 1},     {95, 3}, 
        {95, 1},     {78, 1},     {78, 1},     {79, 1},     {60, 1}, 
        {60, 1},     {61, 1},     {62, 1},     {63, 1},     {63, 2}, 
        {59, 1},     {59, 1},     {59, 2},     {59, 2},     {59, 1}, 
        {59, 2},     {64, 1},     {65, 1},     {66, 2},     {67, 1}, 
        {67, 1},     {68, 1},     {69, 1},     {70, 1},     {51, 5}, 
        {51, 2},     {88, 1},     {88, 2},     {77, 3},     {53, 9}, 
        {53, 2},     {45, 1},     {45, 1},     {45, 1},     {45, 1}, 
        {45, 1},     {55, 1},     {55, 2},     {56, 3},     {89, 3}, 
        {89, 2},     {89, 4},     {89, 3},     {57, 2},     {50, 5}, 
        {97, 1},     {97, 3},     {54, 2},     {73, 6},     {73, 4}, 
        {72, 4},     {72, 4},     {72, 1},     {72, 1},     {74, 6}, 
        {80, 2},     {98, 1},     {98, 2},     {81, 3},     {86, 4}, 
        {86, 5},     {86, 3},     {86, 4},     {87, 8},     {87, 8}, 
        {87, 4},     {87, 4},     {94, 1},     {94, 3},     {52, 4}, 
        {52, 5},     {85, 6},     {4, 1},     {4, 1},     {43, 1}, 
        {43, 1},     {71, 1},     {92, 3},     {92, 2},     {90, 3}, 
        {90, 1},     {82, 3},     {5, 1},     {5, 1},     {5, 1}, 
        {83, 4},     {83, 1},     {84, 4},     {1, 4},     {1, 1}, 
        {2, 1},     {2, 3},     {44, 1},     {44, 1},     {44, 1}, 
        {3, 0}  };

  /** access to production table */
  public short[][] production_table() {return _production_table;}

  /** parse action table */
  protected static final short[][] _action_table = {
    /*0*/{0,-241,2,-2,8,-2,10,-2,13,-2,14,-2,22,-2,23,-2,25,-2,26,-2,33,-2,40,-2,45,-2,46,-2,48,-2,50,-2,-1,0},
    /*1*/{2,32,8,30,10,8,13,29,14,11,22,31,23,14,25,22,26,13,33,24,40,12,45,28,46,18,48,27,50,17,-1,0},
    /*2*/{0,5,-1,0},
    /*3*/{0,-4,-1,0},
    /*4*/{0,-1,-1,0},
    /*5*/{54,438,-1,0},
    /*6*/{54,437,-1,0},
    /*7*/{50,431,-1,0},
    /*8*/{54,430,-1,0},
    /*9*/{54,-123,-1,0},
    /*10*/{84,425,-1,0},
    /*11*/{84,416,-1,0},
    /*12*/{84,205,-1,0},
    /*13*/{22,409,-1,0},
    /*14*/{0,-6,2,32,8,30,10,8,13,29,14,11,22,31,23,14,25,22,26,13,33,24,40,12,45,28,46,18,48,27,50,17,65,-6,-1,0},
    /*15*/{54,-40,-1,0},
    /*16*/{84,372,-1,0},
    /*17*/{27,82,79,72,84,78,-1,0},
    /*18*/{54,367,-1,0},
    /*19*/{54,-42,-1,0},
    /*20*/{54,366,-1,0},
    /*21*/{84,362,-1,0},
    /*22*/{54,-124,-1,0},
    /*23*/{22,356,-1,0},
    /*24*/{54,355,-1,0},
    /*25*/{54,354,-1,0},
    /*26*/{84,327,-1,0},
    /*27*/{3,88,5,83,7,70,12,97,13,29,17,293,18,85,24,66,27,82,28,94,37,302,38,92,39,84,40,12,47,75,48,27,49,80,52,93,53,95,79,72,84,78,-1,0},
    /*28*/{84,281,-1,0},
    /*29*/{5,83,7,70,12,97,17,276,18,85,24,66,27,82,28,94,38,92,39,84,47,75,52,93,53,95,79,72,84,78,-1,0},
    /*30*/{84,263,-1,0},
    /*31*/{22,38,50,39,-1,0},
    /*32*/{54,-41,-1,0},
    /*33*/{54,-122,-1,0},
    /*34*/{54,-120,-1,0},
    /*35*/{54,-121,-1,0},
    /*36*/{0,-3,-1,0},
    /*37*/{84,252,-1,0},
    /*38*/{84,40,-1,0},
    /*39*/{41,43,54,-45,58,41,64,-241,-1,0},
    /*40*/{27,82,44,244,64,-56,79,72,84,78,-1,0},
    /*41*/{64,-57,-1,0},
    /*42*/{27,82,79,72,84,78,-1,0},
    /*43*/{64,45,-1,0},
    /*44*/{3,-241,4,48,5,-241,7,-241,8,30,12,-241,13,29,14,11,18,-241,24,-241,26,13,27,-241,28,-241,29,49,35,47,38,-241,39,-241,40,12,45,28,47,-241,48,27,49,-241,51,-241,52,-241,53,-241,65,-241,79,-241,84,-241,-1,0},
    /*45*/{54,242,-1,0},
    /*46*/{4,233,-1,0},
    /*47*/{3,88,5,83,7,70,12,97,18,85,24,66,27,82,28,94,38,92,39,84,47,75,49,80,52,93,53,95,79,72,84,78,-1,0},
    /*48*/{3,-218,5,-218,7,-218,12,-218,18,-218,24,-218,27,-218,28,-218,38,-218,39,-218,47,-218,49,-218,51,-218,52,-218,53,-218,79,-218,84,-218,-1,0},
    /*49*/{3,88,5,83,7,70,12,97,18,85,24,66,27,82,28,94,38,92,39,84,47,75,49,80,51,96,52,93,53,95,79,72,84,78,-1,0},
    /*50*/{54,63,-1,0},
    /*51*/{3,-219,5,-219,7,-219,12,-219,18,-219,24,-219,27,-219,28,-219,38,-219,39,-219,47,-219,49,-219,51,-219,52,-219,53,-219,65,-47,79,-219,84,-219,-1,0},
    /*52*/{54,62,-1,0},
    /*53*/{54,61,-1,0},
    /*54*/{54,60,-1,0},
    /*55*/{65,59,-1,0},
    /*56*/{3,-241,4,48,5,-241,7,-241,8,30,12,-241,13,29,14,11,18,-241,24,-241,26,13,27,-241,28,-241,29,49,35,47,38,-241,39,-241,40,12,45,28,47,-241,48,27,49,-241,51,-241,52,-241,53,-241,65,-241,79,-241,84,-241,-1,0},
    /*57*/{65,-46,-1,0},
    /*58*/{54,-44,-1,0},
    /*59*/{3,-28,4,-28,5,-28,7,-28,8,-28,12,-28,13,-28,14,-28,15,-28,18,-28,24,-28,26,-28,27,-28,28,-28,29,-28,31,-28,32,-28,35,-28,38,-28,39,-28,40,-28,45,-28,47,-28,48,-28,49,-28,51,-28,52,-28,53,-28,65,-28,79,-28,84,-28,-1,0},
    /*60*/{3,-30,4,-30,5,-30,7,-30,8,-30,12,-30,13,-30,14,-30,15,-30,18,-30,24,-30,26,-30,27,-30,28,-30,29,-30,31,-30,32,-30,35,-30,38,-30,39,-30,40,-30,45,-30,47,-30,48,-30,49,-30,51,-30,52,-30,53,-30,65,-30,79,-30,84,-30,-1,0},
    /*61*/{3,-27,4,-27,5,-27,7,-27,8,-27,12,-27,13,-27,14,-27,15,-27,18,-27,24,-27,26,-27,27,-27,28,-27,29,-27,31,-27,32,-27,35,-27,38,-27,39,-27,40,-27,45,-27,47,-27,48,-27,49,-27,51,-27,52,-27,53,-27,65,-27,79,-27,84,-27,-1,0},
    /*62*/{3,-29,4,-29,5,-29,7,-29,8,-29,12,-29,13,-29,14,-29,15,-29,18,-29,24,-29,26,-29,27,-29,28,-29,29,-29,31,-29,32,-29,35,-29,38,-29,39,-29,40,-29,45,-29,47,-29,48,-29,49,-29,51,-29,52,-29,53,-29,65,-29,79,-29,84,-29,-1,0},
    /*63*/{54,-136,55,-136,69,-136,84,-136,-1,0},
    /*64*/{84,-239,-1,0},
    /*65*/{12,209,24,173,54,-163,55,-163,69,-163,84,-163,-1,0},
    /*66*/{54,-134,55,-134,69,-134,84,-134,-1,0},
    /*67*/{79,164,84,-240,-1,0},
    /*68*/{84,175,-1,0},
    /*69*/{54,-165,55,-165,63,-165,69,-165,84,-165,-1,0},
    /*70*/{54,-160,55,-160,63,-160,69,-160,84,-160,-1,0},
    /*71*/{84,174,-1,0},
    /*72*/{84,-220,-1,0},
    /*73*/{84,-238,-1,0},
    /*74*/{24,169,38,92,-1,0},
    /*75*/{54,-133,55,-133,69,-133,84,-133,-1,0},
    /*76*/{54,-150,55,-150,69,-150,84,-150,-1,0},
    /*77*/{41,-36,54,-36,55,-36,56,-36,58,-36,60,-36,61,-36,63,-36,64,-36,67,-36,69,-36,71,-36,73,-36,74,-36,75,-36,76,-36,77,-36,79,-36,80,-36,81,-36,84,-36,-1,0},
    /*78*/{84,-221,-1,0},
    /*79*/{54,-138,55,-138,69,-138,84,-138,-1,0},
    /*80*/{54,-135,55,-135,69,-135,84,-135,-1,0},
    /*81*/{41,-39,54,-39,55,-39,56,-39,58,-39,60,-39,61,-39,63,-39,64,-39,67,-39,69,-39,71,-39,73,-39,74,-39,75,-39,76,-39,77,-39,79,-39,80,-39,81,-39,84,-39,-1,0},
    /*82*/{54,-167,55,-167,63,-167,69,-167,84,-167,-1,0},
    /*83*/{54,-198,55,-198,68,166,69,-198,84,-198,-1,0},
    /*84*/{54,-152,55,-152,69,-152,84,-152,-1,0},
    /*85*/{54,-137,55,-137,69,-137,84,-137,-1,0},
    /*86*/{54,-151,55,-151,69,-151,84,-151,-1,0},
    /*87*/{54,-169,55,-169,69,-169,84,-169,-1,0},
    /*88*/{54,-157,55,-157,63,-157,69,-157,84,-157,-1,0},
    /*89*/{54,-132,55,-132,69,-132,84,-132,-1,0},
    /*90*/{54,-156,55,-156,63,-156,69,-156,84,-156,-1,0},
    /*91*/{54,-162,55,-162,63,-162,69,-162,84,-162,-1,0},
    /*92*/{54,-166,55,-166,63,-166,69,-166,84,-166,-1,0},
    /*93*/{54,-168,55,-168,69,-168,84,-168,-1,0},
    /*94*/{54,-199,55,-199,68,98,69,-199,84,-199,-1,0},
    /*95*/{84,-222,-1,0},
    /*96*/{54,-154,55,-154,69,-154,84,-154,-1,0},
    /*97*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*98*/{54,-81,55,-81,58,-81,63,-81,67,-81,69,-81,73,-81,74,152,-1,0},
    /*99*/{54,-110,55,-110,56,-110,58,-110,60,-110,61,-110,63,-110,67,-110,69,-110,73,-110,74,-110,75,-110,76,-110,77,-110,80,-110,81,-110,-1,0},
    /*100*/{16,-100,27,-100,43,-100,62,-100,70,-100,71,-100,79,-100,82,-100,84,-100,86,-100,87,-100,88,-100,89,-100,-1,0},
    /*101*/{54,-109,55,-109,56,-109,58,-109,60,-109,61,-109,63,-109,67,-109,69,-109,73,-109,74,-109,75,-109,76,-109,77,-109,80,-109,81,-109,-1,0},
    /*102*/{54,-106,55,-106,56,-106,58,-106,60,-106,61,-106,63,-106,67,-106,69,-106,73,-106,74,-106,75,-106,76,-106,77,-106,80,-106,81,-106,-1,0},
    /*103*/{54,-102,55,-102,56,-102,58,-102,60,-102,61,-102,63,-102,67,-102,69,-102,73,-102,74,-102,75,-102,76,-102,77,-102,79,164,80,-102,81,-102,-1,0},
    /*104*/{71,158,84,159,-1,0},
    /*105*/{54,-111,55,-111,56,-111,58,-111,60,-111,61,-111,63,-111,67,-111,69,-111,73,-111,74,-111,75,-111,76,-111,77,-111,80,-111,81,-111,-1,0},
    /*106*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*107*/{16,-101,27,-101,43,-101,62,-101,70,-101,71,-101,79,-101,82,-101,84,-101,86,-101,87,-101,88,-101,89,-101,-1,0},
    /*108*/{54,-87,55,-87,58,-87,60,130,61,131,63,-87,67,-87,69,-87,73,-87,74,-87,75,-87,80,-87,81,-87,-1,0},
    /*109*/{54,-93,55,-93,56,-93,58,-93,60,-93,61,-93,63,-93,67,-93,69,-93,73,-93,74,-93,75,-93,76,-93,77,-93,80,-93,81,-93,-1,0},
    /*110*/{85,154,-1,0},
    /*111*/{54,-105,55,-105,56,-105,58,-105,60,-105,61,-105,63,-105,67,-105,69,-105,73,-105,74,-105,75,-105,76,-105,77,-105,80,-105,81,-105,-1,0},
    /*112*/{54,-80,55,-80,58,-80,63,-80,67,-80,69,-80,73,150,-1,0},
    /*113*/{69,149,-1,0},
    /*114*/{54,-98,55,-98,56,-98,58,-98,60,-98,61,-98,63,-98,67,-98,69,-98,73,-98,74,-98,75,-98,76,-98,77,-98,80,-98,81,-98,-1,0},
    /*115*/{16,-99,27,-99,43,-99,62,-99,70,-99,71,-99,79,-99,82,-99,84,-99,86,-99,87,-99,88,-99,89,-99,-1,0},
    /*116*/{54,-112,55,-112,56,-112,58,-112,60,-112,61,-112,63,-112,67,-112,69,-112,73,-112,74,-112,75,-112,76,-112,77,-112,80,-112,81,-112,-1,0},
    /*117*/{54,-103,55,-103,56,-103,58,-103,60,-103,61,-103,63,-103,67,-103,69,-103,73,-103,74,-103,75,-103,76,-103,77,-103,80,-103,81,-103,-1,0},
    /*118*/{54,-108,55,-108,56,-108,58,-108,60,-108,61,-108,63,-108,67,-108,69,-108,73,-108,74,-108,75,-108,76,-108,77,-108,80,-108,81,-108,-1,0},
    /*119*/{54,-83,55,-83,58,-83,63,-83,67,-83,69,-83,73,-83,74,-83,75,147,-1,0},
    /*120*/{54,-90,55,-90,56,133,58,-90,60,-90,61,-90,63,-90,67,-90,69,-90,73,-90,74,-90,75,-90,76,135,77,134,80,-90,81,-90,-1,0},
    /*121*/{71,141,84,142,-1,0},
    /*122*/{55,-119,67,-119,69,-119,-1,0},
    /*123*/{54,-85,55,-85,58,-85,63,-85,67,-85,69,-85,73,-85,74,-85,75,-85,80,128,81,127,-1,0},
    /*124*/{16,117,27,82,43,106,62,107,70,111,71,105,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*125*/{54,-97,55,-97,56,-97,58,-97,60,-97,61,-97,63,-97,67,-97,69,-97,73,-97,74,-97,75,-97,76,-97,77,-97,80,-97,81,-97,-1,0},
    /*126*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*127*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*128*/{54,-89,55,-89,58,-89,60,130,61,131,63,-89,67,-89,69,-89,73,-89,74,-89,75,-89,80,-89,81,-89,-1,0},
    /*129*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*130*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*131*/{54,-92,55,-92,56,133,58,-92,60,-92,61,-92,63,-92,67,-92,69,-92,73,-92,74,-92,75,-92,76,135,77,134,80,-92,81,-92,-1,0},
    /*132*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*133*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*134*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*135*/{54,-95,55,-95,56,-95,58,-95,60,-95,61,-95,63,-95,67,-95,69,-95,73,-95,74,-95,75,-95,76,-95,77,-95,80,-95,81,-95,-1,0},
    /*136*/{54,-96,55,-96,56,-96,58,-96,60,-96,61,-96,63,-96,67,-96,69,-96,73,-96,74,-96,75,-96,76,-96,77,-96,80,-96,81,-96,-1,0},
    /*137*/{54,-94,55,-94,56,-94,58,-94,60,-94,61,-94,63,-94,67,-94,69,-94,73,-94,74,-94,75,-94,76,-94,77,-94,80,-94,81,-94,-1,0},
    /*138*/{54,-91,55,-91,56,133,58,-91,60,-91,61,-91,63,-91,67,-91,69,-91,73,-91,74,-91,75,-91,76,135,77,134,80,-91,81,-91,-1,0},
    /*139*/{54,-88,55,-88,58,-88,60,130,61,131,63,-88,67,-88,69,-88,73,-88,74,-88,75,-88,80,-88,81,-88,-1,0},
    /*140*/{54,-118,55,-118,56,-118,58,-118,60,-118,61,-118,63,-118,67,-118,69,-118,73,-118,74,-118,75,-118,76,-118,77,-118,80,-118,81,-118,-1,0},
    /*141*/{71,143,-1,0},
    /*142*/{54,-116,55,-116,56,-116,58,-116,60,-116,61,-116,63,-116,67,-116,69,-116,73,-116,74,-116,75,-116,76,-116,77,-116,80,-116,81,-116,82,144,-1,0},
    /*143*/{84,145,-1,0},
    /*144*/{71,146,-1,0},
    /*145*/{54,-117,55,-117,56,-117,58,-117,60,-117,61,-117,63,-117,67,-117,69,-117,73,-117,74,-117,75,-117,76,-117,77,-117,80,-117,81,-117,-1,0},
    /*146*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*147*/{54,-86,55,-86,58,-86,63,-86,67,-86,69,-86,73,-86,74,-86,75,-86,80,128,81,127,-1,0},
    /*148*/{54,-197,55,-197,69,-197,84,-197,-1,0},
    /*149*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*150*/{54,-82,55,-82,58,-82,63,-82,67,-82,69,-82,73,-82,74,152,-1,0},
    /*151*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*152*/{54,-84,55,-84,58,-84,63,-84,67,-84,69,-84,73,-84,74,-84,75,147,-1,0},
    /*153*/{70,155,-1,0},
    /*154*/{54,-107,55,-107,56,-107,58,-107,60,-107,61,-107,63,-107,67,-107,69,-107,73,-107,74,-107,75,-107,76,-107,77,-107,80,-107,81,-107,-1,0},
    /*155*/{63,157,-1,0},
    /*156*/{54,-104,55,-104,56,-104,58,-104,60,-104,61,-104,63,-104,67,-104,69,-104,73,-104,74,-104,75,-104,76,-104,77,-104,80,-104,81,-104,-1,0},
    /*157*/{54,-115,55,-115,56,-115,58,-115,60,-115,61,-115,63,-115,67,-115,69,-115,73,-115,74,-115,75,-115,76,-115,77,-115,80,-115,81,-115,-1,0},
    /*158*/{71,160,-1,0},
    /*159*/{54,-113,55,-113,56,-113,58,-113,60,-113,61,-113,63,-113,67,-113,69,-113,71,161,73,-113,74,-113,75,-113,76,-113,77,-113,80,-113,81,-113,-1,0},
    /*160*/{84,162,-1,0},
    /*161*/{71,163,-1,0},
    /*162*/{54,-114,55,-114,56,-114,58,-114,60,-114,61,-114,63,-114,67,-114,69,-114,73,-114,74,-114,75,-114,76,-114,77,-114,80,-114,81,-114,-1,0},
    /*163*/{84,165,-1,0},
    /*164*/{41,-38,54,-38,55,-38,56,-38,58,-38,60,-38,61,-38,63,-38,64,-38,67,-38,69,-38,71,-38,73,-38,74,-38,75,-38,76,-38,77,-38,79,-38,80,-38,81,-38,84,-38,-1,0},
    /*165*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*166*/{69,168,-1,0},
    /*167*/{54,-196,55,-196,69,-196,84,-196,-1,0},
    /*168*/{24,173,54,-163,55,-163,63,-163,69,-163,84,-163,-1,0},
    /*169*/{54,-161,55,-161,63,-161,69,-161,84,-161,-1,0},
    /*170*/{54,-159,55,-159,63,-159,69,-159,84,-159,-1,0},
    /*171*/{54,-158,55,-158,63,-158,69,-158,84,-158,-1,0},
    /*172*/{54,-164,55,-164,63,-164,69,-164,84,-164,-1,0},
    /*173*/{41,-37,54,-37,55,-37,56,-37,58,-37,60,-37,61,-37,63,-37,64,-37,67,-37,69,-37,71,-37,73,-37,74,-37,75,-37,76,-37,77,-37,79,-37,80,-37,81,-37,84,-37,-1,0},
    /*174*/{62,176,-1,0},
    /*175*/{20,197,21,200,30,196,63,198,-1,0},
    /*176*/{9,-241,34,178,54,-241,-1,0},
    /*177*/{62,190,-1,0},
    /*178*/{9,183,54,-241,-1,0},
    /*179*/{9,-232,54,-232,-1,0},
    /*180*/{54,-217,-1,0},
    /*181*/{54,-235,-1,0},
    /*182*/{62,184,-1,0},
    /*183*/{71,105,82,122,-1,0},
    /*184*/{55,188,63,-236,-1,0},
    /*185*/{63,187,-1,0},
    /*186*/{54,-234,-1,0},
    /*187*/{71,105,82,122,-1,0},
    /*188*/{63,-237,-1,0},
    /*189*/{27,82,79,72,84,78,-1,0},
    /*190*/{41,-35,55,194,63,-35,64,-35,79,164,-1,0},
    /*191*/{63,193,-1,0},
    /*192*/{9,-231,54,-231,-1,0},
    /*193*/{27,82,79,72,84,78,-1,0},
    /*194*/{41,-34,63,-34,64,-34,-1,0},
    /*195*/{3,-229,5,-229,7,-229,12,-229,18,-229,24,-229,27,-229,28,-229,38,-229,39,-229,47,-229,49,-229,52,-229,53,-229,79,-229,84,-229,-1,0},
    /*196*/{3,-228,5,-228,7,-228,12,-228,18,-228,24,-228,27,-228,28,-228,38,-228,39,-228,47,-228,49,-228,52,-228,53,-228,79,-228,84,-228,-1,0},
    /*197*/{9,-224,34,-224,54,-224,-1,0},
    /*198*/{63,208,-1,0},
    /*199*/{3,-230,5,-230,7,-230,12,-230,18,-230,24,-230,27,-230,28,-230,38,-230,39,-230,47,-230,49,-230,52,-230,53,-230,79,-230,84,-230,-1,0},
    /*200*/{55,206,63,-226,-1,0},
    /*201*/{3,88,5,83,7,70,12,97,18,85,24,66,27,82,28,94,38,92,39,84,47,75,49,80,52,93,53,95,79,72,84,78,-1,0},
    /*202*/{84,205,-1,0},
    /*203*/{55,-227,63,-227,-1,0},
    /*204*/{19,-149,34,-149,36,-149,54,-149,55,-149,63,-149,-1,0},
    /*205*/{20,197,21,200,30,196,-1,0},
    /*206*/{63,-225,-1,0},
    /*207*/{9,-223,34,-223,54,-223,-1,0},
    /*208*/{54,-155,55,-155,69,-155,84,-155,-1,0},
    /*209*/{84,205,-1,0},
    /*210*/{19,214,36,216,54,-213,55,213,-1,0},
    /*211*/{54,-207,-1,0},
    /*212*/{84,205,-1,0},
    /*213*/{62,224,-1,0},
    /*214*/{54,-208,-1,0},
    /*215*/{62,217,-1,0},
    /*216*/{27,82,79,72,84,78,-1,0},
    /*217*/{63,219,-1,0},
    /*218*/{19,220,54,-212,-1,0},
    /*219*/{62,221,-1,0},
    /*220*/{27,82,79,72,84,78,-1,0},
    /*221*/{63,223,-1,0},
    /*222*/{54,-210,-1,0},
    /*223*/{27,82,79,72,84,78,-1,0},
    /*224*/{63,226,-1,0},
    /*225*/{36,227,54,-211,-1,0},
    /*226*/{62,228,-1,0},
    /*227*/{27,82,79,72,84,78,-1,0},
    /*228*/{63,230,-1,0},
    /*229*/{54,-209,-1,0},
    /*230*/{54,-213,55,213,-1,0},
    /*231*/{54,-214,-1,0},
    /*232*/{3,88,5,83,7,70,12,97,18,85,24,66,27,82,28,94,38,92,39,84,47,75,49,80,52,93,53,95,79,72,84,78,-1,0},
    /*233*/{84,205,-1,0},
    /*234*/{34,237,54,-213,55,213,-1,0},
    /*235*/{54,-205,-1,0},
    /*236*/{62,239,-1,0},
    /*237*/{54,-206,-1,0},
    /*238*/{27,82,79,72,84,78,-1,0},
    /*239*/{63,241,-1,0},
    /*240*/{54,-233,-1,0},
    /*241*/{3,-26,4,-26,5,-26,7,-26,8,-26,12,-26,13,-26,14,-26,15,-26,18,-26,24,-26,26,-26,27,-26,28,-26,29,-26,31,-26,32,-26,35,-26,38,-26,39,-26,40,-26,45,-26,47,-26,48,-26,49,-26,51,-26,52,-26,53,-26,65,-26,79,-26,84,-26,-1,0},
    /*242*/{64,-53,-1,0},
    /*243*/{27,-58,79,-58,84,-58,-1,0},
    /*244*/{27,82,79,72,84,78,-1,0},
    /*245*/{41,247,64,-52,-1,0},
    /*246*/{27,82,79,72,84,78,-1,0},
    /*247*/{64,-55,-1,0},
    /*248*/{41,250,64,-51,-1,0},
    /*249*/{27,82,79,72,84,78,-1,0},
    /*250*/{64,-54,-1,0},
    /*251*/{54,-21,58,254,64,-241,-1,0},
    /*252*/{64,257,-1,0},
    /*253*/{27,82,64,-32,79,72,84,78,-1,0},
    /*254*/{64,-33,-1,0},
    /*255*/{64,-31,-1,0},
    /*256*/{3,-241,4,48,5,-241,7,-241,8,30,12,-241,13,29,14,11,18,-241,24,-241,26,13,27,-241,28,-241,29,49,35,47,38,-241,39,-241,40,12,45,28,47,-241,48,27,49,-241,51,-241,52,-241,53,-241,65,-241,79,-241,84,-241,-1,0},
    /*257*/{65,262,-1,0},
    /*258*/{3,-219,5,-219,7,-219,12,-219,18,-219,24,-219,27,-219,28,-219,38,-219,39,-219,47,-219,49,-219,51,-219,52,-219,53,-219,65,-25,79,-219,84,-219,-1,0},
    /*259*/{3,-241,4,48,5,-241,7,-241,8,30,12,-241,13,29,14,11,18,-241,24,-241,26,13,27,-241,28,-241,29,49,35,47,38,-241,39,-241,40,12,45,28,47,-241,48,27,49,-241,51,-241,52,-241,53,-241,65,-241,79,-241,84,-241,-1,0},
    /*260*/{65,-24,-1,0},
    /*261*/{54,-17,-1,0},
    /*262*/{54,-20,58,254,64,-241,-1,0},
    /*263*/{64,265,-1,0},
    /*264*/{3,-241,4,48,5,-241,7,-241,8,30,12,-241,13,29,14,11,18,-241,24,-241,26,13,27,-241,28,-241,29,49,35,47,38,-241,39,-241,40,12,45,28,47,-241,48,27,49,-241,51,-241,52,-241,53,-241,65,-241,79,-241,84,-241,-1,0},
    /*265*/{65,267,-1,0},
    /*266*/{54,-16,-1,0},
    /*267*/{84,-78,-1,0},
    /*268*/{84,-77,-1,0},
    /*269*/{84,-73,-1,0},
    /*270*/{79,164,84,-79,-1,0},
    /*271*/{84,-72,-1,0},
    /*272*/{84,-76,-1,0},
    /*273*/{84,-74,-1,0},
    /*274*/{84,-75,-1,0},
    /*275*/{84,-153,-1,0},
    /*276*/{84,278,-1,0},
    /*277*/{59,279,-1,0},
    /*278*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*279*/{54,-71,-1,0},
    /*280*/{64,282,-1,0},
    /*281*/{84,283,-1,0},
    /*282*/{55,286,65,-191,-1,0},
    /*283*/{65,285,-1,0},
    /*284*/{54,-190,63,-190,84,-190,-1,0},
    /*285*/{84,283,-1,0},
    /*286*/{65,-192,-1,0},
    /*287*/{54,-142,84,-142,-1,0},
    /*288*/{54,-144,84,-144,-1,0},
    /*289*/{54,-125,-1,0},
    /*290*/{54,-127,84,-127,-1,0},
    /*291*/{54,-130,55,-130,69,-130,84,-130,-1,0},
    /*292*/{68,322,-1,0},
    /*293*/{54,-128,84,-128,-1,0},
    /*294*/{54,-143,84,-143,-1,0},
    /*295*/{54,-131,55,-131,69,-131,79,164,84,-131,-1,0},
    /*296*/{54,-140,55,-140,69,-140,84,-140,-1,0},
    /*297*/{84,310,-1,0},
    /*298*/{54,-139,55,-139,69,-139,84,-139,-1,0},
    /*299*/{54,-129,55,-129,69,-129,84,-129,-1,0},
    /*300*/{54,-141,55,-141,69,-141,84,-141,-1,0},
    /*301*/{68,303,-1,0},
    /*302*/{3,88,5,83,7,70,12,97,17,293,18,85,24,66,27,82,28,94,37,302,38,92,39,84,47,75,49,80,52,93,53,95,79,72,84,78,-1,0},
    /*303*/{55,305,69,306,-1,0},
    /*304*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*305*/{54,-195,55,-195,69,-195,84,-195,-1,0},
    /*306*/{69,308,-1,0},
    /*307*/{54,-194,55,-194,69,-194,84,-194,-1,0},
    /*308*/{54,-147,55,-147,-1,0},
    /*309*/{54,-149,55,-149,66,318,-1,0},
    /*310*/{54,-146,55,314,-1,0},
    /*311*/{54,-148,55,-148,-1,0},
    /*312*/{54,-126,-1,0},
    /*313*/{84,310,-1,0},
    /*314*/{54,-145,-1,0},
    /*315*/{54,-202,55,-202,66,318,-1,0},
    /*316*/{54,-201,55,-201,-1,0},
    /*317*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*318*/{67,320,-1,0},
    /*319*/{54,-204,55,-204,66,-204,-1,0},
    /*320*/{54,-203,55,-203,-1,0},
    /*321*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*322*/{55,324,-1,0},
    /*323*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*324*/{69,326,-1,0},
    /*325*/{54,-200,55,-200,69,-200,84,-200,-1,0},
    /*326*/{42,328,54,-176,84,-176,-1,0},
    /*327*/{62,329,-1,0},
    /*328*/{5,83,7,70,13,29,24,169,27,82,38,92,47,75,52,93,79,72,84,78,-1,0},
    /*329*/{63,-180,-1,0},
    /*330*/{63,-178,-1,0},
    /*331*/{63,336,-1,0},
    /*332*/{63,-181,79,164,-1,0},
    /*333*/{63,-177,-1,0},
    /*334*/{63,-179,-1,0},
    /*335*/{64,337,-1,0},
    /*336*/{6,342,11,338,-1,0},
    /*337*/{58,352,-1,0},
    /*338*/{65,351,-1,0},
    /*339*/{6,342,11,338,65,-182,-1,0},
    /*340*/{3,88,5,83,7,70,12,97,13,29,17,293,18,85,24,66,27,82,28,94,37,302,38,92,39,84,40,12,47,75,48,27,49,80,52,93,53,95,79,72,84,78,-1,0},
    /*341*/{16,117,27,82,43,106,60,101,61,116,62,107,70,111,71,105,78,108,79,72,82,122,84,78,86,112,87,103,88,100,89,102,-1,0},
    /*342*/{58,344,-1,0},
    /*343*/{3,-185,5,-185,6,342,7,-185,11,338,12,-185,13,-185,17,-185,18,-185,24,-185,27,-185,28,-185,37,-185,38,-185,39,-185,40,-185,47,-185,48,-185,49,-185,52,-185,53,-185,79,-185,84,-185,-1,0},
    /*344*/{3,-187,5,-187,7,-187,12,-187,13,-187,17,-187,18,-187,24,-187,27,-187,28,-187,37,-187,38,-187,39,-187,40,-187,47,-187,48,-187,49,-187,52,-187,53,-187,79,-187,84,-187,-1,0},
    /*345*/{54,349,-1,0},
    /*346*/{84,310,-1,0},
    /*347*/{54,-189,-1,0},
    /*348*/{6,-184,11,-184,65,-184,-1,0},
    /*349*/{65,-183,-1,0},
    /*350*/{54,-175,84,-175,-1,0},
    /*351*/{3,-186,5,-186,6,342,7,-186,11,338,12,-186,13,-186,17,-186,18,-186,24,-186,27,-186,28,-186,37,-186,38,-186,39,-186,40,-186,47,-186,48,-186,49,-186,52,-186,53,-186,79,-186,84,-186,-1,0},
    /*352*/{3,-188,5,-188,7,-188,12,-188,13,-188,17,-188,18,-188,24,-188,27,-188,28,-188,37,-188,38,-188,39,-188,40,-188,47,-188,48,-188,49,-188,52,-188,53,-188,79,-188,84,-188,-1,0},
    /*353*/{0,-13,2,-13,8,-13,10,-13,13,-13,14,-13,22,-13,23,-13,25,-13,26,-13,33,-13,40,-13,45,-13,46,-13,48,-13,50,-13,65,-13,-1,0},
    /*354*/{0,-9,2,-9,8,-9,10,-9,13,-9,14,-9,22,-9,23,-9,25,-9,26,-9,33,-9,40,-9,45,-9,46,-9,48,-9,50,-9,65,-9,-1,0},
    /*355*/{84,357,-1,0},
    /*356*/{54,-23,58,254,64,-241,-1,0},
    /*357*/{64,359,-1,0},
    /*358*/{3,-241,4,48,5,-241,7,-241,8,30,12,-241,13,29,14,11,18,-241,24,-241,26,13,27,-241,28,-241,29,49,35,47,38,-241,39,-241,40,12,45,28,47,-241,48,27,49,-241,51,-241,52,-241,53,-241,65,-241,79,-241,84,-241,-1,0},
    /*359*/{65,361,-1,0},
    /*360*/{54,-19,-1,0},
    /*361*/{64,363,-1,0},
    /*362*/{2,32,8,30,10,8,13,29,14,11,22,31,23,14,25,22,26,13,33,24,40,12,45,28,46,18,48,27,50,17,-1,0},
    /*363*/{65,365,-1,0},
    /*364*/{54,-14,-1,0},
    /*365*/{0,-8,2,-8,8,-8,10,-8,13,-8,14,-8,22,-8,23,-8,25,-8,26,-8,33,-8,40,-8,45,-8,46,-8,48,-8,50,-8,65,-8,-1,0},
    /*366*/{0,-12,2,-12,8,-12,10,-12,13,-12,14,-12,22,-12,23,-12,25,-12,26,-12,33,-12,40,-12,45,-12,46,-12,48,-12,50,-12,65,-12,-1,0},
    /*367*/{71,369,79,164,-1,0},
    /*368*/{84,370,-1,0},
    /*369*/{71,371,-1,0},
    /*370*/{54,-15,-1,0},
    /*371*/{3,88,5,83,7,70,12,97,13,29,17,293,18,85,24,66,27,82,28,94,37,302,38,92,39,84,40,12,41,43,47,75,48,27,49,80,52,93,53,95,54,-49,58,41,64,-241,79,72,84,78,-1,0},
    /*372*/{64,375,-1,0},
    /*373*/{54,-43,-1,0},
    /*374*/{3,-241,4,48,5,-241,7,-241,8,30,12,-241,13,29,14,11,15,382,18,-241,24,-241,26,13,27,-241,28,-241,29,49,31,376,32,378,35,47,38,-241,39,-241,40,12,45,28,47,-241,48,27,49,-241,51,-241,52,-241,53,-241,65,-241,79,-241,84,-241,-1,0},
    /*375*/{3,88,5,83,7,70,12,97,13,29,17,293,18,85,24,66,27,82,28,94,37,302,38,92,39,84,40,12,47,75,48,27,49,80,52,93,53,95,79,72,84,78,-1,0},
    /*376*/{3,-62,4,-62,5,-62,7,-62,8,-62,12,-62,13,-62,14,-62,15,-62,18,-62,24,-62,26,-62,27,-62,28,-62,29,-62,31,-62,32,-62,35,-62,38,-62,39,-62,40,-62,45,-62,47,-62,48,-62,49,-62,51,-62,52,-62,53,-62,65,-62,79,-62,84,-62,-1,0},
    /*377*/{3,88,5,83,7,70,12,97,13,29,17,293,18,85,24,66,27,82,28,94,37,302,38,92,39,84,40,12,47,75,48,27,49,80,52,93,53,95,79,72,84,78,-1,0},
    /*378*/{3,-219,5,-219,7,-219,12,-219,18,-219,24,-219,27,-219,28,-219,38,-219,39,-219,47,-219,49,-219,51,-219,52,-219,53,-219,65,-60,79,-219,84,-219,-1,0},
    /*379*/{3,-63,4,-63,5,-63,7,-63,8,-63,12,-63,13,-63,14,-63,15,-63,18,-63,24,-63,26,-63,27,-63,28,-63,29,-63,31,-63,32,-63,35,-63,38,-63,39,-63,40,-63,45,-63,47,-63,48,-63,49,-63,51,-63,52,-63,53,-63,65,-63,79,-63,84,-63,-1,0},
    /*380*/{3,-61,4,-61,5,-61,7,-61,8,-61,12,-61,13,-61,14,-61,15,-61,18,-61,24,-61,26,-61,27,-61,28,-61,29,-61,31,-61,32,-61,35,-61,38,-61,39,-61,40,-61,45,-61,47,-61,48,-61,49,-61,51,-61,52,-61,53,-61,65,-61,79,-61,84,-61,-1,0},
    /*381*/{84,387,-1,0},
    /*382*/{65,386,-1,0},
    /*383*/{3,-241,4,48,5,-241,7,-241,8,30,12,-241,13,29,14,11,15,382,18,-241,24,-241,26,13,27,-241,28,-241,29,49,31,376,32,378,35,47,38,-241,39,-241,40,12,45,28,47,-241,48,27,49,-241,51,-241,52,-241,53,-241,65,-241,79,-241,84,-241,-1,0},
    /*384*/{65,-59,-1,0},
    /*385*/{54,-50,-1,0},
    /*386*/{62,388,-1,0},
    /*387*/{20,389,63,390,-1,0},
    /*388*/{3,88,5,83,7,70,12,97,18,85,24,66,27,82,28,94,38,92,39,84,47,75,49,80,52,93,53,95,79,72,84,78,-1,0},
    /*389*/{34,178,54,-241,-1,0},
    /*390*/{63,395,-1,0},
    /*391*/{55,393,63,-68,-1,0},
    /*392*/{20,389,-1,0},
    /*393*/{63,-69,-1,0},
    /*394*/{34,178,54,-241,-1,0},
    /*395*/{54,397,-1,0},
    /*396*/{3,-66,4,-66,5,-66,7,-66,8,-66,12,-66,13,-66,14,-66,15,-66,18,-66,24,-66,26,-66,27,-66,28,-66,29,-66,31,-66,32,-66,35,-66,38,-66,39,-66,40,-66,45,-66,47,-66,48,-66,49,-66,51,-66,52,-66,53,-66,65,-66,79,-66,84,-66,-1,0},
    /*397*/{54,399,-1,0},
    /*398*/{3,-67,4,-67,5,-67,7,-67,8,-67,12,-67,13,-67,14,-67,15,-67,18,-67,24,-67,26,-67,27,-67,28,-67,29,-67,31,-67,32,-67,35,-67,38,-67,39,-67,40,-67,45,-67,47,-67,48,-67,49,-67,51,-67,52,-67,53,-67,65,-67,79,-67,84,-67,-1,0},
    /*399*/{84,205,-1,0},
    /*400*/{55,-70,63,-70,-1,0},
    /*401*/{84,310,-1,0},
    /*402*/{54,404,-1,0},
    /*403*/{3,-64,4,-64,5,-64,7,-64,8,-64,12,-64,13,-64,14,-64,15,-64,18,-64,24,-64,26,-64,27,-64,28,-64,29,-64,31,-64,32,-64,35,-64,38,-64,39,-64,40,-64,45,-64,47,-64,48,-64,49,-64,51,-64,52,-64,53,-64,65,-64,79,-64,84,-64,-1,0},
    /*404*/{84,310,-1,0},
    /*405*/{54,407,-1,0},
    /*406*/{3,-65,4,-65,5,-65,7,-65,8,-65,12,-65,13,-65,14,-65,15,-65,18,-65,24,-65,26,-65,27,-65,28,-65,29,-65,31,-65,32,-65,35,-65,38,-65,39,-65,40,-65,45,-65,47,-65,48,-65,49,-65,51,-65,52,-65,53,-65,65,-65,79,-65,84,-65,-1,0},
    /*407*/{0,-5,65,-5,-1,0},
    /*408*/{84,410,-1,0},
    /*409*/{54,-22,58,254,64,-241,-1,0},
    /*410*/{64,412,-1,0},
    /*411*/{3,-241,4,48,5,-241,7,-241,8,30,12,-241,13,29,14,11,18,-241,24,-241,26,13,27,-241,28,-241,29,49,35,47,38,-241,39,-241,40,12,45,28,47,-241,48,27,49,-241,51,-241,52,-241,53,-241,65,-241,79,-241,84,-241,-1,0},
    /*412*/{65,414,-1,0},
    /*413*/{54,-18,-1,0},
    /*414*/{54,-193,-1,0},
    /*415*/{54,-171,64,417,84,-171,-1,0},
    /*416*/{3,88,5,83,7,70,12,97,13,29,17,293,18,85,24,66,27,82,28,94,37,302,38,92,39,84,40,12,47,75,48,27,49,80,52,93,53,95,79,72,84,78,-1,0},
    /*417*/{65,424,-1,0},
    /*418*/{84,310,-1,0},
    /*419*/{3,88,5,83,7,70,12,97,13,29,17,293,18,85,24,66,27,82,28,94,37,302,38,92,39,84,40,12,47,75,48,27,49,80,52,93,53,95,65,-172,79,72,84,78,-1,0},
    /*420*/{65,-173,-1,0},
    /*421*/{54,423,-1,0},
    /*422*/{3,-174,5,-174,7,-174,12,-174,13,-174,17,-174,18,-174,24,-174,27,-174,28,-174,37,-174,38,-174,39,-174,40,-174,47,-174,48,-174,49,-174,52,-174,53,-174,65,-174,79,-174,84,-174,-1,0},
    /*423*/{54,-170,84,-170,-1,0},
    /*424*/{64,426,-1,0},
    /*425*/{3,88,5,83,7,70,12,97,13,29,17,293,18,85,24,66,27,82,28,94,37,302,38,92,39,84,40,12,47,75,48,27,49,80,52,93,53,95,65,428,79,72,84,78,-1,0},
    /*426*/{65,429,-1,0},
    /*427*/{54,-215,-1,0},
    /*428*/{54,-216,-1,0},
    /*429*/{0,-11,2,-11,8,-11,10,-11,13,-11,14,-11,22,-11,23,-11,25,-11,26,-11,33,-11,40,-11,45,-11,46,-11,48,-11,50,-11,65,-11,-1,0},
    /*430*/{84,432,-1,0},
    /*431*/{41,43,58,41,64,-241,-1,0},
    /*432*/{64,434,-1,0},
    /*433*/{3,-241,4,48,5,-241,7,-241,8,30,12,-241,13,29,14,11,15,382,18,-241,24,-241,26,13,27,-241,28,-241,29,49,31,376,32,378,35,47,38,-241,39,-241,40,12,45,28,47,-241,48,27,49,-241,51,-241,52,-241,53,-241,65,-241,79,-241,84,-241,-1,0},
    /*434*/{65,436,-1,0},
    /*435*/{54,-48,-1,0},
    /*436*/{0,-7,2,-7,8,-7,10,-7,13,-7,14,-7,22,-7,23,-7,25,-7,26,-7,33,-7,40,-7,45,-7,46,-7,48,-7,50,-7,65,-7,-1,0},
    /*437*/{0,-10,2,-10,8,-10,10,-10,13,-10,14,-10,22,-10,23,-10,25,-10,26,-10,33,-10,40,-10,45,-10,46,-10,48,-10,50,-10,65,-10,-1,0},
  };

  /** access to parse action table */
  public short[][] action_table() {return _action_table;}

  /** reduce_goto table */
  protected static final short[][] _reduce_table = {
    /*0*/{3,3,7,2,99,1,-1,-1},
    /*1*/{8,14,9,36,10,8,11,18,12,5,17,25,18,19,19,15,20,32,28,20,40,6,46,34,50,9,51,35,52,24,53,33,54,22,-1,-1},
    /*2*/{-1,-1},
    /*3*/{-1,-1},
    /*4*/{-1,-1},
    /*5*/{-1,-1},
    /*6*/{-1,-1},
    /*7*/{-1,-1},
    /*8*/{-1,-1},
    /*9*/{-1,-1},
    /*10*/{-1,-1},
    /*11*/{-1,-1},
    /*12*/{79,414,-1,-1},
    /*13*/{-1,-1},
    /*14*/{8,14,9,407,10,8,11,18,12,5,17,25,18,19,19,15,20,32,28,20,40,6,46,34,50,9,51,35,52,24,53,33,54,22,-1,-1},
    /*15*/{-1,-1},
    /*16*/{-1,-1},
    /*17*/{15,367,-1,-1},
    /*18*/{-1,-1},
    /*19*/{-1,-1},
    /*20*/{-1,-1},
    /*21*/{-1,-1},
    /*22*/{-1,-1},
    /*23*/{-1,-1},
    /*24*/{-1,-1},
    /*25*/{-1,-1},
    /*26*/{-1,-1},
    /*27*/{15,295,41,289,42,297,47,290,48,291,49,293,50,288,51,287,53,294,58,299,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,296,73,298,74,300,-1,-1},
    /*28*/{-1,-1},
    /*29*/{15,270,29,276,59,271,60,274,61,76,62,272,63,86,64,70,65,90,66,88,67,269,68,273,69,267,72,268,-1,-1},
    /*30*/{-1,-1},
    /*31*/{-1,-1},
    /*32*/{-1,-1},
    /*33*/{-1,-1},
    /*34*/{-1,-1},
    /*35*/{-1,-1},
    /*36*/{-1,-1},
    /*37*/{-1,-1},
    /*38*/{-1,-1},
    /*39*/{3,41,22,43,-1,-1},
    /*40*/{15,190,16,244,93,245,-1,-1},
    /*41*/{-1,-1},
    /*42*/{15,190,93,242,-1,-1},
    /*43*/{-1,-1},
    /*44*/{3,51,4,49,14,56,21,55,28,52,40,45,46,34,50,9,51,35,52,54,53,33,54,22,85,53,86,50,-1,-1},
    /*45*/{-1,-1},
    /*46*/{-1,-1},
    /*47*/{15,67,44,209,58,73,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,64,-1,-1},
    /*48*/{-1,-1},
    /*49*/{15,67,43,68,44,72,58,73,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,71,78,72,64,-1,-1},
    /*50*/{-1,-1},
    /*51*/{-1,-1},
    /*52*/{-1,-1},
    /*53*/{-1,-1},
    /*54*/{-1,-1},
    /*55*/{-1,-1},
    /*56*/{3,51,4,49,14,56,21,57,28,52,40,45,46,34,50,9,51,35,52,54,53,33,54,22,85,53,86,50,-1,-1},
    /*57*/{-1,-1},
    /*58*/{-1,-1},
    /*59*/{-1,-1},
    /*60*/{-1,-1},
    /*61*/{-1,-1},
    /*62*/{-1,-1},
    /*63*/{-1,-1},
    /*64*/{-1,-1},
    /*65*/{-1,-1},
    /*66*/{-1,-1},
    /*67*/{-1,-1},
    /*68*/{-1,-1},
    /*69*/{-1,-1},
    /*70*/{-1,-1},
    /*71*/{-1,-1},
    /*72*/{-1,-1},
    /*73*/{-1,-1},
    /*74*/{64,169,65,171,66,170,-1,-1},
    /*75*/{-1,-1},
    /*76*/{-1,-1},
    /*77*/{-1,-1},
    /*78*/{-1,-1},
    /*79*/{-1,-1},
    /*80*/{-1,-1},
    /*81*/{-1,-1},
    /*82*/{-1,-1},
    /*83*/{-1,-1},
    /*84*/{-1,-1},
    /*85*/{-1,-1},
    /*86*/{-1,-1},
    /*87*/{-1,-1},
    /*88*/{-1,-1},
    /*89*/{-1,-1},
    /*90*/{-1,-1},
    /*91*/{-1,-1},
    /*92*/{-1,-1},
    /*93*/{-1,-1},
    /*94*/{-1,-1},
    /*95*/{-1,-1},
    /*96*/{-1,-1},
    /*97*/{6,124,15,103,30,122,31,113,32,112,33,98,34,119,35,123,36,108,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*98*/{-1,-1},
    /*99*/{-1,-1},
    /*100*/{-1,-1},
    /*101*/{-1,-1},
    /*102*/{-1,-1},
    /*103*/{-1,-1},
    /*104*/{-1,-1},
    /*105*/{-1,-1},
    /*106*/{6,124,15,103,30,155,32,112,33,98,34,119,35,123,36,108,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*107*/{-1,-1},
    /*108*/{-1,-1},
    /*109*/{-1,-1},
    /*110*/{-1,-1},
    /*111*/{-1,-1},
    /*112*/{-1,-1},
    /*113*/{-1,-1},
    /*114*/{-1,-1},
    /*115*/{-1,-1},
    /*116*/{-1,-1},
    /*117*/{-1,-1},
    /*118*/{-1,-1},
    /*119*/{-1,-1},
    /*120*/{-1,-1},
    /*121*/{-1,-1},
    /*122*/{-1,-1},
    /*123*/{-1,-1},
    /*124*/{15,103,39,125,75,117,76,118,-1,-1},
    /*125*/{-1,-1},
    /*126*/{6,124,15,103,36,139,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*127*/{6,124,15,103,36,128,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*128*/{-1,-1},
    /*129*/{6,124,15,103,37,138,38,109,39,114,75,117,76,118,-1,-1},
    /*130*/{6,124,15,103,37,131,38,109,39,114,75,117,76,118,-1,-1},
    /*131*/{-1,-1},
    /*132*/{6,124,15,103,38,137,39,114,75,117,76,118,-1,-1},
    /*133*/{6,124,15,103,38,136,39,114,75,117,76,118,-1,-1},
    /*134*/{6,124,15,103,38,135,39,114,75,117,76,118,-1,-1},
    /*135*/{-1,-1},
    /*136*/{-1,-1},
    /*137*/{-1,-1},
    /*138*/{-1,-1},
    /*139*/{-1,-1},
    /*140*/{-1,-1},
    /*141*/{-1,-1},
    /*142*/{-1,-1},
    /*143*/{-1,-1},
    /*144*/{-1,-1},
    /*145*/{-1,-1},
    /*146*/{6,124,15,103,35,147,36,108,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*147*/{-1,-1},
    /*148*/{-1,-1},
    /*149*/{6,124,15,103,33,150,34,119,35,123,36,108,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*150*/{-1,-1},
    /*151*/{6,124,15,103,34,152,35,123,36,108,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*152*/{-1,-1},
    /*153*/{-1,-1},
    /*154*/{-1,-1},
    /*155*/{-1,-1},
    /*156*/{-1,-1},
    /*157*/{-1,-1},
    /*158*/{-1,-1},
    /*159*/{-1,-1},
    /*160*/{-1,-1},
    /*161*/{-1,-1},
    /*162*/{-1,-1},
    /*163*/{-1,-1},
    /*164*/{-1,-1},
    /*165*/{6,124,15,103,30,122,31,166,32,112,33,98,34,119,35,123,36,108,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*166*/{-1,-1},
    /*167*/{-1,-1},
    /*168*/{-1,-1},
    /*169*/{-1,-1},
    /*170*/{-1,-1},
    /*171*/{-1,-1},
    /*172*/{-1,-1},
    /*173*/{-1,-1},
    /*174*/{92,176,-1,-1},
    /*175*/{5,201,82,200,90,198,-1,-1},
    /*176*/{3,179,83,178,-1,-1},
    /*177*/{-1,-1},
    /*178*/{1,180,3,181,-1,-1},
    /*179*/{-1,-1},
    /*180*/{-1,-1},
    /*181*/{-1,-1},
    /*182*/{-1,-1},
    /*183*/{2,185,76,184,-1,-1},
    /*184*/{-1,-1},
    /*185*/{-1,-1},
    /*186*/{-1,-1},
    /*187*/{2,188,76,184,-1,-1},
    /*188*/{-1,-1},
    /*189*/{15,190,93,191,-1,-1},
    /*190*/{-1,-1},
    /*191*/{-1,-1},
    /*192*/{-1,-1},
    /*193*/{15,190,93,194,-1,-1},
    /*194*/{-1,-1},
    /*195*/{-1,-1},
    /*196*/{-1,-1},
    /*197*/{-1,-1},
    /*198*/{-1,-1},
    /*199*/{-1,-1},
    /*200*/{-1,-1},
    /*201*/{15,67,44,202,58,73,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,64,-1,-1},
    /*202*/{79,203,-1,-1},
    /*203*/{-1,-1},
    /*204*/{-1,-1},
    /*205*/{5,201,82,200,90,206,-1,-1},
    /*206*/{-1,-1},
    /*207*/{-1,-1},
    /*208*/{-1,-1},
    /*209*/{79,210,94,211,-1,-1},
    /*210*/{87,214,-1,-1},
    /*211*/{-1,-1},
    /*212*/{79,230,94,231,-1,-1},
    /*213*/{-1,-1},
    /*214*/{-1,-1},
    /*215*/{-1,-1},
    /*216*/{15,190,93,217,-1,-1},
    /*217*/{-1,-1},
    /*218*/{-1,-1},
    /*219*/{-1,-1},
    /*220*/{15,190,93,221,-1,-1},
    /*221*/{-1,-1},
    /*222*/{-1,-1},
    /*223*/{15,190,93,224,-1,-1},
    /*224*/{-1,-1},
    /*225*/{-1,-1},
    /*226*/{-1,-1},
    /*227*/{15,190,93,228,-1,-1},
    /*228*/{-1,-1},
    /*229*/{-1,-1},
    /*230*/{-1,-1},
    /*231*/{-1,-1},
    /*232*/{15,67,44,233,58,73,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,64,-1,-1},
    /*233*/{79,234,94,235,-1,-1},
    /*234*/{84,237,-1,-1},
    /*235*/{-1,-1},
    /*236*/{-1,-1},
    /*237*/{-1,-1},
    /*238*/{15,190,93,239,-1,-1},
    /*239*/{-1,-1},
    /*240*/{-1,-1},
    /*241*/{-1,-1},
    /*242*/{-1,-1},
    /*243*/{-1,-1},
    /*244*/{15,190,93,248,-1,-1},
    /*245*/{-1,-1},
    /*246*/{15,190,93,247,-1,-1},
    /*247*/{-1,-1},
    /*248*/{-1,-1},
    /*249*/{15,190,93,250,-1,-1},
    /*250*/{-1,-1},
    /*251*/{3,254,96,252,-1,-1},
    /*252*/{-1,-1},
    /*253*/{15,190,93,255,-1,-1},
    /*254*/{-1,-1},
    /*255*/{-1,-1},
    /*256*/{3,258,4,49,13,257,14,259,28,52,40,45,46,34,50,9,51,35,52,54,53,33,54,22,85,53,86,50,-1,-1},
    /*257*/{-1,-1},
    /*258*/{-1,-1},
    /*259*/{3,258,4,49,13,260,14,259,28,52,40,45,46,34,50,9,51,35,52,54,53,33,54,22,85,53,86,50,-1,-1},
    /*260*/{-1,-1},
    /*261*/{-1,-1},
    /*262*/{3,254,96,263,-1,-1},
    /*263*/{-1,-1},
    /*264*/{3,258,4,49,13,265,14,259,28,52,40,45,46,34,50,9,51,35,52,54,53,33,54,22,85,53,86,50,-1,-1},
    /*265*/{-1,-1},
    /*266*/{-1,-1},
    /*267*/{-1,-1},
    /*268*/{-1,-1},
    /*269*/{-1,-1},
    /*270*/{-1,-1},
    /*271*/{-1,-1},
    /*272*/{-1,-1},
    /*273*/{-1,-1},
    /*274*/{-1,-1},
    /*275*/{-1,-1},
    /*276*/{-1,-1},
    /*277*/{-1,-1},
    /*278*/{6,124,15,103,30,279,32,112,33,98,34,119,35,123,36,108,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*279*/{-1,-1},
    /*280*/{-1,-1},
    /*281*/{97,283,-1,-1},
    /*282*/{-1,-1},
    /*283*/{-1,-1},
    /*284*/{-1,-1},
    /*285*/{97,286,-1,-1},
    /*286*/{-1,-1},
    /*287*/{-1,-1},
    /*288*/{-1,-1},
    /*289*/{-1,-1},
    /*290*/{-1,-1},
    /*291*/{-1,-1},
    /*292*/{-1,-1},
    /*293*/{-1,-1},
    /*294*/{-1,-1},
    /*295*/{-1,-1},
    /*296*/{-1,-1},
    /*297*/{78,310,79,308,80,311,95,312,-1,-1},
    /*298*/{-1,-1},
    /*299*/{-1,-1},
    /*300*/{-1,-1},
    /*301*/{-1,-1},
    /*302*/{15,295,47,303,48,291,58,299,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,296,73,298,74,300,-1,-1},
    /*303*/{-1,-1},
    /*304*/{6,124,15,103,30,122,31,306,32,112,33,98,34,119,35,123,36,108,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*305*/{-1,-1},
    /*306*/{-1,-1},
    /*307*/{-1,-1},
    /*308*/{-1,-1},
    /*309*/{81,315,98,316,-1,-1},
    /*310*/{-1,-1},
    /*311*/{-1,-1},
    /*312*/{-1,-1},
    /*313*/{78,310,79,308,80,311,95,314,-1,-1},
    /*314*/{-1,-1},
    /*315*/{81,315,98,320,-1,-1},
    /*316*/{-1,-1},
    /*317*/{6,124,15,103,30,122,31,318,32,112,33,98,34,119,35,123,36,108,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*318*/{-1,-1},
    /*319*/{-1,-1},
    /*320*/{-1,-1},
    /*321*/{6,124,15,103,30,122,31,322,32,112,33,98,34,119,35,123,36,108,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*322*/{-1,-1},
    /*323*/{6,124,15,103,30,122,31,324,32,112,33,98,34,119,35,123,36,108,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*324*/{-1,-1},
    /*325*/{-1,-1},
    /*326*/{-1,-1},
    /*327*/{-1,-1},
    /*328*/{15,332,45,331,50,329,59,333,64,70,65,90,66,88,67,330,68,334,-1,-1},
    /*329*/{-1,-1},
    /*330*/{-1,-1},
    /*331*/{-1,-1},
    /*332*/{-1,-1},
    /*333*/{-1,-1},
    /*334*/{-1,-1},
    /*335*/{-1,-1},
    /*336*/{55,338,56,339,89,340,-1,-1},
    /*337*/{-1,-1},
    /*338*/{-1,-1},
    /*339*/{55,349,56,339,89,340,-1,-1},
    /*340*/{15,295,42,346,47,290,48,291,49,293,50,288,51,287,53,294,57,345,58,299,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,296,73,298,74,300,-1,-1},
    /*341*/{6,124,15,103,30,342,32,112,33,98,34,119,35,123,36,108,37,120,38,109,39,114,75,117,76,118,-1,-1},
    /*342*/{-1,-1},
    /*343*/{89,344,-1,-1},
    /*344*/{-1,-1},
    /*345*/{-1,-1},
    /*346*/{78,347,79,308,80,311,-1,-1},
    /*347*/{-1,-1},
    /*348*/{-1,-1},
    /*349*/{-1,-1},
    /*350*/{-1,-1},
    /*351*/{89,352,-1,-1},
    /*352*/{-1,-1},
    /*353*/{-1,-1},
    /*354*/{-1,-1},
    /*355*/{-1,-1},
    /*356*/{3,254,96,357,-1,-1},
    /*357*/{-1,-1},
    /*358*/{3,258,4,49,13,359,14,259,28,52,40,45,46,34,50,9,51,35,52,54,53,33,54,22,85,53,86,50,-1,-1},
    /*359*/{-1,-1},
    /*360*/{-1,-1},
    /*361*/{-1,-1},
    /*362*/{8,14,9,363,10,8,11,18,12,5,17,25,18,19,19,15,20,32,28,20,40,6,46,34,50,9,51,35,52,24,53,33,54,22,-1,-1},
    /*363*/{-1,-1},
    /*364*/{-1,-1},
    /*365*/{-1,-1},
    /*366*/{-1,-1},
    /*367*/{-1,-1},
    /*368*/{-1,-1},
    /*369*/{-1,-1},
    /*370*/{-1,-1},
    /*371*/{3,41,15,295,22,372,42,373,47,290,48,291,49,293,50,288,51,287,53,294,58,299,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,296,73,298,74,300,-1,-1},
    /*372*/{-1,-1},
    /*373*/{-1,-1},
    /*374*/{3,378,4,49,14,380,23,382,24,383,25,376,26,379,28,52,40,45,46,34,50,9,51,35,52,54,53,33,54,22,85,53,86,50,-1,-1},
    /*375*/{15,295,42,404,47,290,48,291,49,293,50,288,51,287,53,294,58,299,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,296,73,298,74,300,-1,-1},
    /*376*/{-1,-1},
    /*377*/{15,295,42,401,47,290,48,291,49,293,50,288,51,287,53,294,58,299,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,296,73,298,74,300,-1,-1},
    /*378*/{-1,-1},
    /*379*/{-1,-1},
    /*380*/{-1,-1},
    /*381*/{-1,-1},
    /*382*/{-1,-1},
    /*383*/{3,378,4,49,14,380,23,384,24,383,25,376,26,379,28,52,40,45,46,34,50,9,51,35,52,54,53,33,54,22,85,53,86,50,-1,-1},
    /*384*/{-1,-1},
    /*385*/{-1,-1},
    /*386*/{-1,-1},
    /*387*/{27,391,91,390,-1,-1},
    /*388*/{15,67,44,399,58,73,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,64,-1,-1},
    /*389*/{3,179,83,397,-1,-1},
    /*390*/{-1,-1},
    /*391*/{-1,-1},
    /*392*/{27,391,91,393,-1,-1},
    /*393*/{-1,-1},
    /*394*/{3,179,83,395,-1,-1},
    /*395*/{-1,-1},
    /*396*/{-1,-1},
    /*397*/{-1,-1},
    /*398*/{-1,-1},
    /*399*/{79,400,-1,-1},
    /*400*/{-1,-1},
    /*401*/{78,310,79,308,80,311,95,402,-1,-1},
    /*402*/{-1,-1},
    /*403*/{-1,-1},
    /*404*/{78,310,79,308,80,311,95,405,-1,-1},
    /*405*/{-1,-1},
    /*406*/{-1,-1},
    /*407*/{-1,-1},
    /*408*/{-1,-1},
    /*409*/{3,254,96,410,-1,-1},
    /*410*/{-1,-1},
    /*411*/{3,258,4,49,13,412,14,259,28,52,40,45,46,34,50,9,51,35,52,54,53,33,54,22,85,53,86,50,-1,-1},
    /*412*/{-1,-1},
    /*413*/{-1,-1},
    /*414*/{-1,-1},
    /*415*/{-1,-1},
    /*416*/{15,295,42,418,47,290,48,291,49,293,50,288,51,287,53,294,58,299,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,296,73,298,74,300,77,419,88,417,-1,-1},
    /*417*/{-1,-1},
    /*418*/{78,310,79,308,80,311,95,421,-1,-1},
    /*419*/{15,295,42,418,47,290,48,291,49,293,50,288,51,287,53,294,58,299,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,296,73,298,74,300,77,419,88,420,-1,-1},
    /*420*/{-1,-1},
    /*421*/{-1,-1},
    /*422*/{-1,-1},
    /*423*/{-1,-1},
    /*424*/{-1,-1},
    /*425*/{15,295,42,418,47,290,48,291,49,293,50,288,51,287,53,294,58,299,59,75,60,89,61,76,63,86,64,70,65,90,66,88,67,66,68,80,69,63,70,85,72,296,73,298,74,300,77,419,88,426,-1,-1},
    /*426*/{-1,-1},
    /*427*/{-1,-1},
    /*428*/{-1,-1},
    /*429*/{-1,-1},
    /*430*/{-1,-1},
    /*431*/{3,41,22,432,-1,-1},
    /*432*/{-1,-1},
    /*433*/{3,378,4,49,14,380,23,434,24,383,25,376,26,379,28,52,40,45,46,34,50,9,51,35,52,54,53,33,54,22,85,53,86,50,-1,-1},
    /*434*/{-1,-1},
    /*435*/{-1,-1},
    /*436*/{-1,-1},
    /*437*/{-1,-1},
  };

  /** access to reduce_goto table */
  public short[][] reduce_table() {return _reduce_table;}

  /** instance of action encapsulation class */
  protected CUP$actions action_obj;

  /** action encapsulation object initializer */
  protected void init_actions()
    {
      action_obj = new CUP$actions();
    }

  /** invoke a user supplied parse action */
  public org.jacorb.idl.runtime.symbol do_action(
    int                        act_num,
    org.jacorb.idl.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$do_action(act_num, parser, stack, top);
  }

  /** start state */
  public int start_state() {return 0;}
  /** start production */
  public int start_production() {return 0;}

  /** EOF symbol index */
  public int EOF_sym() {return 0;}

  /** error symbol index */
  public int error_sym() {return 1;}


  /** user initialization */
  public void user_init() throws java.lang.Exception
    {

        lexer.init();

    }

  /** scan to get the next token */
  public org.jacorb.idl.runtime.token scan()
    throws java.lang.Exception
    {

        return lexer.next_token();

    }


    static String command_line[] = null;

    public static Hashtable pack_replace = new Hashtable();
    public static Stack scopes = new Stack();
    private static Hashtable tmpDefines = new Hashtable();
    private static Hashtable tmpUnDefines = new Hashtable();

    public final static String currentVersion = "";

    // Compiles out leaving no runtime dependency on Version
    public static final String compiler_version = org.jacorb.util.Version.longVersion;

    private static final String yearString = "1997-2012";

    private static final String versionInfo = org.jacorb.util.BuildVersion.versionInfo;

    private static org.jacorb.idl.IDLTreeVisitor generator = null;

    private static final String FINAL = " final";
    private static final String NO_FINAL = "";

    public static String out_dir = ".";
    static String package_prefix = null;

    static boolean parse_only = false;

    /** used for internal checking that name conversion
        to mapped Java names is done only after parsing */
    public static boolean done_parsing = false;

    /** compiler flags */
    public static boolean include_state = false;
    public static boolean strict_names = true;
    /**
     * <code>strict_identifiers</code> defaults to on and is used to
     * disable case insensitive identifiers - see section 3.2.3 of 04-03-12.
     */
    public static boolean strict_identifiers = true;
    /** these two are to work around buggy IDL generated by Sun's rmic in JDK 1.4 */
    public static boolean strict_inheritance = true;
    public static boolean strict_attributes = true;

    public static boolean generateIR = false;
    public static boolean generate_skeletons = true;
    public static boolean generate_stubs = true;

    public static boolean generate_ami_callback = false;
    public static boolean generate_ami_polling  = false;

    protected static boolean generateIncluded = false;
    protected static boolean inhibitionState = false;
    protected static boolean localityContraint = false;
    protected static boolean useUncheckedNarrow = false;
    protected static boolean cldc10 = false;
    static boolean generateEnhanced;

    public static final int HELPER_DEPRECATED = 0;
    public static final int HELPER_PORTABLE = 1;
    public static final int HELPER_JACORB = 2;

    static int generatedHelperPortability = HELPER_PORTABLE;

    protected static boolean forceOverwrite;
    protected static boolean addbackend = false;

    protected static boolean generateDiiStubs = false;

    protected static String finalString = FINAL;

    private static int activeParseThreads;

    private static IDLLogger logger;
    private static Writer logStreamWriter = null;

    /*  a la CORBA 2.4, allow forward declarations that remain undefined */
    public static boolean sloppy = false;

    public static String currentDate;

    private static ObjectCachePlugin objectCachePlugin;

    /**
     *  allows reinitialization if compiler is not
     *  run from a command-line
     */

    protected static void cleanup()
    {
        GlobalInputStream.cleanUp();
        generatedHelperPortability = HELPER_PORTABLE;
        pending_interfaces.clear();
        pack_replace.clear();
        scopes.clear();
        tmpDefines.clear();
        tmpUnDefines.clear();
        generator = null;
        objectCachePlugin = null;

        activeParseThreads = 0;
        InterfaceBody.clearParseThreads ();

        out_dir = ".";
        package_prefix = null;

        parse_only = false;
        done_parsing = false;

        include_state = false;
        generateIR = false;
        generate_skeletons = true;
        generate_stubs = true;
        generate_ami_callback = false;
        generate_ami_polling = false;

        strict_names = true;
        strict_identifiers = true;
        strict_inheritance = true;
        strict_attributes = true;

        generateIncluded = false;
        inhibitionState = false;
        localityContraint = false;
        useUncheckedNarrow = false;
        cldc10 = false;
        generateEnhanced = false;
        forceOverwrite = false;

        generateDiiStubs = false;

        finalString = FINAL;

        sloppy = false;

   }

    protected static final void initLogging()
    {
        currentDate = java.text.DateFormat.getDateTimeInstance().format(new java.util.Date());

        // check if the environment's logStream has been set
        Writer logWriter;
        if( logStreamWriter != null )
        {
            logWriter = logStreamWriter;
        }
        else
        {
            OutputStream outStream = System.err;
            logWriter = new OutputStreamWriter( outStream );
        }

        logger = IDLLogger.getLogger("jacorb.idl", IDLLogger.ERROR, logWriter);
    }


    public static void main( String argv[] )
    {
        if( compileAndHandle( argv ) == true )
            System.exit( 0 );
        else
            System.exit( 1 );
    }


    public static boolean compileAndHandle( String argv[] )
    {
        try
        {
            return compile( argv );
        }
        catch( org.jacorb.idl.ParseException e )
        {
            logger.debug ( "Exception caught", e);
            lexer.emit_error( e.getMessage() );
            return false;
        }
        catch ( java.io.IOException io )
        {
            lexer.emit_error("IO Error, please check file names: " + io.getMessage());
        }
        catch( Exception e )
        {
            lexer.emit_error( "Exception: " + e.toString() );
            usage( argv, e.getMessage() );
        }
        return false;
    }

    public static boolean compile( String argv[] )
        throws Exception
    {
        return compile( argv, null );
    }

    public static boolean compile( String argv[], StringWriter logWriter )
        throws Exception
    {
        BufferedReader in = null;

        if (logWriter!= null)
              logStreamWriter = logWriter;

        initLogging();

        parser.openScope();

        command_line = argv;
        if( argv.length > 0 )
        {
            int i;
            for( i = 0; i < argv.length; i++ )
            {
                if( argv[i].equals("-syntax"))
                {
                    parse_only = true;
                    continue;
                }
                if( argv[i].equals("-diistub"))
                {
                    generateDiiStubs = true;
                    continue;
                }
                if( argv[i].equals("-noskel"))
                {
                    generate_skeletons = false;
                    continue;
                }
                if( argv[i].equals("-nostub"))
                {
                    generate_stubs = false;
                    continue;
                }
                if( argv[i].equals("-ami_callback"))
                {
                    generate_ami_callback = true;
                    continue;
                }
                if( argv[i].equals("-forceOverwrite"))
                {
                    forceOverwrite = true;
                    continue;
                }
                if( argv[i].equals("-ami_polling"))
                {
                    throw new RuntimeException
                      ("Sorry, the polling model is not yet implemented.");
                    // generate_ami_polling = true;
                    // continue;
                }
                if( argv[i].equals("-sloppy_forward"))
                {
                    sloppy = true;
                    continue;
                }
                if( argv[i].equals("-sloppy_names"))
                {
                    strict_names = false;
                    continue;
                }
                if( argv[i].equals("-sloppy_identifiers"))
                {
                    strict_identifiers = false;
                    continue;
                }
                if( argv[i].equals("-permissive_rmic"))
                {
                    strict_names = false;
                    strict_attributes = false;
                    strict_inheritance = false;
                    continue;
                }
                if( argv[i].equals("-unchecked_narrow"))
                {
                    useUncheckedNarrow = true;
                    continue;
                }
                if( argv[i].equals("-backend") || argv[i].equals("-addbackend"))
                {
                    if (argv[i].equals("-addbackend"))
                    {
                        addbackend = true;
                    }

                    if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                        usage(argv, "-backend");

                    // custom code generators
                    Class codeGeneratorClass = null;

                    try
                    {
                        codeGeneratorClass = Class.forName( argv[++i] );
                    }
                    catch( ClassNotFoundException cnfe )
                    {
                        throw new ParseException("Generator Class " + argv[i] + " not found! Check classpath!");
                    }

                    if( ! org.jacorb.idl.IDLTreeVisitor.class.isAssignableFrom( codeGeneratorClass ))
                        throw new ParseException( "Not a valid code generator: " +
                            codeGeneratorClass.getName() );
                    setGenerator( (org.jacorb.idl.IDLTreeVisitor) codeGeneratorClass.newInstance());
                    continue;
                }
                if( argv[i].equals("-cacheplugin"))
                {
                    if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                        usage(argv, "-cacheplugin");

                    setObjectCachePlugin(argv[++i]);
                    continue;
                }
                if( argv[i].equals("-d"))
                {
                    if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                        usage(argv, "-d");
                    out_dir = argv[++i];
                    continue;
                }
                if( argv[i].equals("-W"))
                {
                    if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                        usage(argv, "-W");

                    int level = Integer.parseInt( argv[++i] );

                    logger.setLevel(Environment.intToLevel(level));

                    continue;
                }
                if( argv[i].startsWith("-D"))
                {
                    String def = argv[i].substring(2);
                    String val;

                    if( def.indexOf('=') > 0 )
                    {
                        val = def.substring( def.indexOf('=') + 1);
                        def = def.substring( 0, def.indexOf('='));
                    }
                    else
                        val = "1";
                    tmpDefines.put( def, val );
                    continue;
                }
                if( argv[i].startsWith("-U"))
                {
                        tmpUnDefines.put( argv[i].substring(2), "" );
                        continue;
                }
                if( argv[i].equals("-cldc10"))
                {
                        cldc10 = true;
                        continue;
                }
                if( argv[i].equals("-genEnhanced"))
                {
                    generateEnhanced = true;
                    continue;
                }
                if( argv[i].equals("-generate_helper"))
                {
                    String level = argv[++i];

                    generatedHelperPortability = parseGeneratedHelperPortability(level);

                    if (generatedHelperPortability < 0)
                    {
                        usage(argv, "argument to -generate_helper should be one of (portable|jacorb|deprecated)");

                        return false;
                    }

                    continue;
                }
                if( argv[i].equals("-i2jpackage"))
                {
                    if( i+1 == argv.length || argv[i+1].charAt(0)=='-')
                        usage(argv, "-i2jpackage");
                     addI2JPackage (argv[i+1]);
                    i++;
                    continue;
                }
                if (argv[i].equals ("-i2jpackagefile"))
                {
                   if( i+1 == argv.length || argv[i+1].charAt(0)=='-')
                        usage(argv, "-i2jpackagefile");

                       try
                       {
                          in = new BufferedReader (new FileReader (argv[i+1]));
                       }
                       catch (FileNotFoundException e)
                       {
                          System.out.println ("File " + argv[i+1] + " not found");
                          throw new RuntimeException
                             ("File for -i2jpackagefile not found");
                       }
                       String mapping = in.readLine ();
                       while (mapping != null)
                       {
                          addI2JPackage (mapping);
                          mapping = in.readLine ();
                       }
                       in.close ();
                       i++;
                       continue;
                }
                if( argv[i].equals("-ir"))
                {
                        generateIR = true;
                        continue;
                }
                if( argv[i].startsWith("-I"))
                {
                    GlobalInputStream.setIncludePath(argv[i].substring(2));
                    continue;
                }
                if( argv[i].equals("-h") || argv[i].equals("-help") )
                {
                    help();
                    return true;
                }
                if( argv[i].equals("-all") )
                {
                        generateIncluded = true;
                        continue;
                }
                if( argv[i].equals("-v") || argv[i].equals("-version") )
                {
                    version();
                    return true;
                }
                if ( argv[i].equals("-nofinal") )
                {
                    setFinalString(NO_FINAL);
                    continue;
                }
                if( argv[i].equals("-in") )
                {
                    i++;
                    if( i < argv.length )
                    {
                        prepareAndParse(argv[i]);
                    }
                    continue;
                }
                if( argv[i].endsWith(".idl") )
                {
                    break;
                }

                // else:
                usage(argv, "Unrecognized option: " + argv[i]);

            }

            try
            {
                for( int j=i; j < argv.length; j++)
                {
                    if( argv[j].endsWith(".idl"))
                    {
                        prepareAndParse(argv[j]);
                    }
                    else
                    {
                        throw new ParseException("Not an IDL file:" + argv[j]);
                    }
                }
            }
            finally
            {
                cleanup();
            }
        }
        return true;
    }

    public static int parseGeneratedHelperPortability(String level)
    {
        if (level.equals("deprecated"))
        {
            return HELPER_DEPRECATED;
        }
        else if (level.equals("portable"))
        {
            return HELPER_PORTABLE;
        }
        else if (level.equals("jacorb"))
        {
            return HELPER_JACORB;
        }
        else
        {
            return -1;
        }
    }

    private static void prepareAndParse(String fileName)
        throws Exception
    {
        GlobalInputStream.init();
        GlobalInputStream.setInput( fileName );

        /* reset tables everywhere */
        lexer.reset();
        NameTable.init();
        ConstDecl.init();
        TypeMap.init();

        /* define/undefine symbols */
        for( Enumeration e = tmpDefines.keys(); e.hasMoreElements(); )
        {
            String key = (String)e.nextElement();
            lexer.define( key, (String)tmpDefines.get( key ));
        }

        /* Standard compiler defines, can be undefined */

        lexer.define("JACORB", "1");
        lexer.define("_PRE_3_0_COMPILER_", "1");
        lexer.define("GIOP_1_1", "1");
        lexer.define("GIOP_1_2", "1");

        for( Enumeration e = tmpUnDefines.keys(); e.hasMoreElements(); )
        {
            lexer.undefine( (String)e.nextElement() );
        }

        new parser().parse();

        if( lexer.error_count > 0 )
        {
            throw new ParseException( "Errors in lexer" );
        }
    }




    public static void usage(String [] argv, String msg)
    {
        // debug:
        for( int i = 0; i < argv.length; i++)
            System.out.print( argv[i] + " " );
        System.out.println(" : " + msg);

        System.out.println("Usage: idl [-h|-help][-v|-version][-Dsymbol[=value]][-Idir][-U<symbol>][-W debug_level ][-all][-forceOverwrite][-ami_callback][-ami_polling][-backend classname][-d <Output Dir>][-unchecked_narrow][-i2jpackage x:y][-i2jpackagefile <filename>][-cldc10][-ir][-nofinal][-noskel][-nostub][-diistub][-sloppy_forward][-sloppy_names][-sloppy_identifiers][-permissive_rmic][-genEnhanced][-syntax][-in inputfile][-generate_helper (portable|jacorb|deprecated)][-cacheplugin classname] <filelist>");
    }


    static void addI2JPackage( String mapping )
    {
       int split_idx = mapping.indexOf(':');
       if( split_idx  < 0 )
       {
          System.out.println ("Incorrect format for i2jpackage mapping: " + mapping);
          System.exit (1);
       }
       String idlp = mapping.substring(0,split_idx);
       String jp = mapping.substring(split_idx+1);

       if( idlp.length() == 0 )
       {
           package_prefix = jp;
           if( logger.isDebugEnabled() )
           {
               logger.debug( "Replace unnamed global package with " + jp );
           }
       }
       else
       {
           pack_replace.put( idlp, jp );
           if( logger.isDebugEnabled() )
           {
               logger.debug( "Replace pack " + idlp + " with " + jp );
           }
       }
    }


    private static void help()
    {
        System.out.println("\t-h|help \tthese few lines of help");
        System.out.println("\t-v|version \tprint version information");
        System.out.println("\t-d dir\t\troot of directory tree for output");
        System.out.println("\t-Dx\t\tdefine preprocessor symbol x with value 1");
        System.out.println("\t-Dx=y\t\tdefine preprocessor symbol x with value y");
        System.out.println("\t-Idir\t\tset include path for idl files");
        System.out.println("\t-U<symbol>\t\tundefine preprocessor symbol");
        System.out.println("\t-W [1..4]\tdebug level");
        System.out.println("\t-all\t\tgenerate code for all IDL files, even included ones");
        System.out.println("\t-forceOverwrite\tgenerate code even if IDL has not changed");
        System.out.println("\t-ami_callback\t\tgenerate AMI reply handlers and sendc methods");
        System.out.println("\t-ami_polling\t\tgenerate AMI poller and sendp methods");
        System.out.println("\t-backend classname\t\tuse classname as code generator");
        System.out.println("\t-addbackend classname\t\tadd classname as code generator");
        System.out.println("\t-i2jpackage x:a.b.c\t replace IDL package name x by a.b.c in generated Java code (e.g. CORBA:org.omg.CORBA)");
        System.out.println("\t-i2jpackagefile <filename>\t replace IDL package names using list from <filename>. Format as above.");
        System.out.println("\t-ir\t\tgenerate information required by the Interface Repository");
        System.out.println("\t-nofinal\tgenerated Java code will contain no final class definitions");
        System.out.println("\t-unchecked_narrow\t\tuse unchecked_narrow in generated code for IOR parameters in operations");
        System.out.println("\t-noskel\t\tdisables generation of POA skeletons");
        System.out.println("\t-nostub\t\tdisables generation of client stubs");
        System.out.println("\t-diistub\t\tgenerate dii-based client stubs");
        System.out.println("\t-cldc10\t\tcode generation compatible with J2ME/CLDC 1.0");
        System.out.println("\t-sloppy_forward\tallow forward declarations wo. later definitions");
        System.out.println("\t-sloppy_names\tless strict checking of module name scoping");
        System.out.println("\t-sloppy_identifiers\tAllow certain illegal identifiers.");
        System.out.println("\t-permissive_rmic\ttolerate dubious IDL generated by JDK's rmic, includes -sloppy_names.");
        System.out.println("\t-genEnhanced\tGenerate toString and equals on stubs. Only supported on Struct currently.");
        System.out.println("\t-generate_helper (portable[default]|jacorb|deprecated). Controls the controls the compatibilty level of the generated helper code.");
        System.out.println("\t-cacheplugin classname\tset plugin for cache code generation");

        System.out.println("\t-syntax\t\tsyntax check only, no code generation");
        System.out.println("\t<filelist>\t");
  }

    private static void version()
    {
        System.out.println("JacORB IDL compiler V" +  compiler_version +
                           ",\n   (C) The JacORB Project contributors, " +
                           yearString + "." + versionInfo);
    }

    /* override error routines */

    public void report_fatal_error( String message, Object info)
        throws ParseException
    {
       done_parsing();
       lexer.emit_error(message + "\nCan't recover from previous error(s), giving up.");
       throw new ParseException();
    }

    public static void fatal_error(String message, str_token p_info)
        throws ParseException
    {
       //done_parsing();
       lexer.emit_error(message + "\nCan't recover from previous error(s), giving up.", p_info);
       throw new ParseException();
    }

    public void report_error(String message, Object info)
    {
       lexer.emit_error(message);
    }

    public static void error(String message, str_token p_info)
    {
       lexer.emit_error(message, p_info);
    }

    public static void error( String message )
    {
       lexer.emit_error( message );
    }

    /* bookkeeping with IDL scopes */

    /** called from the lexer/scanner whenever a scope opening
        symbol is encountered */

    public static void openScope()
    {
        scopes.push(new ScopeData());
    }

    /** called from within the parser whenever parsing a scope
        symbol is complete */

    public static void closeScope(Scope symbol)
    {
            ScopeData data = (ScopeData) scopes.pop();
            symbol.setScopeData( data );
    }

    public static ScopeData currentScopeData()
    {
            return (ScopeData)scopes.peek();
    }


    // an interface inheriting from an forward declared interface
    // needs to wait on an object until the ancestor has been parsed
    // if get_pending returns null, the ancestor was not forward
    // declared and thus has already been parsed

    // forward declared interfaces are put into this list

    static Hashtable pending_interfaces = new Hashtable();

    public static synchronized void set_pending( String name, Object type )
    {
         // name will only be marked pending if it has not already been
         // parsed before and if is not already pending
         String use = ScopedName.unPseudoName (name);

         if( ! ( pending_interfaces.containsKey(use) ||
                 NameTable.parsed_interfaces.containsKey(use)) )
         {
                 pending_interfaces.put(use, type);
         }
    }

    public static void setGenerator( org.jacorb.idl.IDLTreeVisitor generatorObject )
    {
        generator = generatorObject;
    }

    public static org.jacorb.idl.IDLTreeVisitor getGenerator()
    {
        return generator;
    }

    public static void setObjectCachePlugin(String pluginClass)
        throws InstantiationException, IllegalAccessException
    {
        final Class cachePluginClass;

        try
        {
            if (Thread.currentThread().getContextClassLoader() == null)
            {
                cachePluginClass = Class.forName(pluginClass);
            }
            else
            {
                cachePluginClass = Thread.currentThread().getContextClassLoader().loadClass(pluginClass);
            }
        }
        catch( ClassNotFoundException cnfe )
        {
            throw new ParseException("CachePlugin Class " + pluginClass + " not found! Check classpath!");
        }

        if( ! ObjectCachePlugin.class.isAssignableFrom( cachePluginClass ))
        {
            throw new ParseException( "Not a valid cache plugin: " + pluginClass );
        }

        objectCachePlugin = (ObjectCachePlugin) cachePluginClass.newInstance();
    }

    public static void setObjectCachePlugin(ObjectCachePlugin plugin)
    {
        objectCachePlugin = plugin;
    }

    public static ObjectCachePlugin getObjectCachePlugin()
    {
        return objectCachePlugin;
    }

    public static boolean hasObjectCachePlugin()
    {
        return objectCachePlugin != null;
    }

    public static synchronized void remove_pending( String name )
    {
         String use = ScopedName.unPseudoName (name);
         Object o = pending_interfaces.remove(use);
         if( o != null)
         {
             synchronized( o )
             {
                  o.notifyAll();
             }
         }
         if( pending_interfaces.size() == 0 )
         {
             // notify the main thread that the parsing phase is complete
             synchronized( pending_interfaces )
             {
                  pending_interfaces.notifyAll();
             }
         }
    }

    public static Object get_pending( String name )
    {
        return pending_interfaces.get (ScopedName.unPseudoName (name));
    }

    public static synchronized void decActiveParseThreads()
    {
        activeParseThreads--;
    }

    public static synchronized void incActiveParseThreads()
    {
        activeParseThreads++;
    }

    public static synchronized int activeParseThreads()
    {
        return activeParseThreads;
    }

    public static boolean generateIncluded()
    {
        return generateIncluded;
    }

    public static boolean getInhibitionState()
    {
        return inhibitionState;
    }

    public static void setInhibitionState(boolean flag)
    {
        inhibitionState = flag;
    }

    public static void set_included( boolean i )
    {
        include_state = i;
    }

    public static String getFinalString()
    {
        return finalString;
    }

    public static void setFinalString(String finalString)
    {
        parser.finalString = finalString;
    }

    public static void setGenerateFinalCode(boolean isFinal)
    {
        if (isFinal)
        {
            setFinalString(FINAL);
        }
        else
        {
            setFinalString(NO_FINAL);
        }
    }



    /**
     * Package replacements as requested
     * by compiler options
     */

    public static String pack_replace(String old)
    {
        String n_str = (String)pack_replace.get(old);
        if( n_str == null )
            return old;
        else
            return n_str;
    }

    /**
     * convenience access to the preconfigured loger for the
     * IDL compiler
     */

    public static final IDLLogger getLogger()
    {
        return logger;
    }




};

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$actions {




  /** Constructor */
  CUP$actions() { }

  /** Method with the actual generated action code. */
  public final org.jacorb.idl.runtime.symbol CUP$do_action(
    int                        CUP$act_num,
    org.jacorb.idl.runtime.lr_parser CUP$parser,
    java.util.Stack            CUP$stack,
    int                        CUP$top)
    throws java.lang.Exception
    {
      /* object for return from actions */
      org.jacorb.idl.runtime.symbol CUP$result;

      /* select the action based on the action number */
      switch (CUP$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 240: // empty ::= 
            {
              CUP$result = new org.jacorb.idl.runtime.symbol(/*empty*/3);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 239: // param_type_spec ::= scopename 
            {
              CUP$result = new TypeSpec(/*param_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 238: // param_type_spec ::= string_type 
            {
              CUP$result = new TypeSpec(/*param_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 237: // param_type_spec ::= base_type_spec 
            {
              CUP$result = new TypeSpec(/*param_type_spec*/44);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(BaseType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 236: // string_literal_list ::= string_literal COMMA string_literal_list 
            {
              CUP$result = new org.jacorb.idl.runtime.symbol(/*string_literal_list*/2);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 235: // string_literal_list ::= string_literal 
            {
              CUP$result = new org.jacorb.idl.runtime.symbol(/*string_literal_list*/2);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 234: // context_expr ::= empty 
            {
              CUP$result = new org.jacorb.idl.runtime.symbol(/*context_expr*/1);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 233: // context_expr ::= CONTEXT LPAREN string_literal_list RPAREN 
            {
              CUP$result = new org.jacorb.idl.runtime.symbol(/*context_expr*/1);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 232: // raises_expr_nonempty ::= RAISES LPAREN scopename_list RPAREN 
            {
              CUP$result = new RaisesExpr(/*raises_expr_nonempty*/84);
              
                ((RaisesExpr)CUP$result).nameList = (Vector)(/*snl*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone();
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 231: // raises_expr ::= empty 
            {
              CUP$result = new RaisesExpr(/*raises_expr*/83);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 230: // raises_expr ::= RAISES LPAREN scopename_list RPAREN 
            {
              CUP$result = new RaisesExpr(/*raises_expr*/83);
              
                ((RaisesExpr)CUP$result).nameList = (Vector)(/*snl*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone();
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 229: // param_attribute ::= INOUT 
            {
              CUP$result = new org.jacorb.idl.runtime.int_token(/*param_attribute*/5);
               ((org.jacorb.idl.runtime.int_token)CUP$result).int_val = ParamDecl.MODE_INOUT; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 228: // param_attribute ::= OUT 
            {
              CUP$result = new org.jacorb.idl.runtime.int_token(/*param_attribute*/5);
               ((org.jacorb.idl.runtime.int_token)CUP$result).int_val = ParamDecl.MODE_OUT; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 227: // param_attribute ::= IN 
            {
              CUP$result = new org.jacorb.idl.runtime.int_token(/*param_attribute*/5);
               ((org.jacorb.idl.runtime.int_token)CUP$result).int_val = ParamDecl.MODE_IN; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // param_dcl ::= param_attribute param_type_spec simple_declarator 
            {
              CUP$result = new ParamDecl(/*param_dcl*/82);
              
                ((ParamDecl)CUP$result).paramAttribute = (/*pa*/(org.jacorb.idl.runtime.int_token)CUP$stack.elementAt(CUP$top-2)).int_val;
                ((ParamDecl)CUP$result).paramTypeSpec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                ((ParamDecl)CUP$result).simple_declarator = (/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0));
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // param_dcls ::= param_dcl 
            {
              CUP$result = new SymbolList(/*param_dcls*/90);
              
                        ((SymbolList)CUP$result).v.insertElementAt((/*pd*/(ParamDecl)CUP$stack.elementAt(CUP$top-0)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // param_dcls ::= param_dcl COMMA param_dcls 
            {
              CUP$result = new SymbolList(/*param_dcls*/90);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*pds*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*pd*/(ParamDecl)CUP$stack.elementAt(CUP$top-2)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // parameter_dcls ::= LPAREN RPAREN 
            {
              CUP$result = new SymbolList(/*parameter_dcls*/92);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // parameter_dcls ::= LPAREN param_dcls RPAREN 
            {
              CUP$result = new SymbolList(/*parameter_dcls*/92);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*pds*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // void_type_spec ::= VOID 
            {
              CUP$result = new VoidTypeSpec(/*void_type_spec*/71);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // op_type_spec ::= void_type_spec 
            {
              CUP$result = new TypeSpec(/*op_type_spec*/43);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(VoidTypeSpec)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // op_type_spec ::= param_type_spec 
            {
              CUP$result = new TypeSpec(/*op_type_spec*/43);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(TypeSpec)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // op_attribute ::= empty 
            {
              CUP$result = new org.jacorb.idl.runtime.int_token(/*op_attribute*/4);
               ((org.jacorb.idl.runtime.int_token)CUP$result).int_val = OpDecl.NO_ATTRIBUTE; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // op_attribute ::= ONEWAY 
            {
              CUP$result = new org.jacorb.idl.runtime.int_token(/*op_attribute*/4);
               ((org.jacorb.idl.runtime.int_token)CUP$result).int_val = OpDecl.ONEWAY; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // op_dcl ::= op_attribute op_type_spec ID parameter_dcls raises_expr context_expr 
            {
              CUP$result = new OpDecl(/*op_dcl*/85);
              
                        ((OpDecl)CUP$result).opAttribute = (/*oa*/(org.jacorb.idl.runtime.int_token)CUP$stack.elementAt(CUP$top-5)).int_val;
                        ((OpDecl)CUP$result).opTypeSpec = (/*ots*/(TypeSpec)CUP$stack.elementAt(CUP$top-4));
                        ((OpDecl)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));
                        ((OpDecl)CUP$result).paramDecls = (Vector)(/*pds*/(SymbolList)CUP$stack.elementAt(CUP$top-2)).v.clone();
                        ((OpDecl)CUP$result).raisesExpr = (/*re*/(RaisesExpr)CUP$stack.elementAt(CUP$top-1));
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // except_dcl ::= EXCEPTION ID LCBRACE member_list RCBRACE 
            {
              CUP$result = new StructType(/*except_dcl*/52);
              
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));
                        ((StructType)CUP$result).exc = true;
                        ((StructType)CUP$result).set_memberlist( (/*ml*/(MemberList)CUP$stack.elementAt(CUP$top-1)) );
                        ((StructType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((StructType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // except_dcl ::= EXCEPTION ID LCBRACE RCBRACE 
            {
              CUP$result = new StructType(/*except_dcl*/52);
              
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)));
                        ((StructType)CUP$result).exc = true;
                        ((StructType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((StructType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // simple_declarator_list ::= simple_declarator COMMA simple_declarator_list 
            {
              CUP$result = new SymbolList(/*simple_declarator_list*/94);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*sdl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-2)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // simple_declarator_list ::= simple_declarator 
            {
              CUP$result = new SymbolList(/*simple_declarator_list*/94);
              
                        ((SymbolList)CUP$result).v.insertElementAt((/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // attr_raises_expr ::= SETRAISES LPAREN scopename_list RPAREN 
            {
              CUP$result = new AttrRaisesExpr(/*attr_raises_expr*/87);
              
            ((AttrRaisesExpr)CUP$result).setNameList = (Vector)(/*set_snl*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone();
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // attr_raises_expr ::= GETRAISES LPAREN scopename_list RPAREN 
            {
              CUP$result = new AttrRaisesExpr(/*attr_raises_expr*/87);
              
            ((AttrRaisesExpr)CUP$result).getNameList = (Vector)(/*get_snl*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone();
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // attr_raises_expr ::= SETRAISES LPAREN scopename_list RPAREN GETRAISES LPAREN scopename_list RPAREN 
            {
              CUP$result = new AttrRaisesExpr(/*attr_raises_expr*/87);
              
            ((AttrRaisesExpr)CUP$result).getNameList = (Vector)(/*get_snl*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone();
            ((AttrRaisesExpr)CUP$result).setNameList = (Vector)(/*set_snl*/(SymbolList)CUP$stack.elementAt(CUP$top-5)).v.clone();
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // attr_raises_expr ::= GETRAISES LPAREN scopename_list RPAREN SETRAISES LPAREN scopename_list RPAREN 
            {
              CUP$result = new AttrRaisesExpr(/*attr_raises_expr*/87);
              
            ((AttrRaisesExpr)CUP$result).getNameList = (Vector)(/*get_snl*/(SymbolList)CUP$stack.elementAt(CUP$top-5)).v.clone();
            ((AttrRaisesExpr)CUP$result).setNameList = (Vector)(/*set_snl*/(SymbolList)CUP$stack.elementAt(CUP$top-1)).v.clone();
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // attr_dcl ::= ATTRIBUTE param_type_spec simple_declarator attr_raises_expr 
            {
              CUP$result = new AttrDecl(/*attr_dcl*/86);
              
          ((AttrDecl)CUP$result).readOnly = false;
          ((AttrDecl)CUP$result).param_type_spec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-2));
          ((AttrDecl)CUP$result).declarators = new SymbolList ((/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-1)));
          ((AttrDecl)CUP$result).getRaisesExpr = new RaisesExpr ((/*are*/(AttrRaisesExpr)CUP$stack.elementAt(CUP$top-0)).getNameList);
          ((AttrDecl)CUP$result).setRaisesExpr = new RaisesExpr ((/*are*/(AttrRaisesExpr)CUP$stack.elementAt(CUP$top-0)).setNameList);
      
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // attr_dcl ::= ATTRIBUTE param_type_spec simple_declarator_list 
            {
              CUP$result = new AttrDecl(/*attr_dcl*/86);
              
          ((AttrDecl)CUP$result).readOnly = false;
          ((AttrDecl)CUP$result).param_type_spec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
          ((AttrDecl)CUP$result).declarators = (/*sdl*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
          ((AttrDecl)CUP$result).getRaisesExpr = new RaisesExpr();
          ((AttrDecl)CUP$result).setRaisesExpr = new RaisesExpr();
      
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // attr_dcl ::= READONLY ATTRIBUTE param_type_spec simple_declarator raises_expr_nonempty 
            {
              CUP$result = new AttrDecl(/*attr_dcl*/86);
              
          ((AttrDecl)CUP$result).readOnly = true;
          ((AttrDecl)CUP$result).param_type_spec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-2));
          ((AttrDecl)CUP$result).declarators = new SymbolList ((/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-1)));
          ((AttrDecl)CUP$result).getRaisesExpr = (/*re*/(RaisesExpr)CUP$stack.elementAt(CUP$top-0));
          ((AttrDecl)CUP$result).setRaisesExpr = new RaisesExpr();
      
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // attr_dcl ::= READONLY ATTRIBUTE param_type_spec simple_declarator_list 
            {
              CUP$result = new AttrDecl(/*attr_dcl*/86);
              
          ((AttrDecl)CUP$result).readOnly = true;
          ((AttrDecl)CUP$result).param_type_spec = (/*pts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
          ((AttrDecl)CUP$result).declarators = (/*sdl*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
          ((AttrDecl)CUP$result).getRaisesExpr = new RaisesExpr();
          ((AttrDecl)CUP$result).setRaisesExpr = new RaisesExpr();
      
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // fixed_array_size ::= LSBRACE positive_int_const RSBRACE 
            {
              CUP$result = new FixedArraySize(/*fixed_array_size*/81);
              
                        ((FixedArraySize)CUP$result).pos_int_const = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // fixed_array_size_list ::= fixed_array_size fixed_array_size_list 
            {
              CUP$result = new SymbolList(/*fixed_array_size_list*/98);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*fasl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*fas*/(FixedArraySize)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // fixed_array_size_list ::= fixed_array_size 
            {
              CUP$result = new SymbolList(/*fixed_array_size_list*/98);
              
                        ((SymbolList)CUP$result).v.insertElementAt((/*fas*/(FixedArraySize)CUP$stack.elementAt(CUP$top-0)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // array_declarator ::= ID fixed_array_size_list 
            {
              CUP$result = new ArrayDeclarator(/*array_declarator*/80);
              
                        ((ArrayDeclarator)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)));
                        ((ArrayDeclarator)CUP$result).fixed_array_size_list = (/*fasl*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // fixed_point_type ::= FIXED LESSTHAN positive_int_const COMMA positive_int_const GREATERTHAN 
            {
              CUP$result = new FixedPointType(/*fixed_point_type*/74);
              
                ((FixedPointType)CUP$result).digit_expr = (/*digits*/(PosIntConst)CUP$stack.elementAt(CUP$top-3)).const_expr;
                ((FixedPointType)CUP$result).scale_expr = (/*scale*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr;
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // string_type ::= WSTRING 
            {
              CUP$result = new StringType(/*string_type*/72);
               ((StringType)CUP$result).setWide(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // string_type ::= STRING 
            {
              CUP$result = new StringType(/*string_type*/72);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // string_type ::= WSTRING LESSTHAN positive_int_const GREATERTHAN 
            {
              CUP$result = new StringType(/*string_type*/72);
              
                ((StringType)CUP$result).setSize((/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr);
                ((StringType)CUP$result).setWide();
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // string_type ::= STRING LESSTHAN positive_int_const GREATERTHAN 
            {
              CUP$result = new StringType(/*string_type*/72);
              
               ((StringType)CUP$result).setSize((/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr);
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // sequence_type ::= SEQUENCE LESSTHAN simple_type_spec GREATERTHAN 
            {
              CUP$result = new SequenceType(/*sequence_type*/73);
              
                        ((SequenceType)CUP$result).setTypeSpec( (/*sts*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-1)) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // sequence_type ::= SEQUENCE LESSTHAN simple_type_spec COMMA positive_int_const GREATERTHAN 
            {
              CUP$result = new SequenceType(/*sequence_type*/73);
              
                        ((SequenceType)CUP$result).max = (/*pic*/(PosIntConst)CUP$stack.elementAt(CUP$top-1)).const_expr;
                        ((SequenceType)CUP$result).setTypeSpec( (/*sts*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-3)) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // native_type ::= NATIVE simple_declarator 
            {
              CUP$result = new NativeType(/*native_type*/54);
              
                        ((NativeType)CUP$result).declarator = (/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // enumerator_list ::= ID COMMA enumerator_list 
            {
              CUP$result = new SymbolList(/*enumerator_list*/97);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*el*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)).str_val,0);
                        ((SymbolList)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // enumerator_list ::= ID 
            {
              CUP$result = new SymbolList(/*enumerator_list*/97);
              
                        ((SymbolList)CUP$result).v.insertElementAt((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val,0);
                        ((SymbolList)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // enum_type ::= ENUM ID LCBRACE enumerator_list RCBRACE 
            {
              CUP$result = new EnumType(/*enum_type*/50);
              
                        ((EnumType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));
                        ((EnumType)CUP$result).enumlist = (/*el*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                        ((EnumType)CUP$result).set_included( parser.include_state );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // element_spec ::= type_spec declarator 
            {
              CUP$result = new ElementSpec(/*element_spec*/57);
              
                        ((ElementSpec)CUP$result).typeSpec.type_spec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((ElementSpec)CUP$result).declarator = (/*dc*/(Declarator)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // case_label_list ::= DEFAULT COLON case_label_list 
            {
              CUP$result = new SymbolList(/*case_label_list*/89);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*cll*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.addElement(null);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // case_label_list ::= CASE const_expr COLON case_label_list 
            {
              CUP$result = new SymbolList(/*case_label_list*/89);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*cll*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.addElement((/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-2)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // case_label_list ::= DEFAULT COLON 
            {
              CUP$result = new SymbolList(/*case_label_list*/89);
               ((SymbolList)CUP$result).v.addElement( null ); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // case_label_list ::= CASE const_expr COLON 
            {
              CUP$result = new SymbolList(/*case_label_list*/89);
               ((SymbolList)CUP$result).v.addElement((/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // case ::= case_label_list element_spec SEMI 
            {
              CUP$result = new Case(/*case*/56);
              
                        ((Case)CUP$result).element_spec = (/*es*/(ElementSpec)CUP$stack.elementAt(CUP$top-1));
                        ((Case)CUP$result).case_label_list = (/*c*/(SymbolList)CUP$stack.elementAt(CUP$top-2));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // switch_body ::= case switch_body 
            {
              CUP$result = new SwitchBody(/*switch_body*/55);
              
                ((SwitchBody)CUP$result).caseListVector = (Vector)(/*sb*/(SwitchBody)CUP$stack.elementAt(CUP$top-0)).caseListVector.clone();
                ((SwitchBody)CUP$result).caseListVector.insertElementAt((/*c*/(Case)CUP$stack.elementAt(CUP$top-1)), 0);
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // switch_body ::= case 
            {
              CUP$result = new SwitchBody(/*switch_body*/55);
              
                ((SwitchBody)CUP$result).caseListVector.insertElementAt((/*c*/(Case)CUP$stack.elementAt(CUP$top-0)), 0);
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // switch_type_spec ::= scopename 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).type_spec = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // switch_type_spec ::= enum_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).set_constr((/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // switch_type_spec ::= bool_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).type_spec = (/*b*/(BooleanType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // switch_type_spec ::= char_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).type_spec = (/*c*/(CharType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // switch_type_spec ::= int_type 
            {
              CUP$result = new TypeSpec(/*switch_type_spec*/45);
               ((TypeSpec)CUP$result).type_spec = (/*i*/(IntType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // union_type ::= UNION ID 
            {
              CUP$result = new UnionType(/*union_type*/53);
              
                        ((UnionType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                        parser.closeScope( (Scope)((UnionType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // union_type ::= UNION ID SWITCH LPAREN switch_type_spec RPAREN LCBRACE switch_body RCBRACE 
            {
              CUP$result = new UnionType(/*union_type*/53);
              
                        ((UnionType)CUP$result).setSwitchType( (/*s*/(TypeSpec)CUP$stack.elementAt(CUP$top-4)) );
                        ((UnionType)CUP$result).setSwitchBody( (/*sb*/(SwitchBody)CUP$stack.elementAt(CUP$top-1)) );
                        ((UnionType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-7)));
                        ((UnionType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((UnionType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // member ::= type_spec declarators SEMI 
            {
              CUP$result = new Member(/*member*/77);
              
                        ((Member)CUP$result).type_spec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-2));
                        ((Member)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // member_list ::= member member_list 
            {
              CUP$result = new MemberList(/*member_list*/88);
              
                        ((MemberList)CUP$result).v = (Vector)(/*ml*/(MemberList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((MemberList)CUP$result).v.insertElementAt((/*m*/(Member)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // member_list ::= member 
            {
              CUP$result = new MemberList(/*member_list*/88);
              
                        ((MemberList)CUP$result).v.insertElementAt((/*m*/(Member)CUP$stack.elementAt(CUP$top-0)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // struct_type ::= STRUCT ID 
            {
              CUP$result = new StructType(/*struct_type*/51);
              
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                        parser.closeScope( (Scope)((StructType)CUP$result) );
               
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // struct_type ::= STRUCT ID LCBRACE member_list RCBRACE 
            {
              CUP$result = new StructType(/*struct_type*/51);
              
                        ((StructType)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));
                        ((StructType)CUP$result).exc = false;
                        ((StructType)CUP$result).set_memberlist( (/*ml*/(MemberList)CUP$stack.elementAt(CUP$top-1)) );
                        ((StructType)CUP$result).set_included( parser.include_state );
                        parser.closeScope( (Scope)((StructType)CUP$result) );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // any_type ::= ANY 
            {
              CUP$result = new AnyType(/*any_type*/70);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // octet_type ::= OCTET 
            {
              CUP$result = new OctetType(/*octet_type*/69);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // bool_type ::= BOOLEAN 
            {
              CUP$result = new BooleanType(/*bool_type*/68);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // char_type ::= WCHAR 
            {
              CUP$result = new CharType(/*char_type*/67);
               ((CharType)CUP$result).setWide(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // char_type ::= CHAR 
            {
              CUP$result = new CharType(/*char_type*/67);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // long_long_type ::= LONG LONG 
            {
              CUP$result = new LongLongType(/*long_long_type*/66);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // long_type ::= LONG 
            {
              CUP$result = new LongType(/*long_type*/65);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // short_type ::= SHORT 
            {
              CUP$result = new ShortType(/*short_type*/64);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // int_type ::= UNSIGNED short_type 
            {
              CUP$result = new IntType(/*int_type*/59);
              
                        ((IntType)CUP$result).type_spec = (/*s*/(ShortType)CUP$stack.elementAt(CUP$top-0));
                        ((IntType)CUP$result).setUnsigned();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // int_type ::= short_type 
            {
              CUP$result = new IntType(/*int_type*/59);
              
                        ((IntType)CUP$result).type_spec = (/*s*/(ShortType)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // int_type ::= UNSIGNED long_long_type 
            {
              CUP$result = new IntType(/*int_type*/59);
              
                        ((IntType)CUP$result).type_spec = (/*l*/(LongLongType)CUP$stack.elementAt(CUP$top-0));
                        ((IntType)CUP$result).setUnsigned();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // int_type ::= UNSIGNED long_type 
            {
              CUP$result = new IntType(/*int_type*/59);
              
                        ((IntType)CUP$result).type_spec = (/*l*/(LongType)CUP$stack.elementAt(CUP$top-0));
                        ((IntType)CUP$result).setUnsigned();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // int_type ::= long_long_type 
            {
              CUP$result = new IntType(/*int_type*/59);
              
                        ((IntType)CUP$result).type_spec = (/*ll*/(LongLongType)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // int_type ::= long_type 
            {
              CUP$result = new IntType(/*int_type*/59);
              
                        ((IntType)CUP$result).type_spec = (/*l*/(LongType)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // double_type ::= LONG DOUBLE 
            {
              CUP$result = new DoubleType(/*double_type*/63);
              
                ((DoubleType)CUP$result).setLongDouble();
                lexer.emit_warn("IDL type long double not supported by standard IDL/Java mappings!");
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // double_type ::= DOUBLE 
            {
              CUP$result = new DoubleType(/*double_type*/63);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // fixed_pt_const_type ::= FIXED 
            {
              CUP$result = new FixedPointConstType(/*fixed_pt_const_type*/62);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // float_type ::= FLOAT 
            {
              CUP$result = new FloatType(/*float_type*/61);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // float_pt_type ::= double_type 
            {
              CUP$result = new FloatPtType(/*float_pt_type*/60);
               ((FloatPtType)CUP$result).type_spec = (/*d*/(DoubleType)CUP$stack.elementAt(CUP$top-0));
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // float_pt_type ::= float_type 
            {
              CUP$result = new FloatPtType(/*float_pt_type*/60);
              ((FloatPtType)CUP$result).type_spec = (/*f*/(FloatType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // simple_declarator ::= ID 
            {
              CUP$result = new SimpleDeclarator(/*simple_declarator*/79);
              
                        ((SimpleDeclarator)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // declarator ::= array_declarator 
            {
              CUP$result = new Declarator(/*declarator*/78);
               ((Declarator)CUP$result).d = (/*s*/(ArrayDeclarator)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // declarator ::= simple_declarator 
            {
              CUP$result = new Declarator(/*declarator*/78);
               ((Declarator)CUP$result).d = (/*s*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // declarators ::= declarator 
            {
              CUP$result = new SymbolList(/*declarators*/95);
              
                        ((SymbolList)CUP$result).v.insertElementAt((/*d*/(Declarator)CUP$stack.elementAt(CUP$top-0)),0);
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // declarators ::= declarator COMMA declarators 
            {
              CUP$result = new SymbolList(/*declarators*/95);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt((/*d*/(Declarator)CUP$stack.elementAt(CUP$top-2)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // constr_type_spec ::= enum_type 
            {
              CUP$result = new ConstrTypeSpec(/*constr_type_spec*/49);
              
                        ((ConstrTypeSpec)CUP$result).c_type_spec = (/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0));
                        ((ConstrTypeSpec)CUP$result).set_token((/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // constr_type_spec ::= union_type 
            {
              CUP$result = new ConstrTypeSpec(/*constr_type_spec*/49);
              
                        ((ConstrTypeSpec)CUP$result).c_type_spec = (/*u*/(UnionType)CUP$stack.elementAt(CUP$top-0));
                        ((ConstrTypeSpec)CUP$result).set_token((/*u*/(UnionType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // constr_type_spec ::= struct_type 
            {
              CUP$result = new ConstrTypeSpec(/*constr_type_spec*/49);
              
                        ((ConstrTypeSpec)CUP$result).c_type_spec = (/*s*/(StructType)CUP$stack.elementAt(CUP$top-0));
                        ((ConstrTypeSpec)CUP$result).set_token((/*s*/(StructType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // template_type_spec ::= fixed_point_type 
            {
              CUP$result = new TemplateTypeSpec(/*template_type_spec*/48);
              
                        ((TemplateTypeSpec)CUP$result).type_spec = (/*f*/(FixedPointType)CUP$stack.elementAt(CUP$top-0));
                        ((TemplateTypeSpec)CUP$result).set_token((/*f*/(FixedPointType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // template_type_spec ::= string_type 
            {
              CUP$result = new TemplateTypeSpec(/*template_type_spec*/48);
              
                        ((TemplateTypeSpec)CUP$result).type_spec = (/*s*/(StringType)CUP$stack.elementAt(CUP$top-0));
                        ((TemplateTypeSpec)CUP$result).set_token((/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // template_type_spec ::= sequence_type 
            {
              CUP$result = new TemplateTypeSpec(/*template_type_spec*/48);
              
                        ((TemplateTypeSpec)CUP$result).type_spec = (/*s*/(SequenceType)CUP$stack.elementAt(CUP$top-0));
                        ((TemplateTypeSpec)CUP$result).set_token((/*s*/(SequenceType)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // base_type_spec ::= VALUEBASE 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = new ValueBase(sym.VALUEBASE); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // base_type_spec ::= any_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(AnyType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // base_type_spec ::= octet_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(OctetType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // base_type_spec ::= bool_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(BooleanType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // base_type_spec ::= char_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(CharType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // base_type_spec ::= int_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
              
                        ((BaseType)CUP$result).type_spec = (/*s*/(IntType)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // base_type_spec ::= float_pt_type 
            {
              CUP$result = new BaseType(/*base_type_spec*/58);
               ((BaseType)CUP$result).type_spec = (/*s*/(FloatPtType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // simple_type_spec ::= scopename 
            {
              CUP$result = new SimpleTypeSpec(/*simple_type_spec*/47);
              
                        ((SimpleTypeSpec)CUP$result).type_spec = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0));
                        ((SimpleTypeSpec)CUP$result).set_token((/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // simple_type_spec ::= template_type_spec 
            {
              CUP$result = new SimpleTypeSpec(/*simple_type_spec*/47);
              
                        ((SimpleTypeSpec)CUP$result).type_spec = (/*s*/(TemplateTypeSpec)CUP$stack.elementAt(CUP$top-0));
                        ((SimpleTypeSpec)CUP$result).set_token((/*s*/(TemplateTypeSpec)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // simple_type_spec ::= base_type_spec 
            {
              CUP$result = new SimpleTypeSpec(/*simple_type_spec*/47);
              
                        ((SimpleTypeSpec)CUP$result).type_spec = (/*s*/(BaseType)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // type_spec ::= constr_type_spec 
            {
              CUP$result = new TypeSpec(/*type_spec*/42);
              
                        ((TypeSpec)CUP$result).type_spec = (/*s*/(ConstrTypeSpec)CUP$stack.elementAt(CUP$top-0));
                        ((TypeSpec)CUP$result).set_token((/*s*/(ConstrTypeSpec)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // type_spec ::= simple_type_spec 
            {
              CUP$result = new TypeSpec(/*type_spec*/42);
              
                        ((TypeSpec)CUP$result).type_spec = (/*s*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-0));
                        ((TypeSpec)CUP$result).set_token((/*s*/(SimpleTypeSpec)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // type_declarator ::= type_spec declarators 
            {
              CUP$result = new TypeDeclarator(/*type_declarator*/41);
              
                        ((TypeDeclarator)CUP$result).type_spec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((TypeDeclarator)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // type_def ::= TYPEDEF type_declarator 
            {
              CUP$result = new TypeDef(/*type_def*/46);
              
                ((TypeDef)CUP$result).type_declarator = (/*t*/(TypeDeclarator)CUP$stack.elementAt(CUP$top-0));
                ((TypeDef)CUP$result).set_included( parser.include_state );
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // type_dcl ::= native_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*n*/(NativeType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // type_dcl ::= enum_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*e*/(EnumType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // type_dcl ::= union_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*u*/(UnionType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // type_dcl ::= struct_type 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*s*/(StructType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // type_dcl ::= type_def 
            {
              CUP$result = new TypeDeclaration(/*type_dcl*/40);
               ((TypeDeclaration)CUP$result).type_decl = (/*t*/(TypeDef)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // positive_int_const ::= const_expr 
            {
              CUP$result = new PosIntConst(/*positive_int_const*/31);
               ((PosIntConst)CUP$result).setExpression( (/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-0)) ); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // string_literal ::= LDBLQUOTE DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/76);
              
                        ((Literal)CUP$result).string = "\"\"";
                        ((Literal)CUP$result).wide = true;
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // string_literal ::= LDBLQUOTE ID DBLQUOTE LDBLQUOTE ID DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/76);
              
                        ((Literal)CUP$result).string = "\"" + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val + (/*j*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val + "\"";
                        ((Literal)CUP$result).wide = true;
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // string_literal ::= LDBLQUOTE ID DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/76);
              
                        ((Literal)CUP$result).string = "\"" + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val + "\"";
                        ((Literal)CUP$result).wide = true;
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // string_literal ::= DBLQUOTE DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/76);
               ((Literal)CUP$result).string = "\"\""; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // string_literal ::= DBLQUOTE ID DBLQUOTE DBLQUOTE ID DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/76);
               ((Literal)CUP$result).string = "\"" + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val + (/*j*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val + "\""; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // string_literal ::= DBLQUOTE ID DBLQUOTE 
            {
              CUP$result = new Literal(/*string_literal*/76);
               ((Literal)CUP$result).string = "\"" + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val + "\""; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // literal ::= FALSE 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "false";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // literal ::= TRUE 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "true";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // literal ::= FLOAT_NUMBER 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "" + (/*n*/(org.jacorb.idl.runtime.float_token)CUP$stack.elementAt(CUP$top-0)).float_val ;
                        ((Literal)CUP$result).primitiveToken = (/*n*/(org.jacorb.idl.runtime.float_token)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // literal ::= FIXED_NUMBER 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "" + (/*f*/(fixed_token)CUP$stack.elementAt(CUP$top-0)).fixed_val;
                        ((Literal)CUP$result).primitiveToken = (/*f*/(fixed_token)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // literal ::= string_literal 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = (/*s*/(Literal)CUP$stack.elementAt(CUP$top-0)).string;
                        ((Literal)CUP$result).wide = (/*s*/(Literal)CUP$stack.elementAt(CUP$top-0)).wide;
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // literal ::= QUOTE CH QUOTE 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "\'" + (/*c*/(org.jacorb.idl.runtime.char_token)CUP$stack.elementAt(CUP$top-1)).char_val + "\'";
                        ((Literal)CUP$result).primitiveToken = (/*c*/(org.jacorb.idl.runtime.char_token)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // literal ::= LONG_NUMBER 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "" + (/*l*/(org.jacorb.idl.runtime.long_token)CUP$stack.elementAt(CUP$top-0)).long_val;
                        ((Literal)CUP$result).primitiveToken = (/*l*/(org.jacorb.idl.runtime.long_token)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // literal ::= NUMBER 
            {
              CUP$result = new Literal(/*literal*/75);
              
                        ((Literal)CUP$result).string = "" + (/*n*/(org.jacorb.idl.runtime.int_token)CUP$stack.elementAt(CUP$top-0)).int_val;
                        ((Literal)CUP$result).primitiveToken = (/*n*/(org.jacorb.idl.runtime.int_token)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // primary_expr ::= LPAREN const_expr RPAREN 
            {
              CUP$result = new PrimaryExpr(/*primary_expr*/39);
               ((PrimaryExpr)CUP$result).symbol = (/*c*/(ConstExpr)CUP$stack.elementAt(CUP$top-1)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // primary_expr ::= literal 
            {
              CUP$result = new PrimaryExpr(/*primary_expr*/39);
               ((PrimaryExpr)CUP$result).symbol = (/*l*/(Literal)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // primary_expr ::= scopename 
            {
              CUP$result = new PrimaryExpr(/*primary_expr*/39);
               ((PrimaryExpr)CUP$result).symbol = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // unary_op ::= TILDE 
            {
              CUP$result = new org.jacorb.idl.runtime.str_token(/*unary_op*/6);
               ((org.jacorb.idl.runtime.str_token)CUP$result).str_val = "~"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // unary_op ::= PLUS 
            {
              CUP$result = new org.jacorb.idl.runtime.str_token(/*unary_op*/6);
               ((org.jacorb.idl.runtime.str_token)CUP$result).str_val = "+"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // unary_op ::= MINUS 
            {
              CUP$result = new org.jacorb.idl.runtime.str_token(/*unary_op*/6);
               ((org.jacorb.idl.runtime.str_token)CUP$result).str_val = "-"; 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // unary_expr ::= primary_expr 
            {
              CUP$result = new UnaryExpr(/*unary_expr*/38);
               ((UnaryExpr)CUP$result).primary_expr = (/*p*/(PrimaryExpr)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // unary_expr ::= unary_op primary_expr 
            {
              CUP$result = new UnaryExpr(/*unary_expr*/38);
              
                        ((UnaryExpr)CUP$result).primary_expr = (/*p*/(PrimaryExpr)CUP$stack.elementAt(CUP$top-0));
                        ((UnaryExpr)CUP$result).unary_op = (/*u*/(org.jacorb.idl.runtime.str_token)CUP$stack.elementAt(CUP$top-1)).str_val;
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // mult_expr ::= mult_expr PERCENT unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/37);
              
                        ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0));
                        ((MultExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-2));
                        ((MultExpr)CUP$result).operator = "%";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // mult_expr ::= mult_expr SLASH unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/37);
              
                        ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0));
                        ((MultExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-2));
                        ((MultExpr)CUP$result).operator = "/";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // mult_expr ::= mult_expr STAR unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/37);
              
                        ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0));
                        ((MultExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-2));
                        ((MultExpr)CUP$result).operator = "*";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // mult_expr ::= unary_expr 
            {
              CUP$result = new MultExpr(/*mult_expr*/37);
               ((MultExpr)CUP$result).unary_expr = (/*u*/(UnaryExpr)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // add_expr ::= add_expr MINUS mult_expr 
            {
              CUP$result = new AddExpr(/*add_expr*/36);
              
                        ((AddExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-2));
                        ((AddExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-0));
                        ((AddExpr)CUP$result).operator = "-";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // add_expr ::= add_expr PLUS mult_expr 
            {
              CUP$result = new AddExpr(/*add_expr*/36);
              
                        ((AddExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-2));
                        ((AddExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-0));
                        ((AddExpr)CUP$result).operator = "+";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // add_expr ::= mult_expr 
            {
              CUP$result = new AddExpr(/*add_expr*/36);
              
                        ((AddExpr)CUP$result).mult_expr = (/*m*/(MultExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // shift_expr ::= shift_expr RSHIFT add_expr 
            {
              CUP$result = new ShiftExpr(/*shift_expr*/35);
              
                        ((ShiftExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-0));
                        ((ShiftExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-2));
                        ((ShiftExpr)CUP$result).operator = ">>";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // shift_expr ::= shift_expr LSHIFT add_expr 
            {
              CUP$result = new ShiftExpr(/*shift_expr*/35);
              
                        ((ShiftExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-0));
                        ((ShiftExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-2));
                        ((ShiftExpr)CUP$result).operator = "<<";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // shift_expr ::= add_expr 
            {
              CUP$result = new ShiftExpr(/*shift_expr*/35);
              
                        ((ShiftExpr)CUP$result).add_expr = (/*a*/(AddExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // and_expr ::= and_expr AMPERSAND shift_expr 
            {
              CUP$result = new AndExpr(/*and_expr*/34);
              
                        ((AndExpr)CUP$result).and_expr = (/*a*/(AndExpr)CUP$stack.elementAt(CUP$top-2));
                        ((AndExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // and_expr ::= shift_expr 
            {
              CUP$result = new AndExpr(/*and_expr*/34);
              
                        ((AndExpr)CUP$result).shift_expr = (/*s*/(ShiftExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // xor_expr ::= xor_expr CIRCUM and_expr 
            {
              CUP$result = new XorExpr(/*xor_expr*/33);
              
                        ((XorExpr)CUP$result).and_expr = (/*a*/(AndExpr)CUP$stack.elementAt(CUP$top-0));
                        ((XorExpr)CUP$result).xor_expr = (/*x*/(XorExpr)CUP$stack.elementAt(CUP$top-2));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // xor_expr ::= and_expr 
            {
              CUP$result = new XorExpr(/*xor_expr*/33);
              
                        ((XorExpr)CUP$result).and_expr = (/*a*/(AndExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // or_expr ::= or_expr BAR xor_expr 
            {
              CUP$result = new OrExpr(/*or_expr*/32);
              
                        ((OrExpr)CUP$result).or_expr = (/*o*/(OrExpr)CUP$stack.elementAt(CUP$top-2));
                        ((OrExpr)CUP$result).xor_expr = (/*x*/(XorExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // or_expr ::= xor_expr 
            {
              CUP$result = new OrExpr(/*or_expr*/32);
              
                        ((OrExpr)CUP$result).xor_expr = (/*x*/(XorExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // const_expr ::= or_expr 
            {
              CUP$result = new ConstExpr(/*const_expr*/30);
              
                        ((ConstExpr)CUP$result).or_expr = (/*o*/(OrExpr)CUP$stack.elementAt(CUP$top-0));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // const_type ::= scopename 
            {
              CUP$result = new ConstType(/*const_type*/29);
              
                        ((ConstType)CUP$result).symbol = (/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0));
                        ((ConstType)CUP$result).set_token((/*s*/(ScopedName)CUP$stack.elementAt(CUP$top-0)).get_token());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // const_type ::= octet_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(OctetType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // const_type ::= string_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(StringType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // const_type ::= fixed_pt_const_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(FixedPointConstType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // const_type ::= float_pt_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(FloatPtType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // const_type ::= bool_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(BooleanType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // const_type ::= char_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(CharType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // const_type ::= int_type 
            {
              CUP$result = new ConstType(/*const_type*/29);
               ((ConstType)CUP$result).symbol = (/*s*/(IntType)CUP$stack.elementAt(CUP$top-0)); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // const_dcl ::= CONST const_type ID EQUALS const_expr 
            {
              CUP$result = new ConstDecl(/*const_dcl*/28);
              
                        ((ConstDecl)CUP$result).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)).str_val);
                        ((ConstDecl)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-2)));
                        ((ConstDecl)CUP$result).const_expr = (/*ce*/(ConstExpr)CUP$stack.elementAt(CUP$top-0));
                        ((ConstDecl)CUP$result).const_type = (ConstType)(/*ct*/(ConstType)CUP$stack.elementAt(CUP$top-3));
                        ((ConstDecl)CUP$result).set_included( parser.include_state );
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // init_param_decl ::= IN param_type_spec simple_declarator 
            {
              CUP$result = new InitParamDecl(/*init_param_decl*/27);
              
                        ((InitParamDecl)CUP$result).paramTypeSpec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-1));
                        ((InitParamDecl)CUP$result).simple_declarator = (/*sd*/(SimpleDeclarator)CUP$stack.elementAt(CUP$top-0));
                  
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // init_param_decls ::= init_param_decl COMMA init_param_decls 
            {
              CUP$result = new SymbolList(/*init_param_decls*/91);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*ipdcls*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((SymbolList)CUP$result).v.insertElementAt( (/*ip*/(InitParamDecl)CUP$stack.elementAt(CUP$top-2)), 0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // init_param_decls ::= init_param_decl 
            {
              CUP$result = new SymbolList(/*init_param_decls*/91);
              
                        ((SymbolList)CUP$result).v.insertElementAt( (/*ip*/(InitParamDecl)CUP$stack.elementAt(CUP$top-0)), 0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // init_dcl ::= FACTORY ID LPAREN RPAREN raises_expr SEMI 
            {
              CUP$result = new InitDecl(/*init_dcl*/26);
              
                        ((InitDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val;
                        ((InitDecl)CUP$result).raisesExpr = (/*re*/(RaisesExpr)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // init_dcl ::= FACTORY ID LPAREN init_param_decls RPAREN raises_expr SEMI 
            {
              CUP$result = new InitDecl(/*init_dcl*/26);
              
                        ((InitDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-5)).str_val;
                        ((InitDecl)CUP$result).paramDecls = (Vector)(/*ipd*/(SymbolList)CUP$stack.elementAt(CUP$top-3)).v.clone();
                        ((InitDecl)CUP$result).raisesExpr = (/*re*/(RaisesExpr)CUP$stack.elementAt(CUP$top-1));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // state_member ::= PRIVATE type_spec declarators SEMI 
            {
              CUP$result = new StateMember(/*state_member*/25);
              
                           ((StateMember)CUP$result).isPublic    = false;
                           ((StateMember)CUP$result).type_spec   = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-2));
                           ((StateMember)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                  
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // state_member ::= PUBLIC type_spec declarators SEMI 
            {
              CUP$result = new StateMember(/*state_member*/25);
              
                           ((StateMember)CUP$result).isPublic    = true;
                           ((StateMember)CUP$result).type_spec   = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-2));
                           ((StateMember)CUP$result).declarators = (/*ds*/(SymbolList)CUP$stack.elementAt(CUP$top-1));
                  
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // value_element ::= init_dcl 
            {
              CUP$result = new Definition(/*value_element*/24);
              
                        ((Definition)CUP$result).set_declaration ((/*id*/(InitDecl)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // value_element ::= state_member 
            {
              CUP$result = new Definition(/*value_element*/24);
              
                        ((Definition)CUP$result).set_declaration ((/*sm*/(StateMember)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // value_element ::= export 
            {
              CUP$result = new Definition(/*value_element*/24);
              
                        ((Definition)CUP$result).set_declaration ((/*e*/(Definition)CUP$stack.elementAt(CUP$top-0)).get_declaration());
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // value_elements ::= empty 
            {
              CUP$result = new Definitions(/*value_elements*/23);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // value_elements ::= value_element value_elements 
            {
              CUP$result = new Definitions(/*value_elements*/23);
              
                        ((Definitions)CUP$result).v = (Vector)(/*es*/(Definitions)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((Definitions)CUP$result).v.insertElementAt((/*e*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // truncatable ::= TRUNCATABLE 
            {
              CUP$result = new Truncatable(/*truncatable*/16);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // value_inheritance_spec ::= empty 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // value_inheritance_spec ::= COLON 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
                        lexer.emit_warn("Illegal IDL: empty inheritance spec after colon!");
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // value_inheritance_spec ::= COLON scopename_list SUPPORTS scopename_list 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
                        ((ValueInheritanceSpec)CUP$result).v = (Vector)(/*vn*/(SymbolList)CUP$stack.elementAt(CUP$top-2)).v.clone();
                        ((ValueInheritanceSpec)CUP$result).supports = (Vector)(/*interface_names*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // value_inheritance_spec ::= COLON truncatable scopename_list SUPPORTS scopename_list 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
                        ((ValueInheritanceSpec)CUP$result).truncatable = (/*t*/(Truncatable)CUP$stack.elementAt(CUP$top-3));
                        ((ValueInheritanceSpec)CUP$result).truncatable.scopedName = (ScopedName)(/*vn*/(SymbolList)CUP$stack.elementAt(CUP$top-2)).v.remove(0);
                        ((ValueInheritanceSpec)CUP$result).v = (Vector)(/*vn*/(SymbolList)CUP$stack.elementAt(CUP$top-2)).v.clone();
                        ((ValueInheritanceSpec)CUP$result).supports = (Vector)(/*interface_names*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // value_inheritance_spec ::= SUPPORTS scopename_list 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
                        ((ValueInheritanceSpec)CUP$result).supports = (Vector)(/*interface_names*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // value_inheritance_spec ::= COLON scopename_list 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
                        ((ValueInheritanceSpec)CUP$result).v = (Vector)(/*vn*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // value_inheritance_spec ::= COLON truncatable scopename_list 
            {
              CUP$result = new ValueInheritanceSpec(/*value_inheritance_spec*/22);
              
                        ((ValueInheritanceSpec)CUP$result).truncatable = (/*t*/(Truncatable)CUP$stack.elementAt(CUP$top-1));
                        ((ValueInheritanceSpec)CUP$result).truncatable.scopedName = (ScopedName)(/*vn*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.remove(0);
                        ((ValueInheritanceSpec)CUP$result).v = (Vector)(/*vn*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // value_dcl ::= VALUETYPE ID value_inheritance_spec LCBRACE value_elements RCBRACE 
            {
              CUP$result = new ValueDecl(/*value_dcl*/19);
              
                        ((ValueDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val;
                        ((ValueDecl)CUP$result).set_token ((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                        ((ValueDecl)CUP$result).setInheritanceSpec ((/*is*/(ValueInheritanceSpec)CUP$stack.elementAt(CUP$top-3)));
                        ((ValueDecl)CUP$result).setValueElements ((/*ve*/(Definitions)CUP$stack.elementAt(CUP$top-1)));
                        ((ValueDecl)CUP$result).isCustomMarshalled (false);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // value_dcl ::= VALUETYPE ID 
            {
              CUP$result = new ValueDecl(/*value_dcl*/19);
              
                        ((ValueDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val;
                        ((ValueDecl)CUP$result).set_token ((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                        ((ValueDecl)CUP$result).isCustomMarshalled (false);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // value_dcl ::= CUSTOM VALUETYPE ID value_inheritance_spec LCBRACE value_elements RCBRACE 
            {
              CUP$result = new ValueDecl(/*value_dcl*/19);
              
                        ((ValueDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val;
                        ((ValueDecl)CUP$result).set_token ((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                        ((ValueDecl)CUP$result).setInheritanceSpec ((/*is*/(ValueInheritanceSpec)CUP$stack.elementAt(CUP$top-3)));
                        ((ValueDecl)CUP$result).setValueElements ((/*ve*/(Definitions)CUP$stack.elementAt(CUP$top-1)));
                        ((ValueDecl)CUP$result).isCustomMarshalled (true);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // value_body ::= empty 
            {
              CUP$result = new ValueBody(/*value_body*/21);
               ((ValueBody)CUP$result).commit(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // value_body ::= export value_body 
            {
              CUP$result = new ValueBody(/*value_body*/21);
              
                        ((ValueBody)CUP$result).v = (Vector)(/*vb*/(ValueBody)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((ValueBody)CUP$result).v.insertElementAt((/*e*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // value_abs_dcl ::= ABSTRACT VALUETYPE ID 
            {
              CUP$result = new ValueAbsDecl(/*value_abs_dcl*/20);
              
                        ((ValueAbsDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val;
                        ((ValueAbsDecl)CUP$result).set_token ((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // value_abs_dcl ::= ABSTRACT VALUETYPE ID value_inheritance_spec LCBRACE value_body RCBRACE 
            {
              CUP$result = new ValueAbsDecl(/*value_abs_dcl*/20);
              
                        ((ValueAbsDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val;
                        ((ValueAbsDecl)CUP$result).setInheritanceSpec( (/*is*/(ValueInheritanceSpec)CUP$stack.elementAt(CUP$top-3)) );
                        ((ValueAbsDecl)CUP$result).body = (/*b*/(ValueBody)CUP$stack.elementAt(CUP$top-1));
                        (/*b*/(ValueBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                        (/*b*/(ValueBody)CUP$stack.elementAt(CUP$top-1)).myAbsValue = ((ValueAbsDecl)CUP$result);
                        (/*b*/(ValueBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((ValueAbsDecl)CUP$result));
                        ((ValueAbsDecl)CUP$result).set_token ((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // value_box_dcl ::= VALUETYPE ID type_spec 
            {
              CUP$result = new ValueBoxDecl(/*value_box_dcl*/18);
              
                        ((ValueBoxDecl)CUP$result).name = (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val;
                        ((ValueBoxDecl)CUP$result).typeSpec = (/*ts*/(TypeSpec)CUP$stack.elementAt(CUP$top-0));
                        ((ValueBoxDecl)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // value ::= value_box_dcl 
            {
              CUP$result = new Value(/*value*/17);
              
                        ((Value)CUP$result).setValue ((/*vbx*/(ValueBoxDecl)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // value ::= value_abs_dcl 
            {
              CUP$result = new Value(/*value*/17);
              
                        ((Value)CUP$result).setValue ((/*vad*/(ValueAbsDecl)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // value ::= value_dcl 
            {
              CUP$result = new Value(/*value*/17);
              
                        ((Value)CUP$result).setValue ((/*vd*/(ValueDecl)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // scopename ::= OBJECT 
            {
              CUP$result = new ScopedName(/*scopename*/15);
              
                        ((ScopedName)CUP$result).typeName = "org.omg.CORBA.Object";
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // scopename ::= scopename DBLCOLON ID 
            {
              CUP$result = new ScopedName(/*scopename*/15);
              
                        ((ScopedName)CUP$result).setId( (/*sn*/(ScopedName)CUP$stack.elementAt(CUP$top-2)).typeName+ "." + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val );
                        ((ScopedName)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // scopename ::= DBLCOLON ID 
            {
              CUP$result = new ScopedName(/*scopename*/15);
              
                        ((ScopedName)CUP$result).setId( "." + (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val);
                        ((ScopedName)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // scopename ::= ID 
            {
              CUP$result = new ScopedName(/*scopename*/15);
              
                        ((ScopedName)CUP$result).setId( (/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)).str_val );
                        ((ScopedName)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // scopename_list ::= scopename 
            {
              CUP$result = new SymbolList(/*scopename_list*/93);
               ((SymbolList)CUP$result).v.insertElementAt((/*sn*/(ScopedName)CUP$stack.elementAt(CUP$top-0)),0); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // scopename_list ::= scopename COMMA scopename_list 
            {
              CUP$result = new SymbolList(/*scopename_list*/93);
              
                ((SymbolList)CUP$result).v = (Vector)(/*snl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                ((SymbolList)CUP$result).v.insertElementAt((/*sn*/(ScopedName)CUP$stack.elementAt(CUP$top-2)),0);
            
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // inheritance_spec ::= empty 
            {
              CUP$result = new SymbolList(/*inheritance_spec*/96);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // inheritance_spec ::= COLON 
            {
              CUP$result = new SymbolList(/*inheritance_spec*/96);
              
                        lexer.emit_warn("Illegal IDL: empty inheritance spec after colon!");
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // inheritance_spec ::= COLON scopename_list 
            {
              CUP$result = new SymbolList(/*inheritance_spec*/96);
              
                        ((SymbolList)CUP$result).v = (Vector)(/*sl*/(SymbolList)CUP$stack.elementAt(CUP$top-0)).v.clone();
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // export ::= op_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/14);
               ((Definition)CUP$result).set_declaration((/*o*/(OpDecl)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // export ::= attr_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/14);
               ((Definition)CUP$result).set_declaration((/*a*/(AttrDecl)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // export ::= except_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/14);
               ((Definition)CUP$result).set_declaration((/*e*/(StructType)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // export ::= const_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/14);
               ((Definition)CUP$result).set_declaration((/*c*/(ConstDecl)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // export ::= type_dcl SEMI 
            {
              CUP$result = new Definition(/*export*/14);
               ((Definition)CUP$result).set_declaration((/*t*/(TypeDeclaration)CUP$stack.elementAt(CUP$top-1))); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // interface_body ::= empty 
            {
              CUP$result = new InterfaceBody(/*interface_body*/13);
               ((InterfaceBody)CUP$result).commit(); 
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // interface_body ::= export interface_body 
            {
              CUP$result = new InterfaceBody(/*interface_body*/13);
              
                        ((InterfaceBody)CUP$result).v = (Vector)(/*i*/(InterfaceBody)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((InterfaceBody)CUP$result).v.insertElementAt((/*e*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // interface ::= PSEUDO INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_pseudo();
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // interface ::= LOCAL INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                ((Interface)CUP$result).set_locality( true );
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // interface ::= ABSTRACT INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                ((Interface)CUP$result).set_abstract();
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // interface ::= INTERFACE ID 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-0)));
                parser.closeScope( (Scope)((Interface)CUP$result) );
          
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // interface ::= PSEUDO INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_pseudo();
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1));
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_pseudo();
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // interface ::= LOCAL INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)) ;
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                ((Interface)CUP$result).set_locality( true );
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // interface ::= ABSTRACT INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).set_abstract();
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)) ;
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // interface ::= INTERFACE ID inheritance_spec LCBRACE interface_body RCBRACE 
            {
              CUP$result = new Interface(/*interface*/12);
              
                ((Interface)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)));
                ((Interface)CUP$result).inheritanceSpec = (/*is*/(SymbolList)CUP$stack.elementAt(CUP$top-3));
                ((Interface)CUP$result).body = (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)) ;
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).set_name((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-4)).str_val);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).my_interface = ((Interface)CUP$result);
                (/*b*/(InterfaceBody)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Interface)CUP$result));
                ((Interface)CUP$result).set_included( parser.include_state );
                parser.closeScope( (Scope)((Interface)CUP$result) );
         
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // type_prefix_decl ::= TYPEPREFIX scopename DBLQUOTE ID DBLQUOTE 
            {
              CUP$result = new TypePrefixDecl(/*type_prefix_decl*/11);
              
                        ((TypePrefixDecl)CUP$result).scopedname = (/*m*/(ScopedName)CUP$stack.elementAt(CUP$top-3));
                        ((TypePrefixDecl)CUP$result).prefix = (/*p*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-1)).str_val;
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // module ::= MODULE ID LCBRACE definitions RCBRACE 
            {
              CUP$result = new Module(/*module*/10);
              
                ((Module)CUP$result).spec = (/*d*/(Definitions)CUP$stack.elementAt(CUP$top-1));
                ((Module)CUP$result).set_token((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)));
                ((Module)CUP$result).setPackage((/*i*/(org.jacorb.idl.str_token)CUP$stack.elementAt(CUP$top-3)).str_val );
                ((Module)CUP$result).set_included( parser.include_state );

                (/*d*/(Definitions)CUP$stack.elementAt(CUP$top-1)).setEnclosingSymbol(((Module)CUP$result));
                parser.closeScope( (Scope)((Module)CUP$result) );
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // definition ::= value SEMI 
            {
              CUP$result = new Definition(/*definition*/8);
              
                        ((Definition)CUP$result).set_declaration((/*m*/(Value)CUP$stack.elementAt(CUP$top-1)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // definition ::= type_prefix_decl SEMI 
            {
              CUP$result = new Definition(/*definition*/8);
              
                        ((Definition)CUP$result).set_declaration((/*pt*/(TypePrefixDecl)CUP$stack.elementAt(CUP$top-1)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // definition ::= module SEMI 
            {
              CUP$result = new Definition(/*definition*/8);
              
                        ((Definition)CUP$result).set_declaration((/*m*/(Module)CUP$stack.elementAt(CUP$top-1)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // definition ::= interface SEMI 
            {
              CUP$result = new Definition(/*definition*/8);
              
                        ((Definition)CUP$result).set_declaration((/*p*/(Interface)CUP$stack.elementAt(CUP$top-1)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // definition ::= except_dcl SEMI 
            {
              CUP$result = new Definition(/*definition*/8);
              
                        ((Definition)CUP$result).set_declaration((/*e*/(StructType)CUP$stack.elementAt(CUP$top-1)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // definition ::= const_dcl SEMI 
            {
              CUP$result = new Definition(/*definition*/8);
              
                        ((Definition)CUP$result).set_declaration((/*c*/(ConstDecl)CUP$stack.elementAt(CUP$top-1)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // definition ::= type_dcl SEMI 
            {
              CUP$result = new Definition(/*definition*/8);
              
                        ((Definition)CUP$result).set_declaration((/*t*/(TypeDeclaration)CUP$stack.elementAt(CUP$top-1)));
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // definitions ::= definition 
            {
              CUP$result = new Definitions(/*definitions*/9);
              
                        ((Definitions)CUP$result).v.insertElementAt((/*d*/(Definition)CUP$stack.elementAt(CUP$top-0)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // definitions ::= definition definitions 
            {
              CUP$result = new Definitions(/*definitions*/9);
              
                        ((Definitions)CUP$result).v = (Vector)(/*ds*/(Definitions)CUP$stack.elementAt(CUP$top-0)).v.clone();
                        ((Definitions)CUP$result).v.insertElementAt((/*d*/(Definition)CUP$stack.elementAt(CUP$top-1)),0);
                
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // specification ::= empty 
            {
              CUP$result = new Spec(/*specification*/7);
              
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // specification ::= NT$0 definitions 
            {
              CUP$result = new Spec(/*specification*/7);
              
                /* parsing */

                ((Spec)CUP$result).definitions = (Vector)(/*ds*/(Definitions)CUP$stack.elementAt(CUP$top-0)).v.clone();

                if( parser.package_prefix != null )
                        ((Spec)CUP$result).setPackage( parser.package_prefix );

                ((Spec)CUP$result).parse();

                if ( lexer.error_count != 0 )
                {
                    lexer.emit_error( lexer.error_count + " error(s).");
                    throw new ParseException ("Lexer errors");
                }

                // if there are still interfaces to be parsed, wait until the
                // threads performing this have finished. The last one
                // will call notify() :)

                if( parser.pending_interfaces.size() > 0  )
                {
                   // only block waiting if we know that there are active or
                   // runnable threads and that there are still pending tasks
                    final long timeout = 60000;
                    long waitUntil = System.currentTimeMillis() + 20000;

                    synchronized(parser.pending_interfaces)
                    {
                        while(parser.activeParseThreads() > 0 && parser.pending_interfaces.size() > 0 && System.currentTimeMillis() < waitUntil)
                        {
                            parser.pending_interfaces.wait(timeout);
                        }
                    }
                }

                if( parser.pending_interfaces.size() > 0 &&
                    !parser.sloppy )
                {
                    parser.fatal_error("Undefined interface: " +
                        (String)(parser.pending_interfaces.keys().nextElement()), null );
                }


                /* okay, parsing is done */
                parser.done_parsing = true;

                /* code generation phase */

                if (! parser.parse_only  )
                {
                     if( parser.getGenerator() != null )
                     {
                         if (parser.addbackend)
                         {
                             // before the custom backend first use
                             // the default code generator for the Java Mapping
                              ((Spec)CUP$result).print( new java.io.PrintWriter( java.lang.System.out ) );
                         }

                          // a custom backend was provided , so let's start
                          // the visitor
                          ((Spec)CUP$result).accept( parser.getGenerator() );
                     }
                     else
                     {
                          // use the default code generator for the Java Mapping
                          ((Spec)CUP$result).print( new java.io.PrintWriter( java.lang.System.out ) );
                     }
                }

        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              CUP$result = new org.jacorb.idl.runtime.token(/*NT$0*/99);
              
        
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= specification EOF 
            {
              CUP$result = new org.jacorb.idl.runtime.token(/*$START*/0);
              
            }
          /* ACCEPT */
          CUP$parser.done_parsing();
          return CUP$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
};

