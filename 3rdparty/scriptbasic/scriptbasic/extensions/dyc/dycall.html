<HTML>   
     <HEAD>
<TITLE>August 1998/A DynaCall() Function for Win32</TITLE></HEAD><BODY>

<H2 ALIGN="center"><FONT COLOR="#000000">A DynaCall() Function for Win32</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#000000">Ton Plooy</FONT></H3>

<HR>

<BLOCKQUOTE>

<p>You can use <B>LoadLibrary()</B> and <B>GetProcAddress()</B> to dynamically load a DLL, obtain the address of one of its functions, and call that function:</p>

<pre>
typedef int (*MSGBOX)(HWND,LPCSTR,LPCSTR,UINT);
HINSTANCE Lib = LoadLibrary("user32.dll");
PROC      Func= GetProcAddress(Lib, "MessageBoxA");
MSGBOX    MsgBox = (MSGBOX)Func;
MsgBox(NULL, "Dynamic message!", "test", MB_OK);
</pre>

<p>But you must know in advance what function you plan to call in order to correctly declare its arguments; that&#146;s the purpose of the <B>typedef</B> in this example. That&#146;s not normally an important restriction, since most programs don&#146;t need to make a runtime call to a function that was not anticipated at compile time.</p>
<p>There is one class of application that needs to make calls to functions that were unknown at compile time: interpreted Windows environments. For example, both WordBasic (the interpreted language that Microsoft Word supports) and WinHelp (which supports a very simple interpreted language) let you declare and call functions in external DLLs. Those interpreters must execute runtime calls to DLL functions without knowing in advance their names and arguments.</p>
<p>Most Windows programmers won&#146;t create their own interpreted Windows language, but you might want to add the ability to call external DLL functions to an existing interpreted language. The best example of this is VBScript, a subset of Visual Basic that programmers can incorporate into their Windows programs without paying license fees. VBScript lacks the ability to declare and call external DLL functions on the fly, but you could add this ability &#151; if you could construct arbitrary function calls at runtime.</p>
<p>Calling arbitrary DLL functions with arbitrary arguments at runtime requires you to do work that the compiler normally does for you &#151; you must manually place arguments on the stack in the correct order and, depending on the calling sequence of the target function, clean up the stack after the call. This is work that is most conveniently done in assembly language, since C and C++ do not provide explicit enough control over the stack. This article describes how to perform that task, and provides a DLL with a reusable function called <B>DynaCall()</B> that uses inline assembly language to take a function pointer and an array of arguments and execute a call to that function.</p>

<H4>Overview</H4>

<p>The goal is to write a function which, given a function pointer and an array of arguments of varying sizes (e.g., <B>char</B>, <B>int</B>, <B>double</B>, and so on), pushes the arguments onto the stack in whatever form or order the callee expects, invokes the function, and then obtains the return value from that function. Arguments are always passed on the stack, so <B>DynaCall()</B> will have to be able to move data from its input array of arguments onto the stack, adjusting the stack pointer appropriately. This is of course function-specific code, since the number of stack pushes as well as what must be pushed depends on the specific function being called and in which context. The way a function returns information also depends on the type of its return value. Return values up to four bytes in size are always passed through the (32-bit) <B>EAX</B> register. But other types require different handling, and specific code must be generated for it.</p>
<p>Unfortunately, these issues are compiler-dependent to some degree. I analyzed the involved mechanisms for 32-bit Microsoft and Borland compilers. If you need support for calling functions from DLLs generated by other compilers, you need to handle any differences yourself. Most standard items are handled the same way though, so I don&#146;t expect to see major implementation differences in this area. Most languages that can generate DLLs with exported functions will try to be compatible with the ad hoc standard of the Win32 API itself (which is exposed as a set of DLL functions).</p>
<p>Here&#146;s an overview of the various issues involved in function calling.</p>
<p><B>Parameter Passing</B>. This is rather straightforward. All parameters are pushed onto the stack. Parameters are aligned on a four-byte boundary, so, for example, a <B>char</B> parameter uses four bytes of stack space. Floating-point and structure parameters are copied directly to the stack; they each consume some multiple of four bytes.</p>
  <p><B>Calling Sequence</B>. <B>DynaCall()</B> supports the two types of calling 
    sequences used by the Win32 API: <B>__stdcall</B> (<B>WINAPI</B>) and <B>__cdecl</B> 
    (<B>WINAPIV</B>). <a href="http://www.windevnet.com/documents/s=7297/wdj9808d/9808df1.htm">Figure 1</a> shows two functions that 
    are identical except for calling sequence, along with a disassembly of the 
    code that calls them. The calling sequence specifies three things: argument 
    order, stack cleanup, and naming convention.</p>
  <p>First, under Win32, both <B>__stdcall</B> and <B>__cdecl</B> require arguments 
    to be pushed on the stack from right to left &#151; reverse order, in other 
    words. As you can see in <a href="http://www.windevnet.com/documents/s=7297/wdj9808d/9808df1.htm">Figure 1</a>, when you pass 
    arguments <B>a</B> and <B>b</B> to a function, the compiler generates code 
    that pushes first <B>b</B> and then <B>a</B> onto the stack.</p>
  <p>Second, <B>__stdcall</B> requires the callee to clean up the stack (pop the 
    pushed parameters off), while <B>__cdecl</B> requires the caller to handle 
    stack cleanup. Because of this, <B>__cdecl</B> can support functions that 
    take a variable number of arguments (e.g., <B>printf()</B>), since in that 
    case the callee cannot know at compile time how many parameters need to be 
    popped. In <a href="http://www.windevnet.com/documents/s=7297/wdj9808d/9808df1.htm">Figure 1</a>, you can see that the <B>__stdcall</B> 
    function ends in a <B>RET 8</B> instruction (popping two four-byte parameters), 
    while the <B>__cdecl</B> function ends in a simple <B>RET</B> (since the caller 
    has to adjust the stack pointer).</p>
<p>Finally, the calling sequence affects the actual exported name generated by the compiler and linker, and Microsoft and Borland use different conventions for this. Microsoft mangles <B>__stdcall</B> names by default, so a function declared as:</p>

<pre>
int __stdcall Foo(int a)
</pre>

<p>would by default get assigned a name of &#147;_Foo@4&#148; by Visual C++, but would be named &#147;Foo&#148; by Borland C++. With <B>__cdecl</B>, the same function would be named &#147;Foo&#148; by Visual C++, but &#147;_Foo&#148; by Borland C++. With both compilers, you can use a <B>.def</B> file to alias the exported function name to whatever you want, and most DLLs intended for wide reuse follow the convention of the Win32 API: <B>__stdcall</B> function names are not mangled, and <B>__cdecl</B> functions (the less common case) have a &#147;_&#148; prepended to their name.</p>
<p>This discussion of mangling assumes you&#146;re either compiling with C, or are exporting functions from C++ using the <B>extern "C"</B> directive. Otherwise, C++ will impose its own name mangling scheme.</p>
<p><B>Returned Values</B>. Most C compilers return smallish data types in some machine register, and larger types (such as structures) by requiring the caller to pass a hidden pointer to an appropriate amount of memory. The Win32 API is no different in this respect. All four-byte return values are returned through the <B>EAX</B> register and all eight-byte integer values (<B>__int64</B>) are returned through the <B>EAX</B>/<B>EDX</B> register pair. For floating-point return values the situation is a little different. They are returned on the math coprocessor&#146;s stack and a special instruction is needed to move the return value into main memory. You might wonder what happens if you run on a machine that doesn&#146;t have a floating-point coprocessor installed. Even in this (rather theoretical) case the floating-point instructions are used. Windows NT and 32-bit Windows 95 provide floating-point emulation from the Win32 kernel so the application itself doesn&#146;t have to deal with it.</p>
<p>For non-integer, large return types (structures), Microsoft&#146;s compiler pushes a hidden argument on the stack, which is a pointer to a temporary buffer (located on the stack). The function itself then copies the return value to this buffer. Upon return, additional code in the caller copies the temporary buffer to the assigned variable. Borland&#146;s code is more efficient; it passes the pointer to the assigned variable directly so there&#146;s no need for a temporary structure and second copying. There&#146;s one notable exception to these general rules. The Microsoft compiler recognizes structures that are less than or equal to eight bytes and uses <B>EAX</B>/<B>EDX</B> register passing instead of the stack data copying mechanism in these cases. (Ironically, it was Borland and not Microsoft that implemented this additional optimization under Win16 &#151; the two compilers have managed to remain incompatible under Win32 by copying each other&#146;s Win16 behavior.)</p>

<H4>Implementing DynaCall()</H4>

<p>The issues of <B>__stdcall</B> versus <B>__cdecl</B> and Borland C++ versus Visual C++ all play a part in the implementation of <B>DynaCall()</B>. The prototype for <B>DynaCall()</B> is:</p>

<pre>
RESULT DynaCall(
    int      Flags,
    DWORD    lpFunction,
    int      nArgs,
    DYNAPARM DynaParm,
    LPVOID   pRet,
    int      nRetSize
    );
</pre>

<p><B>RESULT</B> is a union of standard types, ranging from a four-byte <B>int</B> to an eight-byte <B>double</B>. If you need to call a function that returns a structure, then you have to use <B>pRet</B> and <B>nRetSize</B> to supply a buffer to hold the return value.</p>
<p>The <B>Flags</B> parameter specifies various options: whether the return value is a floating-point value (since that requires fetching the value from the math coprocessor), whether the calling sequence of the target function is <B>__stdcall</B> or <B>__cdecl</B>, and whether the callee is a Borland C++ or Visual C++ function (which affects how some structures are returned, as described previously). In most cases, the return value will be a simple data type, in which case you don&#146;t have to know whether the callee was compiled with Visual C++ or Borland C++.</p>
<p>You need to specify the function&#146;s address (retrieved via <B>GetProcAddress()</B>, for example) in the <B>lpFunction</B> parameter.</p>
<p>The third and fourth parameters contain the argument count and an array of <B>DYNAPARM</B> structures that describe the individual function arguments:</p>

<pre>
typedef struct DYNAPARM {
    DWORD       dwFlags;        // Parameter flags
    int         nWidth;         // Byte width
    union {                     //
        DWORD   dwArg;          // 4-byte argument
        void   *pArg;           // Pointer to argument
    };
} DYNAPARM;
</pre>

<p>The fourth parameter is an array of <B>DYNAPARM</B> structures preceded by the number of elements (arguments) in the array. The <B>DYNAPARM</B> type is a structure containing argument flags, argument size, and the argument itself. Currently there&#146;s only one possible flag that specifies if the argument is supplied by reference instead of directly. (If the parameter is larger than four bytes, a pointer to the argument needs to be specified.)</p>
  <p><B>docall.c</B> (<a href="http://www.windevnet.com/documents/s=7297/wdj9808d/9808dl1.htm">Listing 1</a>) contains some sample 
    calls that demonstrate how to use <B>DynaCall()</B>. Be sure to specify all 
    parameters and options correctly. One wrong value can misbalance your own 
    application stack and (especially on Win95/98) crash the system. With a normal 
    function call, the compiler can verify that the caller and callee agree on