






























\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename devguide
@settitle ScriptBasic Developers Manual
@setchapternewpage odd
@c %**end of header

@ifinfo
This file contains the texinfo format documentation how to embed ScriptBasic 
into applications, how to write extension modules and preprocessors.

Copyright 1999-2001 Peter Verhas 
@end ifinfo

@titlepage
@title ScriptBasic Developers Manual
@author Peter Verhas

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1999-2001 Peter Verhas
Published by @code{peter.verhas.com}

@end titlepage
@summarycontents
@contents

@menu
@end menu


@chapter Introduction


ScriptBasic is an open source scripting implementation of the programming language BASIC. The language and the implementation make the software a considerable choice in many cases when there is a need for some scripting tool. This software can be used where traditionally Perl, Python, TCL or some other scripting interpreter is used.

The language itself is BASIC with powerful command set and large number of extension modules. The language was designed so that this is familiar for all BASIC programmers no matter which dialect one has experience with. Thus the learning curve of the language is very steep: you can start to write your first programs just in few minutes.

The interpreter is built modular, well documented, and easy to read source code and has well defined and documented interfaces. It is easy to embed the interpreter into an application and it is also easy to write external modules extending the language. Applications embedding ScriptBasic can build virtual machines in multiple or in single process running interpreters simultaneously independent of each other, but they can also execute multi-thread applications running interpreter threads that provide features for the BASIC programs running parallel to communicate to each other.

This means that ScriptBasic can be the language of choice in situations when the application programmer wants to implement some programmability feature into the application. It will attract the users of the application because there is no need to learn a new programming language at the time when they have to learn the functions of the application anyway. The programmer on the other hand has an easy job to integrate ScriptBasic into the application because it was designed for the purpose.

To sum up these in a listing the language and the implementation has the following features:
 
@itemize

@item
IT IS BASIC. No question, this is the MOST important feature of ScriptBasic. 
There are a lot of people who can program BASIC and only BASIC. There are many people, who can not really program. Those who do not really know what programming is, and still: they write their five-liners in BASIC to solve their simple problems. They never write Perl, Tcl, Java or C. Therefore it is BASIC.

@item
SCRIPTING language. There are no data types in the language. You can store real numbers, integer numbers and strings in any variable. You can mix them and conversion is done automatically.

@item
PORTABLE Available in C source and can be compiled on UNIXes as well as on Windows NT.

@item
4E LANGUAGE, which means easy to extend, easy to embed. ScriptBasic was developed to provide clean and clear interfaces around it, and inside it. It is easy to embed the language to an application and use it as a macro language just like TCL. It is also easy to implement new built-in function and new commands. 
You can develop dynamically loaded libraries that ScriptBasic may load at run time. The language source is clean, well documented and development guides are on the way.

@item
COMPILED CODE ScriptBasic creates intermediate compiled code, which is interpreted afterwards. Syntax analysis is done at first and only syntactically perfect programs start to run. The compiled code is put into a continuous memory space and compiled code can be saved and loaded again to run without recompilation. This is vital for CGI scripts and is not available for most scripting programming languages. Compiled code is binary, not readable. 
Therefore you can develop and distribute programs and getting some help to protect your intellectual property. You need not give the source code. 

@item
MULTI THREAD aware. Although the current implementation is not multi thread, all the code was designed to be thread safe. You can embed the code into systems that run multiple interpreters in the same process. On the other hand the interpreter can run the same code in multiple threads and was designed to be capable handling call-back functions, and multithread programs in the future. 

@item
DEBUGGER The BASIC programs can be debugged using the external debugger.

@end itemize

@section Chapters

This documentation has four main chapters. These are

@itemize

@item @xref{Interpreter Architecture} describes the overall architecture of the interpreter, lists the different modules, and contains the reference documentation of the C functions implemented in the individual modules.

@item @xref{Embedding the Interpreter} describes how to write an application that embeds The ScriptBasic interpreter. This chapter also contains the reference documentation of the full C API.

@item @xref{Extension Modules} describes what extension modules are, how to use them and how to write extension modules that may provide access to special programs, operating system features, and are not implemented in the interpreter core.

@item @xref{Preprocessors} detail how to write preprocessor extensions to ScriptBasic. These extensions provide development functionalities like debugging, profiling and processing of the source code in addition to the processing of the interpreter.

@item @xref{Compilation} details how to compile ScriptBasic under Windows NT.
@end itemize

I advise you to read the architecture chapter first to get the overall picture. After that you can read one of the three middle chapters based on your plans. If you plan to embed the interpreter, read the second chapter. If you want to write an extension module, read the third chapter. If you intend to write a preprocessor, read the fourth chapter. You may want to do more than one even.

By now you may not need what the differences are. This will change after reading the architecture chapter.

The last chapter is to be read just before you start to experiment with ScriptBasic. This will give you guide lines how to compile the program from source. This may not be needed for extension module and preprocessor developers, but it does not do any harm either. It may help.

@chapter Interpreter Architecture

This chapter tells you the architecture of the interpreter. It is not a must to read this chapter, and you may find that some topic is irrelevant or not needed to learn to embed or to extend ScriptBasic. However understanding the internal working order of ScriptBasic should help you understand why some of the extending or embedding interfaces work the way they actually do. So I recommend that you read on and do not skip this chapter.

To read this chapter and to understand the internal working of the interpreter is vital when you decide to write an internal preprocessor. Internal preprocessors interact with not only the execution system but also the reader, lexer, syntaxer and builder modules along the way one after the other as they do their unique job processing a BASIC program, thus internal preprocessor writers have to understand how these modules work.

ScriptBasic is not a real scripting language. This is a mix of a scripting language and compiled languages. The language is scripting in the sense that it is very easy to write small programs, there is no need for long variable and function declarations. On the other hand the language is compiled into an internal code that is executed afterwards. This is the same or similar technique, which is used in the implementations of the language Java, Perl, Python and many other languages.

ScriptBasic as a language is a BASIC dialect that implements most BASIC features that BASIC implementations usually do. However ScriptBasic variables are not typed, and dynamic storage, like arrays are automatically allocated and released. A ScriptBasic variable can store a string, an integer, a real value or an array. Naturally a variable can not store more than one of any of these types of values. But you need not declare a variable to be INTEGER or REAL, or STRING. A variable may store a string at a time and the next assignment command may release the original value and store a different value in the variable.

When a program is executed it goes through several steps. The individual steps are implemented in different modules each being coded in a separate C language source file. These modules were developed so that they provide clear interface and thus could be replaced. The lexical analyzer uses the functions provided by the reader, the syntax analyzer uses the functions provided by the lexical analyzer and so on. The modules never dig into each others private area.

The modules are listed here with some explanation.

@itemize

@item
EXTERNAL PREPROCESSOR

This module executes external preprocessors. These preprocessors are standalone executable programs that read the source program and create another file that is read and processed by the ScriptBasic interpreter. If an external preprocessor is used the source file is usually not BASIC but rather some other language, usually a BASIC like language, which is extended some way and the preprocessor creates the pure ScriptBasic conformant BASIC program. The sample preprocessor supplied with ScriptBasic is the HEB (HTML Embedded BASIC) preprocessor that reads HTML embedded BASIC code and creates BASIC program. This HEB source file is a kind of HTML with embedded program fragments, which you may be familiar with in case you program PHP or Microsoft BASIC ASP pages. The HEB preprocessor itself is written in BASIC and is executed by ScriptBasic. Thus when a HEB "language" is executed by ScriptBasic it starts a separate instance of the interpreter and executes the HEB preprocessor on the source file. Of course the HEB preprocessor could be implemented in any language that can be compiled or some way executed on the target machine. Actually the very first version of the HEB preprocessor was written in Perl so when it was first tested the ScriptBasic interpreter started a Perl interpreter before reading the generated BASIC code.

Note that the HEB preprocessor provided in the ScriptBasic package is an example implementation and lacks many features. It can, for example, be fooled by putting a @code{%>} characters into a BASIC string constant.

@item
READER

This module reads the source file into the computer memory. Usually source programs are not too big compared to computer memory and thus can be read into the operational memory (RAM). ScriptBasic source code is approximately 1MB and I develop it on a station that has 386MB memory. This means that even a fairly large program can fit into the memory seamlessly. BASIC programs executed by the ScriptBasic interpreter are likely to be much smaller than that.

The source code is stored in memory pieces that form a linked list. Each element of the list contains one line of the source code and the information of the line for debugging and error reporting purposes. This information includes the file name that the line was read and the line number. Later when the lexer (detailed later) performs lexical analysis it will inherit this information and when there is a lexical or syntactical error the line number is reported correct.

The reader module also handles the @code{include} and @code{import} directives that are used to include files into the source file. (Note that @code{import} inserts the content of the file only if it was not loaded yet.)

The module also processes the lines that look 

@example
use preprocessor
@end example

and loads the internal preprocessor named on the line. @xref{Preprocessors}

When the module is ready the latter modules have the full source file in memory ready to be processed. The module also provides @code{getc} and @code{ungetc} like functions to get the read characters one by one. These are is used by the lexer.

@item
LEXER

The lexer module uses the line stream (or the character stream if we view it from a different point of view) provided by the reader. It reads the characters and builds up a linked list. Each element of the list contains a token, like BASIC keyword, a real or integer number, symbol, string, multi-line string, or character. The list of tokens is stored in a form of linked list in the order the tokens appear in the input. Each element also contains extra information about the token that identifies the name of the file and the line number inside the file where the token originally was.

When the lexer is finished the list of lines is not really needed any more and the reader is ready to release the memory occupied by the source lines read into memory.

The lexer also provides functions that are used by the syntax analyzer to read the tokens in sequence one after the other as needed by the syntax analysis.

@item
SYNTAXER

The syntaxer reads the list of tokens provided by the lexical analysis module and creates an internal structure that is already very similar to the executable internal code of ScriptBasic. The syntax analyzer finds any programming error that is not syntactically correct and when it is ready the result is a huge, cross-linked memory structure that contains the almost-executable code.

The syntax analyzer is responsible building up the evaluation trees of the expressions, the execution nodes, variable numbering and so on.

When the code refers to a variable named for example @code{variable} the syntax analyzer is responsible to allocate a slot for the variable and to convert the name to a serial number that identifies the variable whenever it is used. Beyond the syntax analyzer there are no named variables anymore (except in case of debuggers). There are global variables listed from @code{1} to @code{n} and local variables also listed by numbers. There are also no names for the functions. Each function is identified by a C pointer to the node where the function starts.

To ease the life of those who want to embed ScriptBasic the symbol table that list the global variables and the functions and subroutines is appended to the byte-code and there are functions in the @code{scriba_*} embedding interface that handles these symbol tables. However ScriptBasic itself does not use variable or functions/subroutine names beyond the syntax analyzer.

@item
BUILDER

The builder is the module that creates the code, which is used by the execution system. Why do we have a separate builder? Isn't it the role of the syntax analyzer to build the code?

Yes, and no. The code that was created by the syntax analyzer could be used to execute the BASIC program, but ScriptBasic still inserts an extra transformation before executing the program. The reason for this extra step is to create a byte code that can be stored in a continuous memory area and thus can easily be saved to or loaded from disk.

When the syntax analyzer creates the nodes it does not know the actual number of nodes of the byte-code, nor the number of different strings, or size of the string table. While the code is created the syntax analyzer allocates memory for each new block it creates one by one. The nodes are linked together using C pointers. This means that the final memory structure is neither continuous in memory nor can be saved or loaded back to disk.

When the builder starts the number of the nodes just as well as the total string constant size is known. The builder allocates the memory needed for the whole code and fills in the actual code. The node size is a bit smaller than that of the syntax analyzer and they refer to each other using node serial numbers instead of pointers. This is almost as efficient as using pointers and the actual value does not depend on the location of the node in memory and this way the code can be saved to disk and loaded again for execution.

@item
EXECUTOR

The executor kills the code. Oh no! I am just kidding.

It actually executes the code. It gets the code that was generated by the module builder and executes the nodes one by one and finally exits.

@end itemize

The following sections detail these modules and also some other modules that help these modules to perform their actual tasks.

@node External Preprocessor
@section External Preprocessor

The module that implements the external preprocessor handling is coded in the C source file @file{epreproc.c} (Note that there is a file @file{ipreproc.c} that handles internal preprocessors.) The sole function in this file is named @code{epreproc}. This is quite a complex function that gets a lot of arguments listing all the preprocessors that have to be executed one after the other on the source file or on the file created by the previous preprocessor in case there are more than one preprocessors to be applied in chains. The function gets a series of preprocessors to be executed in the command line but in case there is no preprocessor defined in the arguments it executes the preprocessors that have to be executed according to the BASIC program file name extension and the configuration file.

Only the preprocessors that are configured can be executed. Each preprocessor has a symbolic name, which is used to name it in the configuration file or on the command line using the option @option{-p}.

An external preprocessor is a program that reads a text file and produces a text file. ScriptBasic executes the external preprocessor in a separate process and supplies it with the input and the output file name on the command line. For example the @file{scriba.conf.lsp} configuration file may contain the following lines

@example
preproc (
  extensions (
     heb "heb"
     )
  external (
    heb (
      executable "/usr/bin/scriba /usr/share/scriba/source/heber.bas"
      directory "/var/cache/scriba/hebtemp/"
      )    
    )
  )
@end example

The key @code{executable} defines the executable image of the preprocessor. In this case this is an executable image and an argument because the HEB (HTML Embedded Basic) preprocessor is written in BASIC. The other arguments, namely the input file name and the output file name are appended after this string separated by space. When the preprocessor is executed the actual command line is

@example
/usr/bin/scriba /usr/share/scriba/source/heber.bas myprog.heb /var/cache/scriba/hebtemp/ADBKPLNBDELMMNKGNBBLHAHGBKKJFIMN
@end example

(The above sample command line may be split into two lines by the printing/displaying system, but this is essentially a single command line with the executable name and the two arguments.)

The final argument is a file name automatically generated by ScriptBasic using MD5 calculation of the input file name full path (may and presumably should not be correct in this example above as I just typed some random 32 characters). The preprocessor should read the file @code{myprog.heb} and should generate @code{/var/ca@dots{}MN} (forgive me for not typing that long file name again).

If there are more preprocessor to be executed on the generated result then the next is executed on the generated file as input file and another output file is generated.

The preprocessor program should gracefully exit the process it runs in and exit with the code @code{0}. Any other process exit code is treated as error and the further processing of the BASIC program is aborted.

The sample code for the HEB preprocessor can be found in the ScriptBasic source distribution. Note that this preprocessor implementation is a sample and is not meant to be a professional, commercial grade preprocessor.



@subsection  External preprocessor handling
=abstract
This module starts the external preprocessors.
=end

=toc


@subsection  Execute external preprocessors

This function executes the external preprocessors that are
needed to be executed either by the command line options or
driven by the extensions.

The command line option preprocessors are executed as listed
in the character array @code{ppszArgPreprocessor}. These preprocessors
are checked to be run first.

If there is no preprocessors defined on the command line then the
preprocessors defined in the config file for the extensions are
executed. The input file name is also modified by the code.
The input file name is modified so that it will contain the source
code file name after the preprocessing.

The return value of the function is the error code. This is @code{PREPROC_ERROR_SUCCESS}
if the preprocessing was successful. This value is zero. If the return
value is positive this is one of the error codes defined in the file @code{errcodes.def}
prefixed by @code{PREPROC_}.

@example
int epreproc(ptConfigTree pCONF,
             char *pszInputFileName,
             char **pszOutputFileName,
             char **ppszArgPreprocessor,
             void *(*thismalloc)(unsigned int),
             void (*thisfree)(void *)
  )@@{
@end example

The first argument @code{pCONF} is the configuration data pointer which is passed to the
configuration handling routines.

The second argument @code{pszInputFileName} is the pointer to the pointer to the input file name.

The third argument is an output variable. This will point to the output file name upon success
or to NULL. If this variable is NULL then an error has occured or the file needed no preprocessing.
The two cases can be separated based on the return value of the function. If the file needed
preprocessing and the preprocessing was successfully executed then this variable will point
to a ZCHAR string allocated via the function @code{thismalloc}. This is the responsibility of the
caller to deallocate this memory space after use calling the function pointed by @code{thisfree}.

The fourth argument @code{ppszArgPreprocessor} is an array of preprocessors to be used
on the input file. This array contains pointers that point to ZCHAR strings.
The ZCHAR strings contain the symbolic names of the external preprocessors that
are defined in the configuration file. The configuration file defines
the actual executable for the preprocessor and the temporary directory where the
preprocessed file is stored. The final element of this pointer array should be @code{NULL}.
If the pointer @code{ppszArgPreprocessor} is @code{NULL} or the pointer array pointed by this
contains only the terminating @code{NULL} pointer then the extensions of the file name are
used to determine what preprocessors are to be applied. Preprocessors are applied from
left to right order of the file extensions.

The arguments @code{thismalloc} and @code{thisfree} should point to @code{malloc} and @code{free} or to
a similar functioning function pair. These functions will be used via the @code{myalloc.c} module
and also to allocate the new @code{pszOutputFileName} string in case of success. This means that the
caller should use the function pointed by @code{thisfree} to release the string pointed by
@code{pszOutputFileName} after the function has returned.

 


@section Reader

The module reader is implemented in the C source file @file{reader.c} This is a very simple module it just reads the lines from the source code files and stores the actual text in memory using linked lists. There is not too much possibility to configure this module except that the memory handling functions and the file opening, closing and reading functions are used via function pointers that can be altered by the caller.

Like any other module in ScriptBasic the reader module uses a module object. This is like a class definition except that the interpreter is coded in C and thus there is nothing like VTABLE or inheritance. Otherwise the code is object oriented. Here we list the actual definition of the reader object. Note however that this is actually a copy of the actual definition from the file @file{reader.c} and it may have been changed since I wrote this manual. So the reader object by the time I wrote this manual was:

@example
#define BUFFER_INITIAL_SIZE 1024
#define BUFFER_INCREMENT 1024
 typedef struct _ReadObject {
  void * (*fpOpenFile)(char *, void *);
  int (*fpGetCharacter)(void *, void *);
  void (*fpCloseFile)(void *, void *);
  void *pFileHandleClass;

  void *(*memory_allocating_function)(size_t, void *);
  void (*memory_releasing_function)(void *, void *);
  void *pMemorySegment;

  ptConfigTree pConfig;

  char *Buffer;
  long dwBuffer;
  long cBuffer;

  pSourceLine Result;
  pSourceLine CurrentLine;
  long NextCharacterPosition;
  char fForceFinalNL;

  pReportFunction report;
  void *reportptr;
  int iErrorCounter;
  unsigned long fErrorFlags;

  pImportedFileList pImportList;

  char *FirstUNIXline;
  struct _PreprocObject *pPREP;
  } ReadObject, *pReadObject ;
@end example

The pointers @code{fpOpenFile}, @code{fpGetCharacter} and @code{fpCloseFile} point to functions that are used to open the input file. The pointer @code{pFileHandleClass} set by the higher code using the module reader is passed to these functions without caring its meaning. This is not used by the standard file input/output functions that are used by the command line version of the program, but can be useful for program environment when the source file is stored in some other forms and not in a file. An example of such use can be seen in the function @code{scriba_LoadProgramString} implemented in the file @file{scriba.c}.

The linked list of source lines is stored in the structure named @code{SourceLine} The definition of this structure is

@example
typedef struct _SourceLine {
  char *line;
  long lLineNumber;
  long LineLength;
  char *szFileName;
  struct _SourceLine *next;
  } SourceLine, *pSourceLine;
@end example

You can see that each source line is pointed by the field @code{line} and the length of the line is also stored. The reason for this extra field is that the line itself may contain zero character although this is rare for a program source file to contain zero character inside.

Before the file is read the function @code{reader_InitStructure} should be called. This is usual for the ScriptBasic modules. This function initializes the reader object to the usual values that actually ScriptBasic needs.

The reader provides function @code{reader_ReadLines} that actually reads the lines and also processes all lines that contain an @code{include} or @code{import} directive to include a line.

The reader has some extra functions that are specific to ScriptBasic or generally saying are specific to program source reading.

Source programs under UNIX usually start with a line

@example
#! /usr/bin/scriba
@end example

that tells the operating system how to start the code. 

((((Some very old and totally outdated version of some UNIX systems check the first four characters to look for @code{#! /}. There is a space between the @code{!} and the @code{/}. So if you want to be look a real code geek put this extra space before the executable path. To be honest I have never encountered this issue since 1987 when I met my first UNIX at TU Delft, Hollandia. OK that's for the story, get back to the reader!))) Always close the parentheses you open!)

The reader recognizes this line if this is the very first line of the program and unlinks it from the list. Instead you can reach this line via the reader object variable @code{FirstUNIXline}. This is specific to program source reading and not general file reading. But the reader module is a program source reader or more specific: a BASIC, even ScriptBasic program source reader, though it was coded to be as general as possible.

Another specific issue is the new line at the end of the last line. Lines are usually terminated by new-line. This line terminating character is included in the string at the end of each element of the linked list the reader creates. However when the last line is terminated by the pure EOF some syntax analyzers may fail (ScriptBasic syntax analyzer is also an example, but the reader is kind to care about this). For the reason if the variable @code{fForceFinalNL} is set to be TRUE this line gets the extra new-line when read.




This module contains the functions that read a source file.

Script basic has several passes
until it can start to execute the code. The very first pass is to read the source lines from
the files. The routines in this module perform this task and build up a linked list that contains
the ascii values of the lines.

The input functions are parametrized, and the caller should support. If you have different
system dependent file reading functions, or if you have the input file in some format in memory or
in any other data holding space you can support these routines with character fetch functions.

@subsection  reader_IncreaseBuffer()

When the reader encounters a line which is longer than the currently allocated
input buffer it calls this function to increase the size of the input buffer. The
input buffer is linearly increased by @code{BUFFER_INCREMENT} size (defined in the header
section of @code{reader.c}

When a new buffer is allocated the bytes from the old buffer are copied to the new and
the old buffer is released. It is vital that the buffer is always referenced via the
pRo->buffer pointer because resizing buffer does change the location of the buffer.

If the memory allocation fails the function return @code{READER_ERROR_MEMORY_LOW} error.
Otherwise it returns zero.
@example
int reader_IncreaseBuffer(pReadObject pRo
  )@@{
@end example
@subsection  reader_gets()

This function reads a newline terminated line from the file. The file is
identified by function pRo->fpGetCharacter and the pointer @code{fp}.

When the input buffer is too small it automatically increases the buffer. The
terminating new line is included in the buffer. If the last line of the file is
not terminated by newline an extra newline character is added to this last line.

The addition of this extra newline character can be switched off setting pRo->fForceFinalNL
to false. Even if this variable is false the normal newline characters which are present
in the file are included in the buffer.
@example
int reader_gets(pReadObject pRo,
                 void *fp
  )@@{
@end example
@subsection  reader_ReadLines()

This function calls @xref{reader_ReadLines_r()@} to read the lines of the file
given by the file name @code{szFileName} into pRo->Result. For further
information see @xref{reader_ReadLines_r()@}.
@example
int reader_ReadLines(pReadObject pRo,
                     char *szFileName
  )@@{
@end example
The function returns zero or the error code.
@subsection  reader_ReadLines_r()

This function reads the lines of a file and creates a linked list
of the read lines.
@example
int reader_ReadLines_r(pReadObject pRo,
                       char *szFileName,
                       pSourceLine *pLine
  )@@{
@end example
The file is identified by its name given in the string variable @code{szFileName}. The
file is opened by the function pointed by pRo->fpOpenFile This function should return
a void pointer and this void pointer is passed to @xref{reader_gets()@} (@code{reader_gets}) to get a
single character.

The argument @code{pLine} is a pointer to a @code{SourceLine} pointer. The linked list lines read
will be chained into this pointer. The last read line will be followed by the line pointed by
@code{*pLine} and @code{*pLine} will point to the first line.

This design makes it easy to use and elegant to perform file inclusions. The caller has to
pass the address of the pointer field @code{next} of the source line after which the file is to
be inserted.

See also @code{ReadLines} that calls this function.
@subsection  reader_ProcessIncludeFiles()

This function is called from @xref{reader_ReadLines()@} after calling @xref{reader_ReadLines_r()@}.

This function goes through all the lines and checks if there is any line
containing an include directive.

An include directive is a line starting with a word INCLUDE (case insensitive) and
is followed by the file name. The file name can be enclodes between double quotes.

Note that the processing of the include directives are done on the characters on the
line, because they are processed before any tokenization of the lexer module. This
can cause some problem only when there is an include like line inside a multiline string.
For example:

@example
a = """Hey this is a multiline string
include "subfile.txt"
"""
@end example

This @b{will} include the file @code{subfile.txt} and its content will become part of the string.
This becomes more complicated when the file @code{subfile.txt} contains strings.

The file name may not be enclosed between double quotes. In this case the file is tried to be
found in predefined system directories.

If the programmer uses the command IMPORT instead of INCLUDE the file will only be included if
it was not included yet into the current program.
@example
void reader_ProcessIncludeFiles(pReadObject pRo,
                                pSourceLine *pLine
  )@@{
@end example

The file read is inserted into the plce where the include statement was.

@subsection  reader_LoadPreprocessors()

Preprocessors are not part of ScriptBasic. They can be implemented as external DLLs and
should be configured in the configuration file.

When a line contains

@example
USE preprocessorname
@end example

this reader module loads the preprocessor DLL or SO (dll under unix) file.

@example
void reader_LoadPreprocessors(pReadObject pRo,
                                 pSourceLine *pLine
  )@@{
@end example

@subsection  reader_StartIteration()

The package supports functions that help upper layer modules to iterate
through the lines read. This function should be called to start the iteration
and to set the internal iteration pointer to the first line.
@example
void reader_StartIteration(pReadObject pRo
  )@@{
@end example
@subsection  reader_NextLine()

This function returns a string which is the next line during iteration.
This function does NOT read anything from any file, only returns a pointer to
a string that was already read.

This function can be used together with @xref{reader_NextCharacter()@}. When a line was partially
passed to an upper layer that uses @code{reader_NextCharacter} this function
will only return the rest of the line.

@example
char *reader_NextLine(pReadObject pRo
  )@@{
@end example
@subsection  reader_NextCharacter()

This function gets the next character from the actual line, or gets the
first character of the next line.

This function does NOT read anything from any file, only returns a character from a string that
was already read.

When the last character of the last line was passed it return @code{EOF}
@example
int reader_NextCharacter(void *p
  )@@{
@end example
@subsection  reader_FileName()

This function returns the file name of the actual line. This is the string that
was used to name the file when it was opened. This can be different for different
lines when the reader is called several times to resolve the "include" statements.
@example
char *reader_FileName(void *p
  )@@{
@end example
@subsection  reader_LineNumber()

This function returns the line number of the current line durig iteration.
This number identifies the line in the file where it was read from.

@example
long reader_LineNumber(void *p
  )@@{
@end example
@subsection  reader_InitStructure()

This function should be called to initialize the reader structure. It sets the
file handling routines to the standard @code{fopen}, @code{fclose} and @code{getc} functions,
and also sets the function pointers so that the module uses @code{malloc} and @code{free}.

@example
void reader_InitStructure(pReadObject pRo
  )@@{
@end example
@subsection  reader_RelateFile()

This function gets a file name, which is either absolute or relative
to the current working directory and another file name which is absolute or
relative to the first one.

The return value of the function is a file name which is either absolute or
relative to the current woring directory.

The return value is dynamically allocated and is to be release by the caller.
The allocation function is taken from the class function and the segment is
@code{pMemorySegment}.
@example
char *reader_RelateFile(pReadObject pRo,
                       char *pszBaseFile,
                       char *pszRelativeFile
  )@@{
@end example
@subsection  reader_DumpLines()

This is a debug function that prints the lines into a debug file.
@example
void reader_DumpLines(pReadObject pRo,
                      FILE *fp
  )@@{
@end example

 




@section Lexer

The module lexer is implemented in the C source file @file{lexer.c} This is a module that converts the read characters to a list of tokens. The lexer recognizes the basic lexical elements, like numbers, strings or keywords. It starts to read the characters provided by the reader and group it p into lexical elements. For example whenever the lexical analyzer sees a @code{"} character it starts to process a string until it finds the closing @code{"}. When it does the module creates a new token, links it to the end of the list and goes on.

To do this the lexical analyzer has to know what is a keyword, string or number.

Because general purpose, table driven lexical analyzers are usually rather slow ScriptBasic uses a proprietary lexical analyzer that is partially table driven, but not so general purpose as one created using the program LEX.

There are some rules that are coded into the C code of the lexical analyzer, while other are defined in tables. Even the rules coded into the C program are usually parameterized in the module object.

Lets see the module object definition from the file @file{lexer.c} (Note that the C @code{.h} header files are extracted from the @code{.c} files thus there is no need to double maintain function prototypes.)

Note however that this is actually a copy of the actual definition from the file @file{lexer.c} and it may have been changed since I wrote this manual. So the lexer object by the time I wrote this manual was:

@example
typedef struct _LexObject {
  int (*pfGetCharacter)(void *);
  char * (*pfFileName)(void *);
  long (*pfLineNumber)(void *);
  void *pvInput;
  void *(*memory_allocating_function)(size_t, void *);
  void (*memory_releasing_function)(void *, void *);
  void *pMemorySegment;

  char *SSC;
  char *SCC;

  char *SFC;
  char *SStC;
  char *SKIP;

  char *ESCS;
  long fFlag;

  pReportFunction report;
  void *reportptr;
  int iErrorCounter;
  unsigned long fErrorFlags;

  char *buffer;
  long cbBuffer;

  pLexNASymbol pNASymbols;
  int cbNASymbolLength;

  pLexNASymbol pASymbols;

  pLexNASymbol pCSymbols; 
  pLexeme pLexResult;
  pLexeme pLexCurrentLexeme;
  struct _PreprocObject *pPREP;
  }LexObject, *pLexObject;
@end example

This @code{struct} contains the global variables of the lexer module. In the first "section" of the structure you can see the variables that may already sound familiar from the module reader. These parameterize the memory allocation and the input source for the module. The input functions are usually set so that the characters come from the module reader, but there is no principal objection to use other character source for the purpose.

The variable @code{pvInput} is not altered by the module. It is only passed to the input functions. The function pointer name @code{pfGetCharacter} speaks for itself. It is like @code{getc} returns the next character. However when this function pointer is set to point to the function @code{reader_NextCharacter} the input is already preprocessed a bit. Namely the @code{include} and @code{import} directives were processed.

This imposes some interesting feature that you may recognize now if you read the reader module and this module definition carefully. @code{include} and @code{import} works inside multi-line strings. (OK I did not talk about multi-line strings so far so do not feel ashamed if you did not realize this.)

The function pointers @code{pfFileName} and @code{pfLineNumber} should point to functions that return the file name and the line number of the last read character. This is something that a @code{getc} will not provide, but the reader functions do. This will allow the lexical analyzer to store the file name and the line number for each token.

The next group of variables seems to be frightening and unreadable at first, but here is this book to explain them. These variables define what is a string, a symbol, what has to be treated as unimportant space and so on. Usually symbols start with alpha character and are continued with alphanumeric characters in most programming languages. But what is an alpha character? Is @code{_} one or is @code{$} a valid alphanumeric character. Well, for the lexer module if any of these characters appear in the variable @code{SSC} then the answer is yes. The name stands for @emph{Symbol Start Characters}. But lets go through all these variables one by one.

@itemize

@item @code{char *SSC;}

This @emph{Symbol Start Character} variable contains all the characters that may be used to start a symbol. This symbol can be a variable or a symbol that appears for itself in the code like in the command @code{SET FILE}. (See the users guide.)

@example
QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm_:$
@end example

@item @code{char *SCC;}

This @emph{Symbol Continuation Character} variable contains all the characters that may be used inside a symbol after the opening first character. The default value for this variable is


@example
QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm_1234567890:$
@end example

@item @code{char *SFC;}

This @emph{Symbol Finishing Character} variable contains all the characters that may be used as the last character inside a symbol. The default value for this variable is

@example
QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm_1234567890$
@end example

which works fine for ScriptBasic. Note that this prohibits ScriptBasic variables to finish with colon.

@item @code{char *SStC;}

This @emph{Start String Character} variable contains the characters that may start a string. The ScriptBasic value contains only the @code{"} character thus ScriptBasic strings can only start and end with the @code{"} character. However some other languages may use different string starting and finishing characters.

If there are more than one characters in this string then a string opened using a character should be closed using the same character. This is hard coded into the C program of the lexer.

The lexer also recognizes single-line strings and multi-line strings. A single-line string starts with a single @code{"} (or whatever characters are allowed in the @code{SStC} field) and finish with a single @code{"}. There can not be new-line character in a single-line string and any @code{"} character in the string should be quoted using the @code{\} character. The @code{\} character is not hard-coded it is configured in the field @code{ESCS}, as you will see later.

A multi-line string starts with @code{"""} characters that is three @code{"} characters and finishes the same way. Multi-line string may span several lines. This notation of multi-line string was inherited from the language Python. (At least I did not see it anywhere else.)

@item @code{char *SKIP;}

This @emph{Skip} variable contains all characters that are to be skipped. This is the space, tab and the carriage-return character in case of ScriptBasic.

Skipping these characters does not mean that these characters are not taken into account. They serve a very important role: they stop tokens, thus no space can appear inside the name of a variable for example. However there is no token generated from these characters.

Note that the carriage-return character included in this string allows ScriptBasic to compile any DOS edited and binary transferred files under UNIX. However the operating system may have problem with the terminating carriage-return on the very first line.

@item @code{char *ESCS;}

This @emph{Escape String} variable list all those characters that can be escaped in a string. The line that initializes this variable in @code{lex_InitStructure}:

@example
pLex->ESCS = "\\n\nt\tr\r\"\"\'\'";
@end example

The first character of the @code{ESCS} string is the character used to escape other characters. This is the @code{\} character for ScriptBasic. The latter characters list the original character on the odd positions and the replacement characters on the following even position. For example the second character of this string is @code{n} and the replacement character is a new-line character, thus @code{\n} will be new-line in any sinle- or multi-line string in a BASIC program.

@item @code{long fFlag;}

This variable is a bit field that controls how numbers are treated in strings. The lines that initialize this variable are

@example
  pLex->fFlag = LEX_PROCESS_STRING_NUMBER       |
                LEX_PROCESS_STRING_OCTAL_NUMBER |
                LEX_PROCESS_STRING_HEX_NUMBER   |
                0;
@end example

The constants defined also in @file{lexer.c} tell the lexical analyzer that an escape character in a string followed by numeric characters should be converted to characters of the code. This the string @code{"a\10a"} will contains two @code{a} character separated by a new line. When the first character following the escape character is @code{0} the numbers are treated as octal numbers. If this character is @code{x} (lower case only and not @code{X}) the number is treated as hexadecimal. The escaped number is as long as there are numbers following each other without space. If the number is hexadecimal the letters @code{a-f} and @code{A-F} are also treated as digits.

@end itemize

The default values for these variables are set in the function @code{lex_InitStructure}. Interestingly these default values are perfectly ok for ScriptBasic.

The field @code{pNASymbols} points to an array that contains the non-alpha symbols list. Each element of this array contains a string that is the textual representation of the symbol and a code, which is the token code of the symbol. For example the table @code{NASYMBOLS} in file @file{syntax.c} is:

@example

LexNASymbol NASYMBOLS[] = @{
@{ "@\\" , CMD_EXTOPQN @} ,
@{ "@`" , CMD_EXTOPQO @} ,
@{ "@'" , CMD_EXTOPQP @} ,
@{ "@@" , CMD_EXTOPQQ @} ,

...

@{ "@" , CMD_EXTOPQ @} ,
@{ "^" , CMD_POWER @} ,
@{ "*" , CMD_MULT @} ,
@{ NULL, 0 @}
  @};
@end example

When the lexical analyzer finds something that is not a string, number or alphanumeric symbol it tries to read forward and recognize any of the non-alpha tokens listed in this table. It is extremely important that the symbols are ordered in this table so that the longer symbols come first thus a symbol @code{abc} is not presented before @code{abcd}. Otherwise @code{abcd} will never be found!

The variable @code{cbNASymbolLength} is nothing to care about. This is used internally and is calculated automatically by the lexical analyzer.

The variable @code{pASymbols} is similar to the variable @code{pNASymbols} pointing to a same kind of table. This variable however should point to an array that contains the alphanumeric symbols. You can find the array @code{ASYMBOLS} in file @file{syntax.c} that is pointed by this variable for ScriptBasic.

The order of the words in this array is not important except that more frequent words being listed earlier result faster compilation.

The field @code{pCSymbols} points to an array that is used only for debugging purposes. I mean debugging ScriptBasic code itself and not debugging BASIC programs.

The rest of the variables are used by the functions that iterate through the list of tokens when the syntax analyzer reads the token list or to report errors during lexical analysis. Error reporting is detailed in a separate section.

The tables that list the lexical elements are not maintained "by hand". The source for ScriptBasic syntax is maintained in the file @file{syntax.def} and the program @file{syntaxer.pl} creates the C syntax file @file{syntax.c} from the syntax definition.

The program @file{syntaxer.pl} is so complex that after two years I wrote it I had hard time to understand it and I rather treat it as a holly code: blessed and untouchable. (Ok: see: that code is quite compound, but if there was any bug found in that I could understand what I did in a few hours. Anyway, the brain created that code once belonged to me.)



@subsection Functions implemented in this module

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.





This module contains the functions and structures that are used by ScriptBasic to perform
lexical analysis of the source code. The module was originally developed for ScriptBasic
but was developed to be general enough to be used in other projects.

@subsubsection  lex_SymbolicName()

This function usually is for debug purposes. This searches the
table of the predefined symbols and returns the string which is
the predefined symbols for which the code was passsed.
@example
char *lex_SymbolicName(pLexObject pLex,
                       long OpCode
  )@@{
@end example
@subsubsection  lex_HandleContinuationLines()

This function is called from the main function before syntax analysis is started. 
This function handles the usual basic continuation lines. If the last character on a 
line is a _ character, which is either recognised during lexical analysis as a 
character or as a symbol then this lexical element and the following new-line character
token is removed from the list of tokens.

@example
void lex_HandleContinuationLines(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_RemoveSkipSymbols()

This function is called from @xref{lex_DoLexicalAnalysis()@} to remove the lexical elements
from the list of tokens that were denoted by the preprocessors to be deleted.

Some lexical elements are used to give information to some of the preprocessors. These
tokens should be deleted, because later processing can not deal with them and confuses syntax
analysis.

In those cases the preprocessor should set the type of the token to be L@code{LEX_T_SKIP} or
@code{LEX_T_SKIP_SYMBOL}. The type @code{LEX_T_SKIP} should be used in case the token is handled due to
@code{ProcessLexSymbol} preprocessor command and @code{LEX_T_SKIP} otherwise.

When the type is set @code{LEX_T_SKIP_SYMBOL} the lexical analyzer knows to release the string holding
the symbol. If the type is @code{LEX_T_SKIP} only the token record is released.

If the symbol string is not released due to erroneously setting the type to @code{LEX_T_SKIP} instead
@code{LEX_T_SKIP_SYMBOL} the memory will not be released until the interpreter finishes pre execution
steps. So usually if you do not know how to set the type to skip a token @code{LEX_T_SKIP} is safe.

@example
void lex_RemoveSkipSymbols(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_RemoveComments()

This function called from the function @xref{lex_DoLexicalAnalysis()@} function to remove the comments before the 
syntax analysis starts.

It should be called before calling the continuation line handling because usually REM
lines are not continuable
@example
void lex_RemoveComments(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_NextLexeme()

Use this function during iteration to get the next lexeme from the list of lexemes.

@example
void lex_NextLexeme(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_SavePosition()

Use this function to save the current position of the iteration. This is neccessary during
syntactical analysis to return to a certain position when syntactical analysis fails and
the program has to go back and try a different command syntax.

@example
void lex_SavePosition(pLexObject pLex,
                      pLexeme *ppPosition
  )@@{
@end example

The second argument is a @code{pLexeme *} type variable that holds the position and should be passed
as argument to the function @xref{lex_RestorePosition()@}.
@subsubsection  lex_RestorePosition()

Use this function to restore the lexeme position that was saved calling the function @xref{lex_SavePosition()@}

@example
void lex_RestorePosition(pLexObject pLex,
                         pLexeme *ppPosition
  )@@{
@end example
@subsubsection  lex_StartIteration()

You should call this function when the list of lexemes was built up before starting the iteration
of the syntax analyzer. This function sets the iteration pointer to the first lexeme.

@example
void lex_StartIteration(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_EOF()

Call this function to check if the iteration has reached the last lexeme.

@example
int lex_EOF(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_Type()

During lexeme iteration this function can be used to retrieve the typeof the current lexeme. The
type of a lexeme can be:

@itemize
@item @code{LEX_T_DOUBLE} a double value. A number which is not integer.
@item @code{LEX_T_LONG} an long value. A number which is integer.
@item @code{LEX_T_STRING} a string.
@item @code{LEX_T_ASYMBOL} an alpha symbol, like a variable. This symbol is not predefined. The value
of the lexeme is the string of the symbol.
@item @code{LEX_T_NSYMBOL} a predefined symbol. The actual value of the lexeme is the token value
of the symbol. If you wan to get the actual string of the symbol you have to call the function
@xref{lex_SymbolicName()@}.
@item @code{LEX_T_CHARACTER} A character that is not a predefined symbol and does not fit into any string.
@@end itemize

@example
int lex_Type(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_Double()

When the type of the current lexeme is @code{LEX_T_DOUBLE} during the lexeme iteration
this function should be used to retrieve the actual value of the current lexeme.

@example
double lex_Double(pLexObject pLex
@end example
@subsubsection  lex_String()

When the type of the current lexeme is @code{LEX_T_STRING} during the lexeme iteration
this function should be used to retrieve the actual value of the current lexeme.
@example
char *lex_String(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_StrLen()

When the type of the current lexeme is @code{LEX_T_STRING} during the lexeme iteration
this function should be used to retrieve the length of the current lexeme. This is
more accurate than calling @code{strlen} on the actual string because the string itself may
contain zero characters.
@example
long lex_StrLen(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_Long()

When the type of the current lexeme is @code{LEX_T_LONG} during the lexeme iteration
this function should be used to retrieve the actual value of the current lexeme.

@example
long lex_Long(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_LineNumber()

This function returns the line number that the actual lexeme is in the source file.
This function is needed to print out syntax and lexical error messages.

See also @xref{lex_FileName()@}.
@example
long lex_LineNumber(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_FileName()

This function returns a pointer to a constant string which is the file name
that the lexeme was read from. Use this function to print out error messages when
syntax or lexical error occures.

See also @xref{lex_LineNumber()@}.
@example
char *lex_FileName(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_XXX()

These access functions are implemented as macros and are put into <lexer.h> by the program @code{headerer.pl}

The macros access @code{Int}, @code{Symbol}, @code{Float} etc values of the current lexeme. However these are strored
in a location which is named a bit different. For example the string of a symbol is stored in the string
field of the lexeme. To be readable and to be compatible with future versions use these macros to access
lexeme values when lexeme has any of these types.

@example
/*
TO_HEADER:
#define lex_Int(x) lex_Long(x)
#define lex_Symbol(x) lex_String(x)
#define lex_Float(x) lex_Double(x)
#define lex_Char(x) lex_Long(x)
#define lex_Token(x) lex_Long(x)
#define lex_Code(x) lex_Long(x)
*/
/*
@end example
@subsubsection  lex_Finish()

Call this functionto release all memory allocated by the lexical analyzer.

@example
void lex_Finish(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_DumpLexemes()

Us this function for debugging. This function dumps the list of lexemes to the file @code{psDump}.

@example
void lex_DumpLexemes(pLexObject pLex,
                     FILE *psDump
  )@@{
@end example
@subsubsection  lex_ReadInput()

Call this function after proper initialization to read the input file. This function performs the laxical analysis and
builds up an internal linked list that contains the lexemes.

@example
int lex_ReadInput(pLexObject pLex
  )@@{
@end example
@subsubsection  lex_InitStructure()

You may but need not call this function to initialize a @code{LexObject}. You may
also call this function to use the settings of the function and set some
variables to different values after the function returns.

@example
void lex_InitStructure(pLexObject pLex
  )@@{
@end example
 



@section Syntax Analyzer

The syntax analyzer is a module that reads the token stream delivered by the lexer module and builds a memory data structure containing the syntactically analyzed and built program. The syntax analyzer is contained in the source file @file{expression.c} The name of this module come from the fact that the most important and most complex task of syntax analysis is the analysis of the expressions.

For the syntax analyzer the program is a series of commands. A command is a series of symbols. There is nothing like command blocks, or one command embedding another command. Therefore the syntax definition is quite simple and yet still powerful enough to define a BASIC like language.

Because syntax analysis is quite a complex task and the syntax analyzer built for ScriptBasic is quite a complex one I recommend that you first read the tutorial from the ScriptBasic web site that talks about the syntax analysis. This is a series of slides together with real audio voice explaining the structure of the syntax analyzer of ScriptBasic.

The syntax analyzer should be configured using a structure containing the configuration parameters and the global variables for the syntactical analyzer. This structure contains the pointer to the array containing the syntax definition. Each element of the array defines command syntax. Command syntax is the list of the symbols that construct the command. When the syntactical analyzer tries to analyze a line it tries the array elements until it finds one matching the line. When checking a line against a syntax definition the syntactical analyzer takes the lexical elements on the line and checks that they match the next symbol in the syntax definition. A symbol can be as simple as a reserved word, like @code{if} @code{else}, @code{endif}. Such a syntax element is matched by the specific keyword. On the other hand a symbol on the syntax definition can be as complex as an expression, which is matched by a whole expression.

The syntax analyzer has some built in assumption about the language, but the actual syntax is defined in tables. This way it is possible to analyze different languages using different tables in the same program even in the same process in separate threads.

When the syntax analyzer reads the syntax definition of a line and matches the tokens from the lexer against the syntax element it may do several things:

@itemize
@item recognizes that the syntax element matches the coming token and goes on
@item recognizes that the syntax element matches the coming token(s) and creates one or more new nodes in memory that hold the values associated with the tokens
@item recognizes the syntax element, does not match it against any token, and does some side effect
@end itemize

The first is the case when the syntax element is a constant symbol. For example it is a command keyword. In this case there is nothing to do with the keyword except that the syntax analyzer has to recognize that this is the statement identified by the keyword. The actual code will be generated later when non-constant syntactical elements are found.

When the syntax analyzer sees that the next syntax element is some variable, non-constant syntax element it matches the coming tokens and creates the nodes that hold the actual value for the tokens. For example when the syntax element is @code{string} the syntax analyzer checks that the coming token is a string and creates a node that holds the string. The most important example is the syntax element @code{expression}. In this case the syntax analyzer checks that the coming tokens form an expression and not only "consumes" these tokens, but creates several nodes that hold the structure of the expression.

We can distinguish between constant and variable symbolic definition elements.

@itemize
@item
A constant symbolic element is matched by a constant symbol. A constant symbolic element is a reserved keyword, or a special character that should appear at a certain position on the line.
@item
A variable symbolic element on the other hand is matched by several different actual values. The simplest example of a variable symbolic element is a number. A number in the syntax definition tells the analyzer that a number should appear at the position on the line. However it does not specify the value of the number. Any number can appear and is valid at the position. When a variable symbolic element is matched the actual value, which was presented on the line and matched the symbolic definition element is stored in the memory structure that the analyzer builds.
@end itemize

There are some special symbols that are always matched whenever they are checked by the syntax analyzer. They do not consume any lexical element from the line, and generate values in the memory structure that the analyzer builds.

The symbolic definition elements are:

@itemize
@item

@code{expression} This element matches an expression. When this syntax definition element should be matched the syntactical analyzer tries to work up an expression starting from the actual position in the lexical unit stream.
@item
@code{expression_list} This element matches a list of expressions separated by comma characters.
@item
@code{string} This element is matched by a single string. Whenever you think to use this syntax definition element consider using expression instead. This element matches only a single string and not an expression resulting string value.
@item
@code{integer} This element is matched by an integer number. Whenever you think to use this syntax definition element consider using expression instead. This element matches only a single string and not an expression resulting integer value.
@item
@code{float} This element is matched by an integer or float number. Whenever you think to use this syntax definition element consider using expression instead. This element matches only a single string and not an expression resulting integer or float value. Implementing a command that requires this symbolic element should accept integer values at the same location because this value matches any float or integer value. Any integer value passed on a float syntax location is converted to float during compile time. (Note that the C code does not use the C type float. All float numbers are stored and handled using the C type double.)
@item
@code{symbol} This element accepts a symbol. Before using this syntax definition element you should be familiar with the other elements that may accept a symbol for a certain role. You should use this element when wanting to deal with the actual name of the symbol during run time. Note however that there are other elements that you should consider before using this syntax definition element.
@item
@code{absolute_symbol} This element accepts a symbol similar to the syntax definition element symbol. The difference is that symbol accepts a relative symbol which is treated as belonging to the current name space unless explicit name space was defined. Absolute symbol is taken without any modification.
@item
@code{name_space} This syntax definition element is matched by an absolute symbol and sets the current name space.
@item


@code{end_name_space} this syntax definition element does not consume any lexical elements, but closes a name space and the surrounding name space is used afterwards.
@item
@code{lval} This element can be matched by a left value. That is some variable reference to which value can be assigned.
@item
@code{lval_list} This element can be matched by a list of left values. A list is several left values separated by commas.
@item
@code{local_start} This syntax definition element is always matched, and does not consume any lexical element from the list. When this syntax definition element is reached by the syntax analyzer it starts a new local scope. Such a point is usually the start of a function or procedure.
@item
@code{local_end} This syntax definition element is the pair of local start. This syntax definition element is always matched, and does not consume any lexical element from the list. When this syntax definition element is reached by the syntax analyzer it finishes the local scope. Such a point is usually the end of a function or procedure. Note that local scopes can not be nested.
@item
@code{local} This syntax definition element is matched by a symbol, which is treated as a local variable. The symbol is modified according to name space. The syntax definition element is not matched whenever it is tried to be used outside of local scope.
@item
@code{local_list} This symbol definition element is matched by a comma separated list of local.
@item
@code{function} This symbol definition element is matched by a symbol, which is treated as a function name. Note that the local scope does not automatically start when such a syntax definition element is matched.
@item
@code{thisfn} This symbol definition element is matched within a local scope by the name of the actual function or procedure. This is usually used to describe the assignment that assigns a return value to the function name.
@item
@code{label} This symbol definition matches a label, which is usually used after goto like instructions.
@item
@code{label_def} This symbol definition is matched by a symbol. This symbol is going to be treated as a label. All labels are global.
@item
@code{go_back}
@item
@code{go_forward}
@item
@code{come_back}
@item
@code{come_forward} These symbol definition elements should be used to define block and looping structures. Whenever an instruction like for/next or if/then/else is used it has to define where to continue execution based on the condition. The symbol definition elements go-forward and come-back place the current instruction location on a compile time stack. The symbol definition elements go-back and come-forward take the last element from the same stack. They also check that the location was placed on the stack by a matching construct, assuring that no out of order nesting structures appear, like @code{if/for/endif/next}.
@end itemize
Note that you can find other syntax definition elements in the file syntax.def. However these are converted to a character value by the Perl script tool syntaxer.pl These pseudo syntax definition elements are:
@itemize
@item
@code{nl} end of line ('\n' character)
@item
@code{tab} tab character ('\t' character)
@end itemize

@subsection Name Space
The scriba syntax analyzer implements a simple name space handling. A variable, label or function name always belongs to a name space. The default name space is @code{main}. When the syntax analyzer processes a non-absolute symbol it converts the name to contain the name space. A variable named @code{var} in the name space @code{main} has the name @code{main::var}. The syntax analyzer automatically converts the name to contain the name space, therefore @code{main::var} and @code{var} are equivalent when used in the name space @code{main}.

When a variable contains double colon it is treated as an absolute name, and no name space is prepended to it. If you are in the name space module and use the variable name @code{main::var} it will NOT be converted to @code{module::main::var}. The reason is that it already contains the characters @code{::} and therefore scriba assumes that it already contains the name space.

If you are in the name space module and want to refer to the variable @code{module::main::var} you can use the names @code{module::main::var} or @code{::main::var}. The first format contains all nested name spaces to the variable. The second version tells the syntax analyzer that the variable is relative, altough it contains double colon. This is because it starts with double colons.

If you are in name space @code{module::submodul} and want to refer to the variable @code{module::var} you can either write @code{module::var} or@code{ _::var}. The first format contains all nested name spaces to the variable. The second version tells the syntax analyzer that the variable is relative and the base module is the embedding module of the current one.

If you are familiar with the UNIX or DOS/Windows directory notation you can find similarities of file names and name space in scriba. In file names double dot means the parent directory. In scriba underscore character means the parent name space. You can use the @code{_} character not only in front of a name, but also within @code{::} characters. For example

@example
Main::module::var
Main::module::submodule::_::var
Main::_::Main::module::var
@end example

are equivalent.

Name spaces help to separate variables and to develop scripts cooperatively, but does not prohibit one name space to access variables or symbols of other name spaces.

@subsection Expression

The formal description of an expression syntax is:

@example
 tag ::= UNOP tag
         NUMBER
         STRING
         '(' expression ')'
         VARIABLE { '[' expression_list ']' }
         FUNC '(' expression_list ')'
         .

 expression_list ::= expression [ ',' expression_list ] .
 expression_i(1) ::= tag .
 expression_i(i) := expression_i(i-1) [ OP(i) expression_i(i) ] .
 expression ::= expression_i(MAX_PREC) .
@end example

where 
@itemize
@item @code{OP(i) }  is a binary operator having precdence I
@item @code{UNOP} is an unary operator
@item @code{NUMBER} is a number (float or integer)
@item @code{STRING} is a string
@item @code{VARIABLE} is a symbol that is to a local or global variable
@item @code{FUNC} is a function name, which is either a built-in function or a user defined function
@item @code{MAX_PREC} is the maximal precedence
@end itemize

The syntax analyzer is written to match an expression whenever an expression syntax definition element is to be matched according to these rules. The list of built-in function, unary operators and binary operators are defined in the module "global" variables, @code{BuiltInFunctions}, @code{Unaries}, and @code{Binaries}.



@subsection Functions implemented in this module

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.






The functions in this file compile a ScriptBasic expression into
internal form. The functions are quite general, and do NOT depend
on the actual operators that are implemented in the actual version.

This means that you can define extra operators as well as extra
built-in functions easily adding entries into tables and need not modify
the compiling code.

@subsubsection  What is an expression in ScriptBasic

Altough the syntax defintion in script basic is table driven and can easily be modified
expressions are not. The syntax of an expression is somewhat fix. Here we formally define
what the program thinks to be an expression. This restriction should not cause problem
in the usage of this module because this is the usual syntax of an expression. Any altering
to this would result in an expression syntax which is unusual, and therefore difficult to
use for the common users. The operators and functions along with therir precedence values are
defined in tables anyway, so you have flexibility.

The formal description of an expression syntax:

@example
 tag ::= UNOP tag
         NUMBER
         STRING
         '(' expression ')'
         VARIABLE @@{ '[' expression_list ']' @}
         VARIABLE '@@{' expression_list '@}'
         FUNC '(' expression_list ')'
         .

 expression_list ::= expression [ ',' expression_list ] .

 expression_i(1) ::= tag .

 expression_i(i) := expression_i(i-1) [ OP(i) expression_i(i) ] .

 expression ::= expression_i(MAX_PREC) .

 left_value ::= variable @@{ '[' expression_list ']' @} 
                variable '@@{' expression_list '@}' .

@end example

@itemize
@item UNOP

is unary operator as defined in tables in file operators.h

@item NUMBER 

is a number, lexical element.

@item STRING 

is a string, lexical element.

@item VARIABLE 

is a lexical element.

@item FUNC 

is a function either built in, or user defined

@item OP(i)

is an operator of precendece i as defined in tables.

@@end itemize


@subsubsection  ex_DumpVariables()

This function dumps the variables stored in the symbol table to the file pointed by
@code{fp}

@example
void ex_DumpVariables(SymbolTable q,
                      FILE *fp
  )@@{
@end example

Note that this function is a debug function.
@subsubsection  expression_PushNameSpace()

When a @code{module name} instruction is encountered the name space is modified. However
the old name space should be reset when an @code{end module} statement is reached. As the
modules can be nested into each other the name spaces are stored in a name space stack
during syntax analysis.

This function pushes the current name space onto the stack. After calling
this function the caller can put the new string into the @code{pEx-}>@code{CurrentNameSpace}
variable and later calling @xref{ex_PopNameSpace()@} can be called to retrive the saved name space.

@example
int expression_PushNameSpace(peXobject pEx
  )@@{
@end example
@subsubsection  ex_CheckUndefinedLabels()

This function traverses the label symbol table and reports all undefined
labels as error. Undefined labels reference the node with node-number zero. Jumping
on a label like that caused the program to stop instead of compile time error
in previous versions.

@example
void ex_CheckUndefinedLabels(peXobject pEx
  )@@{
@end example
@subsubsection  ex_CleanNameSpaceStack()

This function cleans the name space stack. This cleaning does not need to be done during
syntax analysis. It is needed after the analysis has been done to detect unclosed modules.

Note that the @code{main::} module is implicit and can not and should not be closed
unless it was explicitly opened.

The function calls the report function if the name space is not empty when the function is called.
@example
void ex_CleanNameSpaceStack(peXobject pEx
  )@@{
@end example
@subsubsection  expression_PopNameSpace()

When a @code{module name} instruction is encountered the name space is modified. However
the old name space should be reset when an @code{end module} statement is reached. As the
modules can be nested into each other the name spaces are stored in a name space stack
during syntax analysis.

This function pops the name space from the name space stack and copies the value to the
@code{pEx-}>@code{CurrentNameSpace} variable. This should be executed when a name space is closed
and we want to return to the embedding name space.

@example
int expression_PopNameSpace(peXobject pEx
  )@@{
@end example
@subsubsection  ex_PushWaitingLabel()

This function is used to define a label.

@example
int ex_PushWaitingLabel(peXobject pEx,
                         pSymbolLABEL pLbl
  )@@{
@end example

When a label is defined the @code{eNode_l} that the label is going to belong still does not exists, and
therefore the @code{NodeId} of that @code{eNode_l} is not known. This function together with @xref{ex_PopWaitingLabel()@}
maintains a stack that can store labels which are currently defined and still need a line to be assigned
to them. These labels all point to the same line. Altough it is very rare that many labels point to
the same line, it is possible. The number of labels that can point the same line is defined by the
constant @code{MAX_SAME_LABELS} defined in @code{expression.c}

To make it clear see the following BASIC code:

@example

this_is_a_label:
REM this is a comment
            PRINT "hello word!!"

@end example

The label is defined on the first line of the example. However the label belongs to the
third line containing the statement @code{PRINT}. When the label is processed the compiler does
not know the node number of the code segment which is generated from the third line. Therefore
this function maintains a label-stack to store all labels that need a line. Whenever a line is
compiled so that a label can be assigned to that very line the stack is emptied and all labels waiting on the
stack are assigned to the line just built up. (Or the line is assigned to the labels if you
like the sentence the other way around.)

Note that not only labels given by a label defining statement are pushed on this stack, but also
labels generated by commands like 'while/wend' of 'if/else/endif'.

@subsubsection  ex_PopWaitingLabel()

This function is used to get a label out of the waiting-label-stack.

@example
pSymbolLABEL ex_PopWaitingLabel(peXobject pEx
  )@@{
@end example

To get some description of waiting labels see the description of the function @xref{ex_PushWaitingLabel()@}.

@subsubsection  _ex_PushLabel()

This function is used to push an unnamed label on the compile time stack.
For more detailed defintion of the unnamed labels and this stack see the
documentation of the function @xref{ex_PopLabel()@}.

@example
int _ex_PushLabel(peXobject pEx,
                  pSymbolLABEL pLbl,
                  long Type,
                  void *pMemorySegment
  )@@{
@end example

The argument @code{Type} is used to define the type of the unnamed label. This is usually defined
in the table created by the program @code{syntaxer.pl}

=bold
Do NOT get confused! This stack is NOT the same as the waiting label stack. That is usually for named
labels.
=nobold

However the non-named labels are also pushed on that stack before they get value.

@subsubsection  _ex_PopLabel()

This function is used to pop an unnamed label off the compile stack.

When a construct, like @code{IF/ELSE/ENDIF} or @code{REPEAT/UNTIL} or @code{WHILE/WEND} is created
it is defined using compile time label stack.

For example analyzing the instruction @code{WHILE} pushes a "go forward" value on the compile time
label stack. When the instruction @code{WEND} is analyzed it pops off the value and stores
@code{NodeId} for the label. The label itself is not present in the global label symbol table,
because it is an unnamed label and is referenced during compile time by the pointer to the
label structure.

The value of the @code{AcceptedType} ensures that a @code{WEND} for example do not matches an @code{IF}.


@example
pSymbolLABEL _ex_PopLabel(peXobject pEx,
                          long *pAcceptedType
  )@@{
@end example

The array @code{pAcceptedType} is an array of long values that have @code{MAX_GO_CONSTANTS} values.
This is usually points to a static table element which is generated by the program @code{syntaxer.pl}.

=bold
Do NOT get confused! This stack is NOT the same as the waiting label stack. That is for named
labels.
=nobold
@subsubsection  _ex_CleanLabelStack()

This function is used to clean the unnamed label stack whenever
a locality is left. This helps to detect when an instruction like
@code{FOR} or @code{WHILE} is not closed within a function.
@example
void _ex_CleanLabelStack(peXobject pEx
  )@@{
@end example
@subsubsection  Some NOTE on SymbolXXX functions

The functions named @code{SymbolXXX} like @code{SymbolLABEL}, or @code{SymbolUF} do NOT store 
the names of the symbols. They are named @code{SymbolXXX} because they are natural
extensions of the symbol table system. In other compilers the functionality to
retrieve the arguments of a symbol is part of the symbol table handling routines.

In script basic the symbol table handling routines were developed to be general purpose.
Therefore all the arguments the symbol table functions bind toa symbol is a @code{void *}
pointer. This pointer points to a struct that holds the arguments of the symbols,
and the functions @code{SymbolXXX} allocate the storage for the arguments.

This way it is possible to allocate arguments for non-existing symbols, as it is done
for labels. Script basic uses non-named labels to arrange the "jump" instructions for
@code{IF/ELSE/ENDIF} constructs. (And for some other constructs as well.) The label and
jump constructs look like:

@example

       IF expression Then

       ELSE
label1:


       END IF
label2:

@end example

The labels @code{label1} and @code{label2} do not have names in the system, not even autogenerated names.
They are referenced via pointers and their value (the @code{NodeId} of the instruction) get into the
@code{SymbolLABEL} structure and later int o the @code{cNODE} during build.

@subsubsection  _new_SymbolLABEL()

This function should be used to create a new label. The label can be named or unnamed. Note that
this structure does NOT contain the name of the label.

@example
pSymbolLABEL _new_SymbolLABEL(peXobject pEx
  )@@{
@end example

Also note that all labels are global in a basic program and are subject to name space decoration.
However the same named label can not be used in two different functions in the same name space.

A label has a serial value, which is not actually used and a number of the node that it points to.

See the comments on @xref{ex_symbols()@}.
@subsubsection  _new_SymbolVAR()

This function should be used to create a new variable during compile time. A
variable is nothing else than a serial number. This serial number starts
from 1.

@example
pSymbolVAR _new_SymbolVAR(peXobject pEx,
                          int iLocal
  )@@{
@end example

The second argument should be true for local variables. The counting of local
variables are reset whenever the program enters a new locality. Localities can
not be nested.

Also note that local variables are allocated in a different segment because they
are deallocated whenever the syntax analyzer leaves a locality.
@subsubsection  _new_SymbolUF()

This function should be used to create a new user defined function symbol.
@example
pSymbolUF _new_SymbolUF(peXobject pEx
  )@@{
@end example

A user function is defined by its serial number (serial number is actually not used in the
current sytsem) and by the node number where the function actually starts.

The number of arguments and the number of local variables are defined in the generated
command and not in the symbol table. This way these numbers are available as they should be
during run time.
@subsubsection  _new_eNODE()

This function should be used to create a new @code{eNODE}.

@example
peNODE _new_eNODE(peXobject pEx
  )@@{
@end example

Each @code{eNODE} and @code{eNODE_l} structure has a serial number. The @code{eNODE}s
are referencing each other using pointers. However after build these pointers
become integer numbers that refer to the ordinal number of the node. Nodes are
stored in a single memory block after they are packed during build.

An @code{eNODE} is a structure that stores a unit of compiled code. For example
an addition in an expression is stored in an @code{eNODE} containing the code for the
addition operator and containing pointers to the operands.

@subsubsection  _new_eNODE_l()

This function should be used to create a new @code{eNODE} list. This is nothing else
than a simple structure having two pointers. One pointer points to an @code{eNODE}
while the other points to the next @code{eNODE_l} struct or to NULL if the current
@code{eNODE_l} is the last of a list.

@example
peNODE_l _new_eNODE_l(peXobject pEx,
                      char *pszFileName,
                      long lLineNumber
  )@@{
@end example

Note that @code{eNODE} and @code{eNODE_l} are converted to the same type of 
structure during build after the syntactical analysis is done.
@subsubsection  ex_free()

This function releases all memory that was allocated during syntax analysis.

@example
void ex_free(peXobject pEx
  )@@{
@end example
@subsubsection  ex_init()

This function should be called before starting syntactical analysis. This
function 
@itemize
@item positions the lexeme pointer to the first lexeme,
@item initializes the memory segments needed for structured memory allocation, 
@item created the symbol tables
@item initializes 'class' variables
@item initializes the name space to be @code{main::}
@@end itemize

@example
int ex_init(peXobject pEx
  )@@{
@end example
@subsubsection  ex_CleanNamePath()

This function created a normalized name space name from a non normalized. This is a simple
string operation.

Think of name space as directories and variables as files. A simple variable name is in the
current name space. If there is a 'path' before the variable or function name the path has to be
used. This path can either be relative or absolute.

File system:

@code{ ../ } is used to denote the parent directory in file systems.

Name space:

@code{ _::} is used to denote the parent name space.

File system:

@code{ mydir/../yourdir} is the same as @code{yourdir}

Name space:

@code{ myns::_::yourns} is the same as @code{yourns}

This function removes the unneccesary downs and ups from the name space and creates the
result in the same buffer as the original. This can always be done as the result is always 
shorter. (Well, not longer.)

@example
void ex_CleanNamePath(char *s
  )@@{
@end example
@subsubsection  ex_ConvertName()

Use this function to convert a relative name to absolute containing name space.

This function checks if the variable or function name is relative or absolute. If the
name is relative it creates the absolute name using the current name space as a base.

The result is always put into the @code{Buffer}.

A name is relative if it does NOT contain @code{::} at all (implicit relative),
if it starts with @code{::} or is it starts with @code{_::} (explicit relative).

@example
int ex_ConvertName(char *s,          /* name to convert            */
                   char *Buffer,     /* buffer to store the result */
                   size_t cbBuffer,  /* size of the buffer         */
                   peXobject pEx     /* current expression object  */
  )@@{
@end example

The error value is @code{EX_ERROR_SUCCESS} (zero) menaing succesful conversion or
@code{EX_ERROR_TOO_LONG_VARIABLE} meaning that the variable is too long for the
buffer.

Note that the buffer is allocated in @xref{ex_init()@} according to the size value given in
the class variable @code{cbBuffer}, which should be set by the main function calling
syntax analysis.
@subsubsection  ex_IsBFun()

This function checks if the current lexeme is a built-in function and
returns pointer to the function in the table @code{BuiltInFunctions} or
returns NULL if the symbol is not a built-in function.

@example
pBFun ex_IsBFun(peXobject pEx
  )@@{
@end example
@subsubsection  ex_IsUnop()

This function checks if the current lexeme is an unary operator and
returns the op code or zero if the lexem is not an unary operator.

@example
unsigned long ex_IsUnop(peXobject pEx
  )@@{
@end example
@subsubsection  ex_IsBinop()

This function checks if the current lexeme is a binary operator of the given precedence
and returns the op code or zero.

@example
unsigned long ex_IsBinop(peXobject pEx,
               unsigned long precedence
  )@@{
@end example
@subsubsection  ex_LeftValueList()

This function works up a @code{leftvalue_list} pseudo terminal and creates the nodes for it.

@example
peNODE_l ex_LeftValueList(peXobject pEx
  )@@{
@end example
@subsubsection  ex_ExpressionList()

This function works up an @code{expression_list} pseudo terminal and creates
the nodes for it.
@example
peNODE_l ex_ExpressionList(peXobject pEx
  )@@{
@end example
@subsubsection  ex_Local()

This function work up a @code{local} pseudo terminal. This does not create any node.

@example
int ex_Local(peXobject pEx
  )@@{
@end example
The return value is @code{0} if no error happens.

@code{1} means sytax error (the coming token is not a symbol)

@code{2} means that there is no local environment (aka. the @code{local var} is not inside a function)
@subsubsection  ex_LocalList()

This function work up a @code{local_list} pseudo terminal. This does not generate any node.

@example
int ex_LocalList(peXobject pEx
  )@@{
@end example
The return value is @code{0} if no error happens.

@code{1} means sytax error (the coming token is not a symbol)

@code{2} means that there is no local environment (aka. the @code{local var} is not inside a function)
@subsubsection  ex_Global()

This function work up a @code{global} pseudo terminal. This does not create any node.

@example
int ex_Global(peXobject pEx
  )@@{
@end example
The return value is @code{0} if no error happens or the error is semantic and was
reported (global variable redefinition).

@code{1} means syntax error (the coming token is not a symbol)

@subsubsection  ex_GlobalList()

This function work up a @code{global_list} pseudo terminal. This does not generate any node.

@example
int ex_GlobalList(peXobject pEx
  )@@{
@end example
The return value is @code{0} if no error happens.

@code{1} means sytax error (the coming token is not a symbol)

@code{2} means the variable was already defined
@subsubsection  ex_LookupUserFunction()

This function searches a user defined function and returns a pointer to the symbol table entry.
If the second argument @code{iInsert} is true the symbol is inserted into the table and an
undefined function is created. This is the case when a function is used before declared. If the
argument @code{iInsert} is fales @code{NULL} is returned if the function is not yet defined.

@example
void **ex_LookupUserFunction(peXobject pEx,
                             int iInsert
  )@@{
@end example
@subsubsection  ex_LookupGlobalVariable

This function searches the global variable symbol table to find the global variable
with the name stored in @@code@@{pEx->Buffer@}. If the variable was not declared then this function
inserts the variable into the symbol table if the argument @code{iInsert} is true,
but nothing more: the symbol table entry remains @code{NULL}.

@example
void **ex_LookupGlobalVariable(peXobject pEx,
                               int iInsert
  )@@{
@end example
The function returns pointer to the pointer stored in the symbol table associated with the global
variable.
@subsubsection  ex_LookupLocallyDeclaredGlobalVariable

This function searches the global variable symbol table to find the global variable
with the name stored in @@code@@{pEx->Buffer@}. If the variable was not declared then this function
return @code{NULL}. Othervise it returns a pointer to a @code{void *} pointer, which is 
@code{NULL}.

Note that this table is allocated when the program starts a @code{sub} or @code{function} (aka. when
we go local) and is used to register, which variables did the program declare
as global variables inside the subroutine. There is no any value associated with the symbols
in this table, as the symbols are also inserted into the global symbol table which serves
the purpose.

@example
void **ex_LookupLocallyDeclaredGlobalVariable(peXobject pEx
  )@@{
@end example
The function returns pointer to the pointer stored in the symbol table associated with the global
variable or @code{NULL}.
@subsubsection  ex_LookupLocalVariable

This function searches the local variable symbol table to find the local variable
with the name stored in @@code@@{pEx->Buffer@}. If the variable was not declared and the argument @code{iInsert}
is true then then this function inserts the variable into the symbol table, 
but nothing more: the symbol table entry remains
@code{NULL}.

@example
void **ex_LookupLocalVariable(peXobject pEx,
                              int iInsert
  )@@{
@end example
The function returns pointer to the pointer stored in the symbol table associated with the global
variable.
@subsubsection  ex_Tag

This function implements the syntax analysis for the lowest syntax elements of an expression.
This function is called when syntax analysis believes that a TAG has to be worked up
in an expression. A tag is defined formally as

@example
 tag ::= UNOP tag
         BUN '(' expression_list ')'
         NUMBER
         STRING
         '(' expression ')'
         VARIABLE @@{ '[' expression_list ']' @}
         VARIABLE '@@{' expression_list '@}'
         FUNC '(' expression_list ')'
        .
@end example

@example
peNODE ex_Tag(peXobject pEx
  )@@{
@end example
The function returns pointer to the new node.
@subsubsection  ex_Expression_i

This function is called to analyze a sub-expression that has no lower precedence operators
than @code{i} (unless enclosed in parentheses inside the sub expression).

If the argument variable @code{i} is @code{1} then this function simply calls @xref{ex_Tag@}. Otherwise it
calls itself recursively twice with optionally compiling the operator between the 
two subexpressions.

@example
peNODE ex_Expression_i(peXobject pEx,
                       int i
  )@@{
@end example
The function returns pointer to the new node.
@subsubsection  ex_Expression_r

This function implements the syntax analysis for an expression. This is quite simple. It only
calls @xref{ex_Expression_i@} to handle the lower precendece expression. 
@example
void ex_Expression_r(peXobject pEx,
                     peNODE *Result
  )@@{
@end example
@subsubsection  ex_IsSymbolValidLval(pEx)

This function checks whether the actual symbol used in as a start symbol of a left value
is defined as a CONST in the BASIC program or not. If this is a const then the syntax analizer
has to report an error (since v1.0b31).

This function is called from the function @xref{ex_LeftValue@} after the symbol was name space corrected.

Note that a symbol can be a global, name space independant constant, a name space local constant and
a function local constant. All these differ only in name decoration inside the interpreter.

If a symbol is a local variable but is also a module or global symbol, but is NOT a function local symbol
then that variable can indeed stand on the left side of a LET command. Therefore we check if the symbol
is in the local variables table and in case this is in some of the global or module contant table,
we just do not care.
@example
int ex_IsSymbolValidLval(peXobject pEx
  )@@{
@end example
The function returns 1 if the symbol is a constant or zero if not.
@subsubsection  ex_LeftValue

This function implements the syntax analisys for a left value.

@example
peNODE ex_LeftValue(peXobject pEx
  )@@{
@end example
The function returns pointer to the new node.
@subsubsection  ex_PredeclareGlobalLongConst()

This function is used to declare the global constants that are given
in the syntax defintinon, and should be defined before the program
is started to be analized.

@example
int ex_PredeclareGlobalLongConst(peXobject pEx,
                                 char *pszConstName,
                                 long lConstValue
  )@@{
@end example
@subsubsection  ex_IsCommandThis

This is the most general syntax analysis function that tries to match the syntax
of the actual line syntax provided in argument @code{p} against the token list at the actual
position.

The function has several side effects altering optionally the global and local variable table,
define user defined functions and so on.

The function signals the success of its operation via the argument @code{piFailure} setting the @code{int}
pointed by it to be zero or the error code.

If the syntax does not match the token list then the function cleans up all its actions if possible
to allow the caller to iterate over to the next syntax defintion. In such a situation
@code{*piFailure} is set @code{EX_ERROR_SYNTAX}

If the syntax does not match the token list but the analysis went too far and had side effects that
cannot be reversed then no cleanup is made. In such a situation @code{*piFailure} is set
@code{EX_ERROR_SYNTAX_FATAL}.

@code{*piFailure} is also set to this value if the syntax definition reaches a "star" point. If the syntax
analysis matches a line up to a "star" point then the line should match that syntax definition or is
known erroneous. For example a command starting with the two keywords @code{'declare' 'command'} after these
two keywords reach a "star" point because no other line syntax but extrenal command declaration starts
with these two keywords. In such a situation signalling fatal syntax error saves the compiler time
to check other syntax definition.

A "star" point is named this way, because the file @code{syntax.def} uses the character @code{*} to denote
this point in the syntax definitions.

@example
peNODE ex_IsCommandThis(peXobject pEx,
                        pLineSyntax p,
                        int *piFailure
  )@@{
@end example
If the syntax analysis fully matches the syntax definition provided in the argument
then the function returns the node that was generated. If more then one nodes were generated
during the syntax analysis of the line then the root node of the generated nodes is returned.
@subsubsection  ex_Command_r()

This function finds the matching sytax line for the actual line in a loop. It
starts with the first syntax definition and goes on until there are no more
syntax defintions, a fatal error has happened or the actual line is matched.

@example
void ex_Command_r(peXobject pEx,
                  peNODE *Result,
                  int *piFailure
  )@@{
@end example
@code{pEx} is the execution object.

@code{Result} is the resulting node.

@code{piFailure} is the error code.

@subsubsection  ex_Command_l()

This function goes over the source lines and performs the syntax analysis. This 
function calls the function @xref{ex_Command_r()@}. When that function returns it
allocated the list nodes that chain up the individual lines. It also defines
the labels that are waiting to be defined.

@example
int ex_Command_l(peXobject pEx,
                  peNODE_l *Result
  )@@{
@end example
When all the lines are done this function cleans the name space stack,
check for undefined labels that remained undefined still the end 
of the source file.

@subsubsection  ex_Pragma

This function implements the compiler directive "declare option".

When the compiler finds a "declare option" directive it calls this function.
The first argument is the compiler class pointer. The second argument points
to a constant string containing the option.

The function implements the internal settings of the compiler options reflecting
the programmer needs expressed by the option. For example DeclareVars will
require all variables declared to be either global or local.

If the programmer specified an option, which is not implemented the error reporting
function is called.

@example
int ex_Pragma(peXobject pEx,
              char *pszPragma
  )@@{
@end example

The function returns @code{0} when the option was processed, and @code{1} when not implemented
option was supplied as argument.
@subsubsection  ex_IsCommandCALL()

Because the syntax of a call statement is very special here is a special
function to analyze the CALL statement.

A call statement is a keyword CALL followed by a function call.

If the function or sub is already defined then the keyword CALL can be missing.

When the function or sub is called this way and not inseide an expression the
enclosing parentheses can be missing.

@example
peNODE ex_IsCommandCALL(peXobject pEx,
                        pLineSyntax p,
                        int *piFailure
  )@@{
@end example

To get some description of waiting labels see the description of the function @xref{ex_PushWaitingLabel()@}.

@subsubsection  ex_IsCommandOPEN()

The open statement is a simple one. The only problem is that the last parameter
defining the length of a record is optional. This can only be handled using a separate
function

@example
peNODE ex_IsCommandOPEN(peXobject pEx,
                        pLineSyntax p,
                        int *piFailure
  )@@{
@end example

'open' expression 'for' absolute_symbol 'as' expression 'len' '=' expression nl

@subsubsection  ex_IsCommandSLIF()

If syntax analysis gets to calling this function the command is surely
not single line if, because the command SLIF is recognised by @code{IsCommandIF}.

The syntax of the command IF is presented in the syntax table before
SLIF and therefore if the syntax analyser gets here it can not be
SLIF.

The original function @code{IsCommandThis} could also do failing automatically,
but it is simpler just to fail after the function call, so this function
is just a bit of speedup.
@example
peNODE ex_IsCommandSLIF(peXobject pEx,
                        pLineSyntax p,
                        int *piFailure
  )@@{
@end example
@subsubsection  ex_IsCommandIF()

The statement IF is quite simple. However there is another
command that has almost the same syntax as the IF statement.
This is the SLIF, single line IF.

The difference between the command IF and SLIF is that SLIF does
not have the new line character after the keyword @code{THEN}.

@example
peNODE ex_IsCommandIF(peXobject pEx,
                        pLineSyntax p,
                        int *piFailure
  )@@{
@end example

IF/IF:    'if' * expression 'then' go_forward(IF) nl
SLIF/SLIF:  'slif' * expression 'then'


@subsubsection  ex_IsCommandLET()

@example
peNODE ex_IsCommandLET(peXobject pEx,
                       pLineSyntax p,
                       int *piFailure
  )@@{
@end example

 


@section Builder

The module is implemented in the file @file{builder.c}.

The rule of the builder is to compile the code created by the syntax analyzer into a continuous memory area. This compilation phase has two advantages. First of all it results a compact code which can easily saved into external file and can also be loaded making recompilation unnecessary before each execution. The second advantage is that the resulting code is smaller and saves memory.

When the syntax analyzer starts its work the final size of the code is not known. Therefore the syntax analyzer starts to build up a memory structure using pointers, linked lists allocating memory step by step as the code grows. Each command, expression element is stored in an internal structure, which is called a node. For example a node containing the operation "plus" contains the node type, which says it is an operator "plus" and contains two pointers to the two operands. The operands are also nodes. If the operand is a number the node contains the value of the number and the node type telling that it is a @code{long} or @code{double} number. If the operand is a variable the node type tells that the node is a variable and the node contains the serial number of the variable. If the operand needs further evaluation then the node is probably an operation having arguments pointed by pointers.


The structure that the builder creates is same as that of the syntax analyzer but it is allocated in a single memory chunk and instead of pointers it uses indices to refer a node from another. These indices are numbered from 1 and not from zero. This is because the index zero is used for @code{NULL} pointer if you know what I mean.

@subsection Node Structure

Have a look at the C definition of a node:

@example
typedef struct _cNODE {
  long OpCode; // the code of operation
  union {
    struct {// when the node is a command
      unsigned long next;
      union {
        unsigned long pNode;// node id of the node
        long lLongValue;
        double dDoubleValue;
        unsigned long szStringValue;
        }Argument;
      }CommandArgument;
    struct {//when the node is an operation
      unsigned long Argument;//node id of the node list head
      }Arguments;
    union {// when the node is a constant

      double dValue;        
      long   lValue;        
      unsigned long sValue; // serial value of the string from the string table       
      }Constant;
    struct {// when the node is a variable
      unsigned long Serial;// the serial number of the variable
      }Variable;
    struct {// when node is a user functions
      unsigned long NodeId; // the entry point of the function
      unsigned long Argument; // node id of the node list head
      }UserFunction;
    struct {// when the node is a node list head
      unsigned long actualm; //car
      unsigned long rest;    //cdr
      }NodeList;
    }Parameter;
  } cNODE,*pcNODE;
@end example

The field @code{OpCode} is the same as the code used in the lexer or the syntax analyzer. In case of an @code{IF} statement it is @code{CMD_IF}. This field can, should and is used to identify which part of the union @code{Parameter} is to be used.

The individual lines of the BASIC program that create code are chained into a list. Each line has a head node. The @code{OpCode} of the head nodes is @code{eNTYPE_LST}. This type of node contains @code{NodeList} structure. The field @code{NodeList.actualm} contains the index of the first node of the actual line and the field @code{NodeList.rest} contains the index of the next header node.

This type of node is used to gather expression lists into a linked list.

Note that usually not the first node in the byte-code is the first head node, where the code is to be started. The nodes generated from a line are created before the head node is allocated in the syntax analyzer and the head node thus gets a larger serial number. The builder uses the serial numbers counted by the syntax analyzer and does not rearrange the nodes.

The command node that the field @code{NodeList.actualm} "points" contains the opcode of the command. For example if the actual command is @code{IF} then the @code{OpCode} is @code{CMD_IF}.

In case of command nodes the @code{Parameter} is @code{CommandArgument}. If the command has only a single argument the field @code{next} is zero. Otherwise this field contains the node index of the node holding the next argument.

The @code{Parameter.CommandArgument.Argument} union contains the actual argument of the command. There is no indication in the data structure what type the argument is. The command has to know what kind of arguments it gets, and should not interpret the union different.

The field @code{pNode} is the node index of the parameter. This is the case for example when the parameter is an expression or a label to jump to.

The fields @code{lLongValue}, @code{dDoubleValue} and @code{szStringValue} contain the constant values in case the argument is a constant. However this is actually not the string that is stored in the field @code{szStringValue} but the index to the string table where the string is started. (Yes, here is some inconsistency in naming.)

Strings are stored in a string table where each string is stored one after the other. Each string is terminated with a zero character and each string is preceded by a @code{long} value that indicates the length of the string. The zero character termination eases the use of the string constants when they have to be passed to the operating system avoiding the need to copy the strings in some cases.


The field @code{Parameter.CommandArgument.next} is zero in case there are no more arguments of the command, or the index of the node containing the next argument. The @code{OpCode} field of the following arguments is @code{eNTYPE_CRG}.

When the node is part of an expression and represents an operation or the call of a built-in function then the @code{Arguments} structure of the @code{Parameter} union is to be used. This simply contains @code{Argument} that "points" to a list of "list" nodes that list the arguments in a list. In this case the @code{OpCode} is the code of the built-in function or operation.

When the node represents a string or a numeric constant the @code{Constant} union field of the union @code{Parameter} should be used. This stores the constant value similar as the field @code{CommandArgument} except that it can only be @code{long}, @code{double} or a string. In case of constant node the @code{OpCode} is  @code{eNTYPE_DBL} for a @code{double}, @code{eNTYPE_LNG} for a @code{long} and @code{eNTYPE_STR} for a string.

When the node represents a variable the field @code{Variable} has to be used. In this case the field @code{Serial} contains the serial number of the variable. To distinguish between local and global variables the @code{OpCode} is either @code{eNTYPE_LVR} for local variables or @code{eNTYPE_GVR} for global variables.

When the node is a user defined function call the field @code{UserFunction} is used. Note that this is not the node that is generated from the line @code{sub/function myfunc} but rather when the function or subroutine is called. The @code{OpCode} is @code{eNTYPE_FUN}.

The field @code{NodeId} is the index of the node where the function or subroutine starts. The field @code{Argument} is the index of the list node that starts the list of the argument expressions.

@subsection Binary File Format

The built code is usually saved to a cache file and this file is used later to load the already compiled code into memory for subsequent execution. The format of this file can be read from the function @code{build_SaveCode} in file @file{builder.c}. This function is quite linear it just saves several structures and is well commented so you should not have problem to understand it. However here I also give some description on the format of the binary file.

The binary file may or may not start with a textual line. This line is the usual UNIX @code{#! /usr/bin/scriba} string telling the operating system how to execute the text file. Altough we are talking now about a binary file, from the operating system point of view this is just a file, like a ScriptBasic source file, a Perl script or a @code{bash} script. The operating system starts to read the file and if the start of the file is something like

@example
#! /usr/bin/scriba\n
@end example

with a new-line character at the end then it can be executed from the command line if some other permission related constraints are met.

When ScriptBasic saves the binary format file it uses the same executable path that was given in the source file. If the source file starts with the line
@code{#! /usr/bin/mypath/scriba} and the basic progam @file{myprog.bas} was started using the command line

@example
/usr/bin/scriba -o myprog.bbf myprog.bas
@end example

then the file @file{myprog.bbf} will start with the line @code{#! /usr/bin/mypath/scriba}.

The user's guide lists a small BASIC program that reads and writes the binary file and alters this line.

Having this line on the first place in the binary format BASIC file makes it possible to deliver programs in compiled format. For example you may develop a CGI application and deliver it as compiled format to protect your program from the customer. You can convert your source issuing the command line

@example
/usr/bin/scriba -o outputdirectory/myprog.bas myprog.bas
@end example

and deliver the binary @file{myprog.bas} to the customer. ScriptBasic does not care the file extension and does not expect a file with the extension @code{.bas} to be source BASIC. It automatically recognizes binary format BASIC programs and thus you need no alter even the URLs that refer to CGI BASIC programs.

The next byte in the file following this optional opening line is the size of a @code{long} on the machine the code was created. The binary code is not necessarily portable from one machine to another. It depends on pointer and @code{long} size as well as byte ordering. We experienced Windows NT and Linux to create the same binary file but this is not a must, may change.

The size of a @code{long} is stored in a single character as @code{sizeof(long)+0x30} so the ASCII character is either @code{'4'} or @code{'8'} on 32 and 64 bit machines.

This byte is followed by the version information. This is a @code{struct}:

@example
  unsigned long MagicCode;
  unsigned long VersionHigh, VersionLow;
  unsigned long MyVersionHigh,MyVersionLow;
  unsigned long Build;
  unsigned long Date;
  unsigned char Variation[9];
@end example

The @code{MagicCode} is @code{0x1A534142}. On DOS based system this is the characters 'BAS' and @code{^Z} which means end of text file. Thus if you issue the command

@example
C:\> type mybinaryprogram.bbf
@end example

you will get

@example
4BAS
@end example

without scrambling your screen. If you use UNIX system then be clever enough not to @code{cat} a binary program to the terminal.

The values @code{VersionHigh} and @code{VersionLow} are the version number of ScriptBasic core code. This is currently @code{1} and @code{0}. The fields @code{MyVersionHigh} and @code{MyVersionLow} are reserved for developers who develop a variation of ScriptBasic. The variation may alter some features and still is based on the same version of the core code. These two version fields are reserved here to distinguish between different variation versions based on the same core ScriptBasic code. To maintain these version numbers is essential for those who embed ScriptBasic into an application, especially if the different versions of the variations alter the binary file format which I doubt is really needed.

The field @code{Build} is the build of the core ScriptBasic code.

The @code{Date} is date when the file @file{builder.c} was compiled. The date is stored in a @code{long} in a tricky way that ensures that no two days result the same @code{long} number. In case you want to track how this is coded see the function @code{build_MagicCode} in file @file{builder.c}. This is really tricky.


The final field is @code{Variation} which is and should be an exactly 8 character long string and a zero character.

If you want to compile a different variation then alter the @code{#define} directives in the file @file{builder.c}

@example
#define VERSION_HIGH 0x00000001
#define VERSION_LOW  0x00000000
#define MYVERSION_HIGH 0x00000000
#define MYVERSION_LOW  0x00000000
#define VARIATION "STANDARD"
@end example



To successfully load a binary format file to run in ScriptBasic the long size, the magic code, version information including the build and the variation string should match. Date may be different.

The following foru @code{long} numbers in the binary file define 
@itemize
@item the number of global variables, 
@item the number of the nodes of the compiled program
@item the index of the start node where the execution should be started
@item the length of the string table
@end itemize

This is followed by the nodes themselves and the stringtable.

This is the last point that has to exist in a binary format file of a BASIC program. The following bytes are optional and may not be present in the file.

The optional part contains the size of the function table defined on a @code{long} and the function table. After this the size of the global variable table is stored in a @code{long} and the global variable table.

The global variable and function symbol table are list of elements, each containing a @code{long} followed by the zero character terminated symbolic name. The @code{long} stores the serial number of the variable or the entry point of the function (the node index where the function starts).

These two tables are not used by ScriptBasic by itself, ScriptBasic does not need any symbolic information to execute a BASIC program. Programmers embedding ScriptBasic however demanded access global variables by name and the ability to execute individual functions from a BASIC program. If this last part is missing from a binary format BASIC program you will not be able to use in an application that uses these features.


@subsection Functions implemented in this module

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.







This module can and should be used to create the memory image for the
executor module from the memory structure that was created by the module
@code{expression}.

The memory structure created by @code{expression} is segmented, allocated
in many separate memory chunks. When the module @code{expression} has been finished
the size of the memory is known. This builder creates a single memory 
chunk containing all the program code.

Note that the function names all start with the prefix @code{build_} in this module.

The first argument to each function is a pointer to a @code{BuildObject} structure
that contains the "global" variables for the module. This technique is used to ensure
multithread usage. There are no global variables which are really global within the
process.

The functions in this module are:

=toc

@subsubsection  The structure of the string table

The string table contains all string contansts that are used in the program.
This includes the single and multi line strings as well as symbols. (note that
even the variable name after the keyword @code{next} is ignored but stored in the
string table).

The strings in the string table are stored one after the other zero character
terminated. Older version of ScriptBasic v1.0b21 and before stored string
constants zero character terminated. Because of this string constants containing
zero character were truncated (note that @code{\000} creates a zero character in a
string constant in ScriptBasic).

The version v1.0b22 changed the way string constants are stored and the way
string table contains the strings. Each string is stored with its length.
The length is stored as a @code{long} on @code{sizeof(long)} bytes. This is followed by
the string. Whenever the code refers to a string the byte offset of the first
character of the string is stored in the built code. For example the very first
string starts on the 4. byte on 32 bit machines.

Altough the string length and zero terminating characters are redundant information
both are stored to avoid higher level mistakes causing problem.
@subsubsection  build_AllocateStringTable()

This function allocates space for the string table. The size of the
string table is already determined during syntax analysis. The determined
size should be enough. In some cases when there are repeated string constants
the calculated sizte is bigger than the real one. In that case the larger memory
is allocated and used, but only the really used part is written to the cache file.

If the program does not use any string constants then a dummy string table of length
one byte is allocated.

@example
void build_AllocateStringTable(pBuildObject pBuild,
                          int *piFailure
  )@@{
@end example

The first argument is the usual pointer to the "class" structure. The second argument
is the result value. It can have two values:

@itemize
@item @code{BU_ERROR_SUCCESS} which is guaranteed zero, means the function was successful.
@item @code{BU_ERROR_MEMORY_LOW} means the memory allocation function could not allocate the
neccessary memory
@@end itemize

The string table is allocated using the function @code{alloc_Alloc}. The string table
is pointed by the class variable @code{StringTable}. The size of the table is stored in
@code{cStringTable}

@subsubsection  build_StringIndex()

In the built code all the strings are references using the offset of the string
from the string table (See @xref{build_AllocateStringTable()@}). This function calculates this value
for the string.

This function is used repetitively during the code building. Whenever a string index is
sought that is not in the string table yet the string is put into the table and the
index is returned.

If there is not enough space in the string table the function calls the system function
@code{exit} and stops the process. This is rude especially in a multithread application
but it should not ever happen. If this happens then it is a serious internal error.
@example
unsigned long build_StringIndex(pBuildObject pBuild,
                                char *s,
                                long sLen
  )@@{
@end example
@subsubsection  build_Build_l()

This function converts an @code{eNODE_l} list to @code{cNODE} list in a loop.
This function is called from @xref{build_Build()@} and from @xref{build_Build_r()@}.

@example
int build_Build_l(pBuildObject pBuild,
                  peNODE_l Result
  )@@{
@end example
The function returns the error code, or zero in case of success.

@subsubsection  build_Build_r()

This function builds a single node. This actually means copiing the values
from the data structure created by the module @code{expression}. The major
difference is that the pointers of the original structure are converted to
@code{unsigned long}. Whenever a pointer pointed to a @code{eNODE} the @code{unsigned long}
will contain the @code{NodeId} of the node. This ID is the same for the @code{eNODE} and
for the @code{cNODE} that is built from the @code{eNODE}.

@example
int build_Build_r(pBuildObject pBuild,
                  peNODE Result
  )@@{
@end example

The node to be converted is passed by the pointer @code{Result}. The return value is
the error code. It is zero (@code{BU_ERRROR_SUCCESS}) in case of success.

When the node pointed by @code{Result} references other nodes the function recursively
calls itself to convert the referenced nodes.

@subsubsection  build_Build()

This is the main entry function for this module. This function initializes the
class variable pointed by @code{pBuild} and calls @xref{build_Build_l()@} to build up the 
command list.
@example
int build_Build(pBuildObject pBuild
  )@@{
@end example
@subsubsection  build_MagicCode()

This is a simple and magical calculation that converts any ascii date to
a single unsigned long. This is used as a magic value in the binary format
of the compiled basic code to help distinguish incompatible versions.

This function also fills in the sVersion static struct that contains the version
info.
@example
unsigned long build_MagicCode(pVersionInfo p
  )@@{
@end example
@subsubsection  build_SaveCCode()

This function saves the binary code of the program into the file
given by the name @code{szFileName} in C programming language format.

The saved file can be compiled using a C compiler on the platform it was
saved. The generated C file is not portable.

@example
void build_SaveCCode(pBuildObject pBuild,
                    char *szFileName
  )@@{
@end example
@subsubsection  build_SaveCorePart()

This function saves the binary content of the compiled file into an
already opened file. This is called from both @code{build_SaveCode} and from
@code{build_SaveECode}.

Arguments:
@itemize
@item @code{pBuild} is the build object
@item @code{fp} is the @code{FILE *} file pointer to an already binary write opened (@code{"wb"}) file.
@@end itemize

The file @code{fp} is not closed even if error occures while writing the file.

@example
int build_SaveCorePart(pBuildObject pBuild,
                       FILE *fp,
                       unsigned long fFlag
  )@@{
@end example
The function returns @code{BU_ERROR_SUCCESS} (zero) if there was no error or @code{BU_ERROR_FAIL} if the function fails
writing the file.
@subsubsection  build_SaveCore()

This function saves the binary content of the compiled file into an
already opened file. This is called from both @code{build_SaveCode} and from
@code{build_SaveECode}.

Arguments:
@itemize
@item @code{pBuild} is the build object
@item @code{fp} is the @code{FILE *} file pointer to an already binary write opened (@code{"wb"}) file.
@@end itemize

The file @code{fp} is not closed even if error occures while writing the file.

@example
int build_SaveCore(pBuildObject pBuild,
                   FILE *fp
  )@@{
@end example
The function returns @code{BU_ERROR_SUCCESS} (zero) if there was no error or @code{BU_ERROR_FAIL} if the function fails
writing the file.
@subsubsection  build_SaveCode()

This function saves the binary code of the program into the file
given by the name @code{szFileName}.

This version is hard wired saving the code into an operating system
file because it uses @code{fopen}, @code{fclose} and @code{fwrite}. Later versions
may use other compatible functions passed as argument and thus allowing
output redirection to other storage media (a database for example).

However I think that this code is quite simple and therefore it is easier
to rewrite the whole function along with @xref{build_LoadCode()@} for other storage
media than writing an interface function.

The saved binary code is NOT portable. It saves the internal values
as memory image to the disk. It means that the size of the code depends
on the actual size of long, char, int and other types. The byte ordering
is also system dependant.

The saved binary code can only be loaded with the same version, and build of
the program, therefore it is vital to distinguish each compilation of
the program. To help the recognition of the different versions, the code starts
with a version structure.

The very first byte of the code contains the size of the long on the target machine.
If this is not correct then the code was created on a different processor and the code
is incompatible.

The version info structure has the following fileds:
@itemize
@item @code{MagicCode} is a magic constant. This contains the characters BAS and a character 1A that
stops output to screen on DOS operating systems.
@item @code{VersionHigh} The high part of the version of the STANDARD version.
@item @code{VersionLow} The low part of the version of the STANDARD version.
@item @code{MyVersionHigh} The high part of the version of the variation.
This is always zero for the STANDARD version.
@item @code{MyVersionLow}  The low part of the version of the variation.
This is always zero for the STANDARD version.
@item @code{Build} A build code which is automatically calculated from the compilation date.
@item @code{Variation} 8 characters (NOT ZERO TERMINATED!) naming the version "STANDARD" for the
STANDARD version (obvious?)
@@end itemize

@example
int build_SaveCode(pBuildObject pBuild,
                   char *szFileName
  )@@{
@end example
The function returns zero on success (@code{BU_ERROR_SUCCESS}) and @code{BU_ERROR_FAIL}
if the code could not be saved.
@subsubsection  build_SaveECode()

This function saves the binary code of the program into the file
given by the name @code{szFileName} in exe format.

This is actually nothing but the copy of the original interpreter file and
the binary code of the BASIC program appended to it and some extra information
at the end of the file to help the reader to find the start of the binary 
BASIC program when it tries to read the exe file.

@example
void build_SaveECode(pBuildObject pBuild,
                     char *pszInterpreter,
                     char *szFileName
  )@@{
@end example
@subsubsection  build_GetExeCodeOffset()

This function checks that the actually running exe contains the binary BASIC program
attached to its end. It returns zero if not, otherwise it returns 1.

@itemize
@item The argument @code{pszInterpreter} should be @code{argv[0]} thus the code can open the executable
file and check if it really contains the BASIC code
@item @code{plOffset} should point to a long variable ready to recieve the file offset where the BASIC
code starts
@item @code{plEOFfset} should point to a long variable ready to receive the file offset where the
BASIC code finishes. This is the position of the last byte belonging to the BASIC code, thus if
@code{ftell(fp) }>@code{ *plEOFfset} means the file pointer is after the code and should treat it as EOF
condition when reading the BASIC program code.
@@end itemize

It is guaranteed that both @code{*plOffset} and @code{*plEOFfset} will be set to @code{0} (zero) if the file
proves to be a standard BASIC interpreter without appended BASIC code.

@example
int build_GetExeCodeOffset(char *pszInterpreter,
                            long *plOffset,
                            long *plEOFfset
  )@@{
@end example
@subsubsection  build_LoadCore()

This function loads the binary code from an opened file.

Arguments:

@itemize
@item @code{pBuild} is the build object
@item @code{szFileName} is the name of the file that is opened. Needed for reporting purposes.
@item @code{fp} opened @code{FILE *} file pointer opened for binary reading (aka @code{"rb"}), and positioned where the
BASIC code starts.
@item @code{lEOFfset} should be the position of the last byte that belongs to the BASIC code so that @code{ftell(fp)}>@code{lEOFfset}
is treated as EOF condition. If this value is zero that means that the BASIC code is contained in the file until the
physical end of file.
@@end itemize

@example
void build_LoadCore(pBuildObject pBuild,
                    char *szFileName,
                    FILE *fp,
                    long lEOFfset
  )@@{
@end example
Note that the program does not return error code, but calls the reporting function to report error. The file @code{fp} is not closed in the
function even if error has happened during reading.
@subsubsection  build_LoadCodeWithOffset()

For detailed definition of the binary format see the code and the documentation of
@xref{build_SaveCode()@}

In case the file is corrupt the function reports error.

@example
void build_LoadCodeWithOffset(pBuildObject pBuild,
                              char *szFileName,
                              long lOffset,
                              long lEOFfset
  )@@{
@end example
@subsubsection  build_LoadCode()

For detailed definition of the binary format see the code and the documentation of
@xref{build_SaveCode()@}

In case the file is corrupt the function reports error.

@example
void build_LoadCode(pBuildObject pBuild,
                    char *szFileName
  )@@{
@end example
@subsubsection  build_IsFileBinaryFormat()

This function test a file reading its first few characters and decides
if the file is binary format of a basic program or not.

@example
int build_IsFileBinaryFormat(char *szFileName
  )@@{
@end example
@subsubsection  build_pprint()

This is a debug function that prints the build code into a file.

This function is not finished and the major part of it is commented out using @code{#if 0} construct.
@example
void build_pprint(pBuildObject pBuild,
                  FILE *f
  )@@{
@end example
@subsubsection  build_CreateFTable()

When the binary code of the BASIC program is saved to disk the symbol table of the user
defined functions and the symbol table of global variables is also saved. This may be needed
by some applications that embed ScriptBasic and want to call specific function or alter global variables
of a given name from the embedding C code. To do this they need the serial number of the global variable
or the entry point of the function. Therefore ScriptBasic v1.0b20 and later can save these two tables into
the binary code.

The format of the tables is simple optimized for space and for simplicity of generation. They are stored
first in a memory chunk and then written to disk just as a series of bytes.

The format is

@example
long      serial number of variable or entry point of the function
zchar     zero character terminated symbol
@end example

This is easy to save and to load. Searching for it is a bit slow. Embedding applications usually
have to search for the values only once, store the serial number/entry point value
in their local variable and use the value.

The function @code{CreateFTable} converts the symbol table of user defined function
collected by symbolic analysis into a single memory chunk.

The same way @xref{build_CreateVTable()@} converts the symbol table of global variables
collected by symbolic analysis into a single memory chunk.

@example
int build_CreateFTable(pBuildObject pBuild
  )@@{
@end example
@subsubsection  build_CreateVTable()

When the binary code of the BASIC program is saved to disk the symbol table of the user
defined functions and the symbol table of global variables is also saved. This may be needed
by some applications that embed ScriptBasic and want to call specific function or alter global variables
of a given name from the embedding C code. To do this they need the serial number of the global variable
or the entry point of the function. Therefore ScriptBasic v1.0b20 and later can save these two tables into
the binary code.

The format of the tables is simple optimized for space and for simplicity of generation. They are stored
first in a memory chunk and then written to disk just as a series of bytes.

The format is

@example
long      serial number of variable or entry point of the function
zchar     zero character terminated symbol
@end example

This is easy to save and to load. Searching for it is a bit slow. Embedding applications usually
have to search for the values only once, store it in their local variable and use the value.

The function @xref{build_CreateFTable()@} converts the symbol table of user defined function
collected by symbolic analysis into a single memory chunk.

The same way @code{CreateVTable} converts the symbol table of global variables
collected by symbolic analysis into a single memory chunk.

@example
int build_CreateVTable(pBuildObject pBuild
  )@@{
@end example
@subsubsection  build_LookupFunctionByName()
@example
long build_LookupFunctionByName(pBuildObject pBuild,
                          char *s
  )@@{
@end example
@subsubsection  build_LookupVariableByName()
@example
long build_LookupVariableByName(pBuildObject pBuild,
                          char *s
  )@@{
@end example
 



@section Executor

The executor kills the code. Oh, no! I was just kidding. It executes the code, which means something different. Starts with the first node and goes on.

The execution of the code starts calling the function @code{execute_Execute} implemented in the file @file{execute.c}

This function initializes the execution environment that was not initialized before calling the function @code{execute_InitStructure}

It allocates global variables, it fills command and instruction parameters and finalizer function pointers with @code{NULL} and starts the function @code{execute_Execute_r}

@subsection Command parameters

Each command type has a pointer that it can use for its own purpose. This is to avoid using global variables. The file commands for example use the pointer available for the command @code{OPEN}. To access this pointer the macro @code{PARAMPTR} is used defined in the file @file{command.c}

@subsection Instrunction parameters

Not only the commands have a pointer for their use, but there are pointers available for each instruction. To make it clear:

If there are three @code{OPEN} statements in a program they share a @emph{common command pointer}, but @emph{each have its own instruction pointer}.

The code fragments implementing the different commands are free to use their own or any other related command or instruction pointer.

@subsection Finalizer function

Finalizer function pointers are available for each command type. This way they are similar to command parameters. There can be many OPEN statements in a program they share a common finalizer pointer. Each finalizer pointer is initialized to @code{NULL}.

The code fragments may put a function entry address in the finalizer pointer. When the execution of a program is finished the executing function calls each function that has a non NULL pointer in the finalizer array.

The @code{_r} in the function name tells that this is a recursive function that may call itself when an expression evaluation performs a function or subroutine call.


@subsection Functions implemented in this module

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.







This module contain the functions that execute the code resuled by the builder.

@subsubsection  execute_GetCommandByName()

The op-code of a command can easily be identified, because @code{syntax.h} contains
symbolic constant for it. This function can be used by external modules to
get this opcode based on the name of the function. The argument @code{pszCommandName}
should be the name of the command, for example @code{"ONERRORRESUMENEXT"}. The third 
argument is the hint for the function to help to find the value. It should always
be the opcode of the command. The return value is the actual opcode of the command.
For example:

@example
i = execute_GetCommandByName(pEo,"ONERRORRESUMENEXT",CMD_ONERRORRESUMENEXT);
@end example

will return @code{CMD_ONERRORRESUMENEXT}.

@emph{Why is this function all about then?}

The reason is that the external module may not be sure that the code
@code{CMD_ONERRORRESUMENEXT} is the same when the external module is compiled
and when it is loaded. External modules negotiate the interface version
information with the calling interpreter, but the opcodes may silently changed
from interpreter version to the next interpreter version and still supporting
the same extension interface version.

When an external module needs to know the opcode of a command of the calling
interpreter it first calls this function telling:

I<I need the code of the command ONERRORRESUMENEXT. I think that the code is
CMD_ONERRORRESUMENEXT, but is it the real code?>

The argument @code{lCodeHint} is required only, because it speeds up search.

If there is no function found for the given name the returnvalue is zero.

@example
long execute_GetCommandByName(pExecuteObject pEo,
                              char *pszCommandName,
                              long lCodeHint
  )@@{
@end example
@subsubsection  execute_CopyCommandTable()

The command table is a huge table containing pointers to functions. For example
the @code{CMD_LET}-th element of the table points to the function @code{COMMAND_LET}
implementing the assignment command.

This table is usually treated as constant and is not moduified during run time.
In case a module wants to reimplement a command it should alter this table.
However the table is shared all concurrently running interpreter threads in
a multi-thread variation of ScriptBasic.

To avoid altering the command table of an independent interpreter threadthe module
wanting altering the command table should call this function. This function allocates
memory for a new copy of the command table and copies the original constant
value to this new place. After the copy is done the @code{ExecuteObject} will point to
the copied command table and the extension is free to alter the table.

In case the function is called more than once for the same interpreter thread
only the first time is effective. Later the function returns without creating superfluous
copies of the command table.
@example
int execute_CopyCommandTable(pExecuteObject pEo
  )@@{
@end example
@subsubsection  execute_InitStructure()

@example
int execute_InitStructure(pExecuteObject pEo,
                          pBuildObject pBo
  )@@{
@end example
@subsubsection  execute_ReInitStructure()

This function should be used if a code is executed repeatedly. The first
initialization call is @xref{execute_InitStructure()@} and consecutive executions
should call this function.

@example
int execute_ReInitStructure(pExecuteObject pEo,
                            pBuildObject pBo
  )@@{
@end example
@subsubsection  execute_Execute_r()

This function executes a program fragment. The execution starts from the class variable
@code{ProgramCounter}. This function is called from the @xref{execute_Execute()@} function which is the
main entry point to the basic main program. This function is also called recursively from
the function @xref{execute_Evaluate()@} when a user defined function is to be executed.

@example
void execute_Execute_r(pExecuteObject pEo,
                       int *piErrorCode
  )@@{
@end example
@subsubsection  execute_InitExecute()

@example
void execute_InitExecute(pExecuteObject pEo,
                        int *piErrorCode
  )@@{
@end example
@subsubsection  execute_FinishExecute()

@example
void execute_FinishExecute(pExecuteObject pEo,
                           int *piErrorCode
  )@@{
@end example
@subsubsection  execute_Execute()

This function was called from the basic @code{main} function. This function performs inititalization
that is needed before each execution of the code and calls @xref{execute_Execute_r()@} to perform the execution.

Note that @xref{execute_Execute_r()@} is recursively calls itself.

This function is obsolete and is not used anymore. This is kept in the source
for the shake of old third party variations that may depend on this function.

Use of this function in new applications is discouraged.

@example
void execute_Execute(pExecuteObject pEo,
                     int *piErrorCode
  )@@{
@end example
@subsubsection  execute_ExecuteFunction()

This function is used by the embedding layer (aka @code{scriba_} functions) to execute a function.
This function is not directly called by the execution of a ScriptBasic program. It may be
used after the execution of the program by a special embeddign application that keeps the
code and the global variables in memory and calls functions of the program.

The function takes @code{pEo} as the execution environment. @code{StartNode} should be the node where the
sub or function is defined. @code{cArgs} should give the number of arguments. @code{pArgs} should point
to the argument array. @code{pResult} will point to the result. If @code{pResult} is @code{NULL} the result is
dropped. Otherwise the result is a mortal variable.

Note that this code does not check the number of arguments you provide. There can be more arguments
passed to the SUB than it has declared, therefore you can initialize the local variables of the sub.
(You should know that arguments are local variables in ScriptBasic just as any other non-argument local
variable.)

The arguments should be normal immortal variables. They are passed to the SUB by reference and in case
they are modified the old variable is going to be released.

@code{piErrorCode} returns the error code of the execution which is zero in case of no error.
@example
void execute_ExecuteFunction(pExecuteObject pEo,
                             unsigned long StartNode,
                             long cArgs,
                             pFixSizeMemoryObject *pArgs,
                             pFixSizeMemoryObject *pResult,
                             int *piErrorCode
  )@@{
@end example
@subsubsection  execute_Evaluate()

This function evaluates an expression. You should not get confused! This is not syntax analysis, caring
operator precedences and grouping by nested parentheses. That has already been done during syntax analysis.
This code performs the code that was generated from an expression.

The result is usually a mortal memory value which is the final result of the expression. However this piece of
code assumes that the caller is careful enough to handle the result as read only, and sometimes the return
value is not mortal. In this case the return value is a memory object that a variable points to. Whenever the
caller needs this value to perform an operation that does not alter the value it is OK. Duplicating the structure
to create a mortal would be waste of time and memory. On the other hand sometimes operations modify their operands
assuming that they are mortal values. They should be careful.

Operators are actually created in the directory @code{commands} and they use the macros defined in @code{command.h} (created
by @code{headerer.pl} from @code{command.c}). They help to avoid pitfalls.

The argument @code{iArrayAccepted} tells the function whether an array as a result is accepted or not. If a whole
array is accepted as a result of the expression evaluation the array is returned. If the array is not an
acceptable result, then the first element of the array is retuned in case the result is an array. If the result
is NOT an array this parameter has no effect.

@example
pFixSizeMemoryObject execute_Evaluate(pExecuteObject pEo,
                                      unsigned long lExpressionRootNode,
                                      pMortalList pMyMortal,
                                      int *piErrorCode,
                                      int iArrayAccepted
  )@@{
@end example
@subsubsection  execute_LeftValue()

This function evaluate a left value. A left value is a special expression that value can be assigned, and therefore
they usually stand on the left side of the assignment operator. That is the reason for the name.

When an expression is evaluates a pointer to a memory object is returned. Whenever a left value is evaluated a pointer
to the variable is returned. If any code assignes value to the variable pointed by the return value of this function
it should release the memory object that the left value points currently.
@example
pFixSizeMemoryObject *execute_LeftValue(pExecuteObject pEo,
                                        unsigned long lExpressionRootNode,
                                        pMortalList pMyMortal,
                                        int *piErrorCode,
                                        int iArrayAccepted
  )@@{
@end example
@subsubsection  execute_EvaluateArray()

This function should be used to evaluate an array access to get the actual
value. This is called by @xref{execute_Evaluate()@}.

An array is stored in the expression as an operator with many operands. The first
operand is a local or global variable, the rest of the operators are the indices.

Accessing a variable holding scalar value with array indices automatically converts
the variable to array. Accessing an array variable without indices gets the "first"
element of the array.
@example
pFixSizeMemoryObject execute_EvaluateArray(pExecuteObject pEo,
                                      unsigned long lExpressionRootNode,
                                      pMortalList pMyMortal,
                                      int *piErrorCode
  )@@{
@end example
@subsubsection  execute_EvaluateSarray()

This function should be used to evaluate an array access to get the actual
value. This is called by @xref{execute_Evaluate()@}.

An array is stored in the expression as an operator with many operands. The first
operand is a local or global variable, the rest of the operators are the indices.

Associative arrays are normal arrays, only the access mode is different. When accessing
an array using the fom @code{a@@{key@}} then the access searches for the value @code{key} in the 
evenly indexed elements of the array and gives the next index element of the array. This
if

@example
a[0] = "kakukk"
a[1] = "birka"
a[2] = "kurta"
a[3] = "mamus"
@end example

then @code{a@@{"kakukk"@}} is "birka". @code{a@@{"birka"@}} is @code{undef}. @code{a@@{"kurta"@}} is "mamus".

@example
pFixSizeMemoryObject execute_EvaluateSarray(pExecuteObject pEo,
                                      unsigned long lExpressionRootNode,
                                      pMortalList pMyMortal,
                                      int *piErrorCode
  )@@{
@end example
@subsubsection  execute_LeftValueArray()

This function evaluates an array access left value. This function is also called by @xref{execute_EvaluateArray()@}
and the result pointer is dereferenced.

@example
pFixSizeMemoryObject *execute_LeftValueArray(pExecuteObject pEo,
                                             unsigned long lExpressionRootNode,
                                             pMortalList pMyMortal,
                                             int *piErrorCode
  )@@{
@end example
@subsubsection  execute_LeftValueSarray()

This function evaluates an associative array access left value.
This function is also called by @xref{execute_EvaluateSarray()@} and the result
pointer is dereferenced.

@example
pFixSizeMemoryObject *execute_LeftValueSarray(pExecuteObject pEo,
                                              unsigned long lExpressionRootNode,
                                              pMortalList pMyMortal,
                                              int *piErrorCode
  )@@{
@end example
@subsubsection  execute_Convert2String()

This functionconverts a variable to string. When the variable is already a string then it returns the pointer to the
variable. When the variable is long or double @code{sprintf} is used to convert the number to string.

When the conversion from number to string is done the result is always a newly allocated mortal. In other words
this conversion routine is safe, not modifying the argument memory object.
@example
pFixSizeMemoryObject execute_Convert2String(pExecuteObject pEo,
                                          pFixSizeMemoryObject pVar,
                                          pMortalList pMyMortal
  )@@{
@end example
@subsubsection  execute_Convert2Long()

This function should be used to convert a variable to long. The conversion is
usually done in place. However strings can not be converted into long in place, because
they have different size. In such a case a new variable is created. If the mortal list @code{pMyMortal}
is @code{NULL} then the new variable in not mortal. In such a case care should be taken
to release the original variable.

Usually there is a mortal list and a new mortal variable is generated. In such a case
the original value is also a mortal and is automatically released after the command
executing the conversion is finished.

Note that strings are converted to long in two steps. The first step converts the string to
@code{double} and then this value is converted to long in-place.


@example
pFixSizeMemoryObject execute_Convert2Long(pExecuteObject pEo,
                                          pFixSizeMemoryObject pVar,
                                          pMortalList pMyMortal
  )@@{
@end example
@subsubsection  execute_Convert2LongS()

This is the safe version of the conversion function @xref{execute_Convert2Long()@}.

This function ALWAYS create a new variable and does NOT convert a
double to long in place. This function is called by the extensions,
because extensions tend to be more laisy regarding conversion and
many converts arguments in place and thus introduce side effect.

To solve this problem we have introduced this function and have
set the support table to point to this function.
@example
pFixSizeMemoryObject execute_Convert2LongS(pExecuteObject pEo,
                                           pFixSizeMemoryObject pVar,
                                           pMortalList pMyMortal
  )@@{
@end example
@subsubsection  execute_Convert2Double()

This function should be used to convert a variable to double. The conversion is
usually done in place. However strings can not be converted into double in place, because
they have different size. In such a case a new variable is created. If the mortal list
is @code{NULL} then the new variable in not mortal. In such a case care should be taken
to release the original variable.

Usually there is a mortal list and a new mortal variable is generated. In such a case
the original value is also a mortal and is automatically released after the command
executing the conversion is finished.

@example
pFixSizeMemoryObject execute_Convert2Double(pExecuteObject pEo,
                                            pFixSizeMemoryObject pVar,
                                            pMortalList pMyMortal
  )@@{
@end example
@subsubsection  execute_Convert2DoubleS()

This is the safe version of the conversion function @xref{execute_Convert2Double()@}.

This function ALWAYS create a new variable and does NOT convert a
long to double in place. This function is called by the extensions,
because extensions tend to be more laisy regarding conversion and
many converts arguments in place and thus introduce side effect.

To solve this problem we have introduced this function and have
set the support table to point to this function.

@example
pFixSizeMemoryObject execute_Convert2DoubleS(pExecuteObject pEo,
                                             pFixSizeMemoryObject pVar,
                                             pMortalList pMyMortal
  )@@{
@end example
@subsubsection  execute_Convert2Numeric()


This function should be used to convert a variable to numeric type.

The conversion results a double or long variable. If the source variable
was already a long or double the function does nothing but results the
source variable.

@code{undef} is converted to long zero.

The function calls @xref{execute_Convert2Long@} and @xref{execute_Convert2Double@} thus
all other parameters are treated according to that.

@example
pFixSizeMemoryObject execute_Convert2Numeric(pExecuteObject pEo,
                                             pFixSizeMemoryObject pVar,
                                             pMortalList pMyMortal
  )@@{
@end example
@subsubsection  execute_Dereference()

This function recursively follows variable references and returns
the original variable that was referenced by the original variable.

A reference variable is a special variable that does not hold value
itself but rather a pointer to another variable. Such reference variables
are used when arguments are passed by reference to BASIC subroutines.

Calling this function the caller can get the original variable and the
value of the original variable rather than a reference.
@example
pFixSizeMemoryObject execute_Dereference(pExecuteObject pEo,
                                         pFixSizeMemoryObject p,
                                         int *piErrorCode
  )@@{
@end example
See also @xref{execute_DereferenceS()@}.
@subsubsection  execute_DereferenceS()

This function does the same as @xref{execute_Dereference()@} except that it has
different arguments fitted to support external modules and @code{besXXX}
macros.

@example
int execute_DereferenceS(unsigned long refcount,
                         pFixSizeMemoryObject *p
  )@@{
@end example
See also @xref{execute_Dereference()@}.

If the argument is referencing an @code{undef} value then this function
converts the argument to be a real @code{NULL} to allow external modules
to compare @code{besDEREFERENCE}d variables against @code{NULL}.

The subroutine is also error prone handling @code{NULL} pointer as argument,
though it should never be happen if the external module programmer
uses the macro @code{besDEREFERENCE}.
@subsubsection  execute_GetDoubleValue()

Use this function whenever you want to access the @b{value} of a variable as a @code{double}.
Formerly ScriptBasic in such situation converted the variable to double calling
@xref{execute_Convert2Double()@} and then used the macro @code{DOUBLEVALUE}. This method is faster
because this does not create a new mortal variable but returns directly the
double value.

The macro @code{GETDOUBLEVALUE} can be used to call this function with the default
execution environment variable @code{pEo}

Note however that the macro @code{GETDOUBLEVALUE} and @code{DOUBLEVALUE} are not 
interchangeable. @code{GETDOUBLEVALUE} is returnig a @code{double} while 
@code{DOUBLEVALUE} is a left value available to store a @code{double}.

@example
double execute_GetDoubleValue(pExecuteObject pEo,
                              pFixSizeMemoryObject pVar
  )@@{
@end example
@subsubsection  execute_GetLongValue()

Use this function whenever you want to access the @b{value} of a variable as a @code{long}.
Formerly ScriptBasic in such situation converted the variable to long calling
@xref{execute_Convert2Long()@} and then used the macro @code{LONGVALUE}. This method is faster
because this does not create a new mortal variable but returns directly the
long value.

The macro @code{GETLONGVALUE} can be used to call this function with the default
execution environment variable @code{pEo}

Note however that the macro @code{GETLONGVALUE} and @code{LONGVALUE} are not 
interchangeable. @code{GETLONGVALUE} is returnig a @code{long} while 
@code{LONGVALUE} is a left value available to store a @code{long}.

@example
long execute_GetLongValue(pExecuteObject pEo,
                          pFixSizeMemoryObject pVar
  )@@{
@end example

Please also note that the result of converting a string variable to LONG and then
accessing its longvalue may not result the same number as calling this function.
The reason is that conversion of a string to a LONG variable is done in two steps.
First it converts the string to a @code{double} and then it rounds the @code{double} value
to @code{long}. On the other hand this function converts a string diretly to @code{long}.

For example the string @code{"3.7"} becomes 4 when converted to long and 3 when getting the
value as a long.

@subsubsection  execute_IsStringInteger()

This function should be used to check a string before converting it to numeric value.
If the string contains only digits it should be converted to @code{long}. If the string contains
other characters then it should be converted to double. This function decides what characters
the string contains.

@example
int execute_IsStringInteger(pFixSizeMemoryObject pVar
  )@@{
@end example
@subsubsection  execute_IsInteger()

This function checks that a variable being long, double or string can be
converted to long without loosing information.

@example
int execute_IsInteger(pFixSizeMemoryObject pVar
  )@@{
@end example
 


@section Configuration File Handling

ScriptBasic contains a fairly sophisticated configuration handling module. The configuration information is read each time the interpreter starts, therefore it is vital that the information can be processed fast even if the configuration data is complex. This can be the case because the configuration information may also contain data for external modules that the interpreter loads when it starts and the external modules can access it any time they run.

The configuration information for ScriptBasic has to be maintained in textual format in a file that has more or less LISP syntax.

The format of the text file version of the configuration information is simple. It contains the keys and the corresponding values separated by one or more spaces and new lines. Usually a key and the assigned value is written on a line. Lines starting with the character ; is comment.

The values can be integer numbers, real numbers, strings and sub-configurations. Strings can either be single line or multi-line strings starting and ending with three """ characters, just like in the language ScriptBasic or in the language Python.

Sub-configurations start with the character ( and are closed with the character ). The list between the parentheses are keys and corresponding values.

This text file has to be converted to binary format. The ScriptBasic interpreter loads this binary format into memory without processing its content, thus loading speed of the configuration information is limited only by IO.

When the interpreter or an external module needs some configuration information there are functions in this module that can search and read information from the configuration file.


@subsection Functions implemented in this module

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.





@subsubsection  cft_init()

Before calling any other configuration handling function the caller has to prepare a @code{tConfigTree}
structure. To do this it has to call this function.

The first argument has to point to an allocated and uninitialized @code{tConfigTree} structure. The second
argument has to point to a memory allocating function. The third argument has to point to the memory releasing
function that is capable releasing the memory allocated by the memory allocating function.

The argument @code{pMemorySegment} should be the segment pointer to the memory handling functions. All memory allocation
will be performed calling the @code{memory_allocating_function} and passing the @code{pMemorySegment} pointer as second argument
to it. All memory releasing will be done via the function @code{memory_releasing_function} passing 
@code{pMemorySegment} pointer as second argument. This lets the caller to use sophisticated memory handling architecture.

@b{On the other hand for the simple use} all these three arguments can be @code{NULL}. In this case the configuration
management system will use its own memory allocating and releasing function that simply uses @code{malloc} and @code{free}.
In this case @code{pMemorySegment} is ignored.

For a ready made module that delivers more features see the alloc module of the ScriptBasic project at
@code{http://scriptbasic.com}

@example
int cft_init(ptConfigTree pCT,
              void *(*memory_allocating_function)(size_t, void *),
              void (*memory_releasing_function)(void *, void *),
              void *pMemorySegment
  )@@{
@end example
Note that suggested convention is to use the '@code{.}' character as separator for hierarchical key structures, but
this is only a suggestion. In other words the module writers advice is to use @code{key.subkey.subsubkey} as key string
for hierarchical strings. On the other hand you can use any character as separator except the zero character and
except the characters that are used as key characters. You can write

@example
key\subkey\subsubkey
@end example

if you are a windows geek. To do this you have to change the character saying

@example
    pCT->TC = '\\';
@end example

after calling the initialization function. You can change this character any time, this character is not
used in the configuration structure. The only point is that you have to use the actual character when you have
changed it. The best practice is to use the dot  ever.
@subsubsection  cft_GetConfigFileName()

This function tries to locate the configuration file. The working of this function
is system dependant. There are two different implementations: one for UNIX and one for Win32.

@b{WIN32}

On Win32 systems the function tries to read the system registry. The value of the key given in the argument
@code{env} is used and returned as the config file name. For example if the argument @code{env} is
@code{Software\myprog\conf} then the registry value of the key @code{HKEY_LOCAL_MACHINE\Software\myprog\conf} will
be returned as configuration file name. The program does not check that the file really exists. It only
checks that the registry key exists, it is a string and has some value.

If the registry key does not exists the program tries to locate the system directory getting the environment
variable @code{windir}, then @code{systemroot} and finally taking @code{c:\WINDOWS}. The argument @code{DefaultFileName} is
appended to the directory name and is returned.

@b{UNIX}

On UNIX it is more simple. The environment variable @code{env} is used as a file name.
If this does not exists the @code{DefaultFileName} is used and returned.

@b{BOTH}

The return value of the function is zero if no error has happened. A pointer to the resulting file name
is returned in the variable @code{ppszConfigFile}. The space to hold the resulting file name is allocated
via the allocation function given by the @code{tConfigTree} structure pointed by @code{pCT}.

@example
int cft_GetConfigFileName(ptConfigTree pCT,
                          char **ppszConfigFile,
                          char *env,/* environment variable or registry key on win32 */
                          char *DefaultFileName
  )@@{
@end example
This function is @code{static} and can not be called from outside of this module.
@subsubsection  cft_start()

When writing real applications you usually want to call this function. This function initializes the
@code{tConfigTree} structure pointed by @code{pCT}, searches for the configuration file and reads it.

When trying to allocate the configuration file the static internal function @xref{GetConfigFileName@} is used.

The argument @code{Envir} is the registry key under @code{HKLM}, eg @code{Software\Myprog\conf} under Win32 or
the environment variable to look for the configuration file name. The argument @code{pszDefaultFileName}
is the file name searched on WIN32 in the system directories or the full path to the default configuration
file nam eunder UNIX. The argument @code{pszForcedFileName} can overrride the file name search or
has to be @code{NULL} to let the reader search the environment and registry for file name.
@example
int cft_start(ptConfigTree pCT,
              void *(*memory_allocating_function)(size_t, void *),
              void (*memory_releasing_function)(void *, void *),
              void *pMemorySegment,
              char *Envir,
              char *pszDefaultFileName,
              char *pszForcedFileName
  )@@{
@end example
@subsubsection  strmyeq()

This is an internal @code{static} function that compares two strings and returns true iff they
are equal. The string terminator is the usual zero character or the dot. Both are legal terminators
for this functions and their difference in the compared strings is not treated as difference in the result.
If one string is terminated by zero character and the other is terminated by a dot but they are the same in any
other character then the return value is true.

This function is used find a sub-key when the caller has specified a dot separated hierarchical key.

Note that the dot is only a convention and the default value for the separator and the caller has 
@example
/**/
static int strmyeq(ptConfigTree pCT,char *a, char *b)@@{
@end example
This function is @code{static} and can not be called from outside of this module.
@subsubsection  cft_FindNode()

Find a node starting from the start node @code{lStartNode}
and searching for the @code{key}.

The function returns zero if the key is not found in the configuration
information tree @code{pCT} or returns the node id of the key. This node
can either be an internal node or leaf.

Note that the string @code{key} may contain dot characters. In this case the
key is searched down in the configuration tree. (You can set the separator character
different from the dot character.)

@example
CFT_NODE cft_FindNode(ptConfigTree pCT,
                      CFT_NODE lStartNode,
                      char *key
  )@@{
@end example
You need this function when you want to iterate over the sub-keys of a node. You get the
node id for the key and then you can call @xref{cft_EnumFirst@} to start the loop and then @xref{cft_EnumNext@} to
iterate the loop over the sub-keys.

If you just want to get the value of a single key you can call the function @xref{cft_GetEx@} that
uses this function.
@subsubsection  cft_GetEx()

Get the value associated with the key @code{key} from the configuration
structure @code{pCT}, or get the values of a node.

The arguments:

@itemize
@item @code{pCT} the configuration information searched.
@item @code{key} the key that we search the value for, or NULL if we already
      know the node id where the needed information is.
@item @code{plNodeId} the id of the node that we need information from. If the
      key argumentum is not NULL then this argument is overwritten with the
      node id associated with the key. If the argument key is NULL this
      argument should specify the id of the node we need information from.
      If the node id is not needed upon return this argument may point to NULL.
@item @code{ppszValue} will return a pointer to a constant ZCHAR string if
      the value associated with @code{key} is string. If the argument is @code{NULL}
      then the function ignore this argument.
@item @code{plValue} will return a @code{long} if the value associated with
      @code{key} is integer. If the argument is @code{NULL}
      then the function ignore this argument.
@item @code{pdValue} will return a @code{double} if the value associated with
      @code{key} is a real number. If the argument is @code{NULL}
      then the function ignore this argument.
@item @code{type} will return the type of the key. This can be
  @itemize
  @item @code{CFT_NODE_BRANCH} if the key is associated with a subtree.
  @item @code{CFT_TYPE_STRING} if the key is associated with a string
  @item @code{CFT_TYPE_INTEGER} if the key is associated with an integer number
  @item @code{CFT_TYPE_REAL} if the key is associated with a real number
  @@end itemize
  This argument can also be NULL if the caller is not interested in the
  type of the value.
@@end itemize

Note that any of @code{ppszValue}, @code{plValue}, @code{pdValue} can point to a
variable or to @code{NULL} in case the caller does not need the actual value.

@example
int cft_GetEx(ptConfigTree pCT,
              char *key,
              CFT_NODE *plNodeId,
              char **ppszValue,
              long *plValue,
              double *pdValue,
              int *type
  )@@{
@end example

The function returns @code{CFT_ERROR_SUCCESS} if no error happens.
The value @code{CFT_ERROR_SUCCESS} is zero.

If an error happens the error code is returned. These error codes are:
@itemize
@item @code{CFT_ERROR_NOT_FOUND} the key is not present in the table, and
      @code{*plNodeId} will also be set to zero.
@item @code{CFT_ERROR_NOTYPE} the key is found but has a type that can not
      be returned, because the caller passed NULL as storage location.
      In this case the type of the configuration information is probably
      wrong.
@@end itemize

@subsubsection  cft_GetString()

This is the simplest interface function to retrieve a configuration
string. This assumes that you exactly know the name of the key and
you are sure that the value is a string. The function returns the pointer
to the constant string or returns NULL if the configuration key is not
present in the tree or the value is not a string.

The use of this function is not recommended. This function is present
in this package to ease porting of programs that use simpler configuration
information management software.
@example
char *cft_GetString(ptConfigTree pCT,
                    char *key
  )@@{
@end example
This function calls @xref{cft_GetEx@}.

@subsubsection  cft_EnumFirst()

Whenever you need to enumerate the sub-keys of a key you have to
get the node associated with the key (see @xref{cft_GetEx@} or @xref{cft_FindNode@}).
When you have the node associated with the key you can get the node of the
first sub-key calling this function.

The function needs the node id @code{lNodeId} of the key for which
we need to enumerate the sub keys and returns the node id of the
first sub key.

If the key is associated with a leaf node the function returns zero.

If the key is associated with a branch node that has no sub-keys the
function returns zero.
@example
CFT_NODE cft_EnumFirst(ptConfigTree pCT,
                       CFT_NODE lNodeId
  )@@{
@end example
@subsubsection  cft_EnumNext()

Whenever you need to enumerate the sub-keys of a key you have to
get the node associated with the key (see @xref{cft_GetEx@} or @xref{cft_FindNode@}).
When you have the node associated with the key you can get the node of the
first sub-key calling the function @xref{cft_EnumFirst@}. Later on you can enumerate
the sub keys stepping from node to node calling this function.

The function needs the node id @code{lNodeId} returned by @xref{cft_EnumFirst@} or
by previous call of this function.

The function returns the node id of the next sub key.

If the enumeration has ended, in other words there is no next sub-key the
function returns zero.
@example
long cft_EnumNext(ptConfigTree pCT,
                  long lNodeId
  )@@{
@end example
@subsubsection  cft_GetKey()

This function returns a pointer to the constant zchar string that
holds the key of the node defined by the id @code{lNodeId}.
@example
char *cft_GetKey(ptConfigTree pCT,
                 CFT_NODE lNodeId
  )@@{
@end example
@subsubsection  cft_ReadConfig()

@example
int cft_ReadConfig(ptConfigTree pCT,
                   char *pszFileName
  )@@{
@end example
@subsubsection  cft_WriteConfig()

@example
int cft_WriteConfig(ptConfigTree pCT,
                    char *pszFileName
  )@@{
@end example
@subsubsection  cft_DropConfig()

@example
void cft_DropConfig(ptConfigTree pCT
  )@@{
@end example
 


@section Memory Allocation
This module is a general purpose memory allocation module, which can be used in any project
that needs heavy and sophisticated memory allocation. Originally the module was developed for
the ScriptBasic project. Later we used it for Index.hu Rt AdEgine project and multi-thread
features were introduced.

The major problem with memory allocation is that memory should be released. Old programs depend
on the operating system to release the memory when the process exists and do not release the memory
before program termination. Such programs are extremely difficult to port to multi-thread operation.
In multi thread operation a thread my exit, but the memory still belongs to the process that goes on.

This module provides a bit of abstraction that helps the programmer to release the memory. The abstraction is
the following:

A piece of memory is always allocated from a segment. A segment is logical entity and you should not think of
a segment in this content as a continuous memory area. I could also say that: whenever a piece of 
memory is allocated it is assigned to a segment. When a piece of memory is released it is removed from the segment.
A segment is an administrative entity that keep track of the memory pieces that were allocated and assigned to the
segment.

To explain segment to the fines details: segments are implemented as linked lists. Each element of the list contains
the allocated memory piece as well as a pointer to the next and previous list members.

Whenever the programmer starts a sophisticated task that allocates several memory pieces it has to create a new segment
and allocate the memory from that segment. When the memory is to be release the programmer can just say: release all the
memory from the segment. This way he or she does not need keep track of the allocated memory structures, and walk through
the memory pointers of his or her program which are designed to the program function instead of releasing the memory.

The overhead is the space allocated by two pointers for each memory piece and the size of the three pointers for
each segment.



@subsection Functions implemented in this module

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.





@subsubsection  Multi-thread use of this module

You can use this module in multi threaded environment. In this case the module depend on the module @code{thread.c}
which contains the thread and mutex interface functions that call the operating system thread and mutex functions
on UNIX and on Windows NT.

In single thread environment there is no need to use the locking mechanism. To get a single-thread version either you can
edit this file (@code{myalloc.c}) or compile is using the option @code{-DMTHREAD=0} The default compilation is multi threaded.

Multi thread implementation has two levels. One is that the subroutines implemented in this module call
the appropriate locking functions to ensure that no two concurrent threads access and modify the same data at a time
and thus assure that the data of the module is correct. The other level is that you can tell the module that the
underlying memory allocation and deallocation modules are mot thread safe. There are global variables
implementing global mutexes that are locked and unlocked if you use the module that way. This can be useful in some
environment where @code{malloc} and @code{free} are not thread safe.

Note that this should not be the case if you call @code{malloc} and @code{free} or you linked the wrong versio of libc.
However you may use a non-thread safe debug layer for example the one that ScriptBasic uses.

@subsubsection  alloc_InitSegment()

Call this function to get a new segment. You should specify the functions that the segement should use to
get memory from the operating system, and the function the segment should use to release the memory to the
operating system. These functions should be like @code{malloc} and @code{free}.

If the second argument is @code{NULL} then the function will treat the first argument as an already
allocated and initialized memory segment and the memory allocation and freeing functions will be
inherited from that segment.

@example
void *alloc_InitSegment(void * (*maf)(size_t), /* a 'malloc' and a 'free' like functions */
                        void   (*mrf)(void *)
  )@@{
@end example

The return value is a @code{void*} pointer which identifies the segment and should be passed to the other functions
as segment argument.

The first argument is the @code{malloc} like function and the second if the @code{free} like function.
@subsubsection  alloc_GlobalUseGlobalMutex()

Some installation use memory allocation function that are not thread safe. On some
UNIX installations @code{malloc} is not thread safe. To tell the module that all the allocation
function primitives are not thread safe call this function before initializing any segment.

@example
void alloc_GlobalUseGlobalMutex(
  )@@{
@end example
@subsubsection  alloc_SegmentLimit()

You can call this function to set a segment limit. Each segment keeps track of the actual memory
allocated to the segment. When a new piece of memory allocated in a segment the calculated segment
size is increased by the size of the memory chunk. When a piece of memory is release the calculated
size of the segment is decreased.

Whenever a segment approaches its limit the next allocation function requesting memory
that would exceed the limit returns @code{NULL} and does not allocate memory.

The value of the limit is the number of bytes allowed for the segment. This is the requested number of
bytes without the segment management overhead.

Setting the limit to zero means no limit except the limits of the underlying memory allocation layers,
usually @code{malloc}.

You can dynamically set the limit during handling the memory at any time except that you should not
set the limit to zero unless the segment is empty and you should not set the limit to a positive value
when the actual limit is zero (no limit) and the segment is not empty. This restriction is artificial
in this release but is needed to be followed to be compatible with planned future developments.

This function sets the limit for the segment pointed by @code{p} and returns the old value of the segment.
@example
long alloc_SegmentLimit(void *p,
                        unsigned long NewMaxSize
  )@@{
@end example
@subsubsection  alloc_FreeSegment()

Use this function to release all the memory that was allocated to the segment @code{p}.
Note that after calling this function the segment is still usable, only the memory
that it handled was released. If you do not need the segment anymore call the function
@xref{alloc_FinishSegment()@} that calls this function and then releases the memory allocated to store
the segment information.

Sloppy programmers may pass @code{NULL} as argument, it just returns.
@example
void alloc_FreeSegment(void *p
  )@@{
@end example
@subsubsection  alloc_FinishSegment()

Use this function to release all the memory that was allocated to the segment @code{p}.
This function also releases the memory of the segment head and therefore the
segment pointed by @code{p} is not usable anymore.

@example
void alloc_FinishSegment(void *p
  )@@{
@end example
@subsubsection  alloc_Alloc()

Use this function to allocate a memory piece from a segment.

@example
void *alloc_Alloc(size_t n,
                  void *p
  )@@{
@end example

The first argument is the size to be allocated. The second argument is the
segment which should be used for the allocation.

If the memory allocation fails the function returns @code{NULL}.
@subsubsection  alloc_Free()

You should call this function whenever you want to release a single piece of memory
allocated from a segment. Note that you also have to pass the segment pointer as the
second argument, because the segment head pointed by this @code{void} pointer contains the
memory releasing function pointer.

Sloppy programmers may try to release @code{NULL} pointer without harm.
@example
void alloc_Free(void *pMem, void *p
  )@@{
@end example
@subsubsection  alloc_Merge()

Call this function in case you want to merge a segment into another. This can be the
case when your program builds up a memory structure in several steps.

This function merges the segment @code{p2} into @code{p1}. This means that the segment @code{p1} will
contain all the memory pieces that belonged to @code{p2} before and @code{p2} will not contain any
allocated memory. However the segment @code{p2} is still valid and can be used to allocated memory
from. If you also want to finish the segment @code{p2} call the function @xref{alloc_MergeAndFinish()@}.

@example
void alloc_Merge(void *p1, void *p2
  )@@{
@end example

Note that the two segments SHOULD use the same, or at least compatible system memory handling functions!
You better use the same functions for both segments.

Example:

ScriptBasic builds up a sophisticated memory structure during syntactical analysis. This memory structure
contains the internal code generated from the program lines of the basic program. When ScriptBasic analyses
a line it tries several syntax descriptions. It checks each syntax defintion against the tokens of the line
until it finds one that fits. These checks need to build up memory structure. However if the check fails and
ScriptBasic should go for the next syntac definition line to check the memory allocated during the failed
checking should be released. Therefore these memory pieces are allocated from a segment that the program
calls @code{pMyMemorySegment}. If the syntax check fails this segment if freed. If the syntax check succedes this
segment is merged into another segement that contains the memory structures allocated from the previous basic program
lines.
@subsubsection  alloc_MergeAndFinish()
Use this function in case you not only want to merge a segment into another but you also
want to finish the segment that was merged into the other.


See also @xref{alloc_Merge()@}
@example
void alloc_MergeAndFinish(void *p1, void *p2
  )@@{
@end example
@subsubsection  alloc_InitStat()

This function initializes the global statistical variables. These variables
can be used in a program to measure the memory usage.

This function should be called before any other memory handling function.

@example
void alloc_InitStat(
  )@@{
@end example
@subsubsection  alloc_GlobalGetStat()

From period to period the code using this memory management layer may need to know
how much memory the program is using.

Calling this function from time to time you can get the minimum and maximum memory
that the program used via this layer since the last call to this function or since
program start in case of the first call.

@example
void alloc_GlobalGetStat(unsigned long *pNetMax,
                         unsigned long *pNetMin,
                         unsigned long *pBruMax,
                         unsigned long *pBruMin,
                         unsigned long *pNetSize,
                         unsigned long *pBruSize
  )@@{
@end example
@subsubsection  alloc_GetStat()

From period to period the code using this memory management layer may need to know
how much memory the program is using.

Calling this function from time to time you can get the minimum and maximum memory
that the program used via this layer since the last call to this function or since
program start in case of the first call.

@example
void alloc_GetStat(void *p,
                   unsigned long *pMax,
                   unsigned long *pMin,
                   unsigned long *pActSize
  )@@{
@end example
 



@section Variable Allocation

This module implemented in the source file @file{memory.c} provides functions to allocate and deallocate memory for BASIC variables. This module itself allocates memory calling the underlying allocation module implemented in the file @file{myalloc.c}. The role of this module is to help ScriptBasic to reuse the allocated memory used for BASIC variable value store effectively.


@subsection Functions implemented in this module

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.





@subsubsection  memory_InitStructure()

Each execution context should have its own memory object responsible for the administration
of the variables and the memory storing the values assigned to variables.

This function initializes such a memory object.

@example
int memory_InitStructure(pMemoryObject pMo
  )@@{
@end example
@subsubsection  memory_RegisterType()

This function should be used to register a variable type. The return value
is the serial number of the type that should later be used to reference the type.

@example
int memory_RegisterType(pMemoryObject pMo,
                        unsigned long SizeOfThisType
  )@@{
@end example
The argument of the function is the size of the type in terms of bytes. Usually this
is calculated using the C structure @code{sizeof}.

If the type can not be registered -1 is returned.
@subsubsection  memory_RegisterTypes()

This function should be used to initialize the usual @code{FixSizeMemoryObject} types. This
sets some usual string sizes, but the caller may not call this function and set different
size objects.

@example
void memory_RegisterTypes(pMemoryObject pMo
  )@@{
@end example
This function registers the different string sizes. In the current implementation a string has
at least 32 characters. If this is longer that that (including the terminating zchar) then
a 64 byte fix size object is allocated. If this is small enough then a 128 byte fix size memory
object is allocated and so on up to 1024 bytes. If a string is longer that that then a LARGE_OBJECT_TYPE
is allocated.

The reason to register these types is that this memory management module keeps a list for these
memory pieces and when a new short string is needed it may be available already without calling
@code{malloc}. On the other hand when a @code{LARGE_OBJECT_TYPE} value is released it is always passed back
to the operating system calling @code{free}.

@subsubsection  memory_DebugDump()

This is a debugging function that dumps several variable data to the standard output.
The actual behavior of the function may change according to the actual debug needs.

@example
void memory_DebugDump(pMemoryObject pMo
  )@@{
@end example
@subsubsection  memory_NewVariable()

This function should be used whenever a new variable is to be allocated.
The function returns a pointer to a @code{FixSizeMemoryObject} structure that
holds the variable information and pointer to the memory that stores the
actual value for the memory.

If there is not engough memory or the calling is illegal the returned value is @code{NULL}
@example
pFixSizeMemoryObject memory_NewVariable(pMemoryObject pMo,
                                        int type,
                                        unsigned long LargeBlockSize
  )@@{
@end example

The second argument gives the type of the memory object to be allocated. If this
value is @code{LARGE_BLOCK_TYPE} then the third argument is used to determine the size of the
memory to be allocated. If the type if NOT @code{LARGE_BLOCK_TYPE} then this argument is
ignored and the proper size is allocated.

If the type has memory that was earlier allocated and released it is stored in a free list
and is reused.

@subsubsection  memory_ReleaseVariable()

This function should be used to release a memory object.

@example
int memory_ReleaseVariable(pMemoryObject pMo,
                           pFixSizeMemoryObject p
  )@@{
@end example
@subsubsection  memory_NewString()

This function should be used to allocate string variable.
@example
pFixSizeMemoryObject memory_NewString(pMemoryObject pMo,
                                      unsigned long StringSize
  )@@{
@end example

The second argument specifies the length of th required string including.

The function checks the desired length and if this is small then is allocates a fix size
object. If this is too large then it allocates a @code{LARGE_BLOCK_TYPE}

@subsubsection  memory_NewCString()

This function should be used to allocate variable to store a constant string.
@example
pFixSizeMemoryObject memory_NewCString(pMemoryObject pMo,
                                       unsigned long StringSize
  )@@{
@end example

The second argument specifies the length of the required string.
@subsubsection  memory_SetRef()

Set the variable @code{ppVar} to reference the variable @code{ppVal}.

@example
int memory_SetRef(pMemoryObject pMo,
                   pFixSizeMemoryObject *ppVar,
                   pFixSizeMemoryObject *ppVal
  )@@{
@end example

@subsubsection  memory_NewRef()

@example
pFixSizeMemoryObject memory_NewRef(pMemoryObject pMo
  )@@{
@end example
@subsubsection  memory_IsUndef()

This function returns if the examined variable is @code{undef}. Since a
variable containing @code{undef} but having other variables referencing this
variable is NOT stored as @code{NULL} examining the variable agains @code{NULL} is
not enough anymore since reference variables were introduced.

@example
int memory_IsUndef(pFixSizeMemoryObject pVar
  )@@{
@end example
@subsubsection  memory_Type()

This function returns the type of the variable. In case the program
does not want to check the @code{NULL} undef, but wants to get @code{VTYPE_UNDEF}
even if the variable is real @code{undef} being @code{NULL} calling this function
is safe. Use this function instead of the macro @code{TYPE} defined in @code{command.h}
is there is doubt.

@example
int memory_Type(pFixSizeMemoryObject pVar
  )@@{
@end example
@subsubsection  memory_SelfOrRealUndef()

@example
pFixSizeMemoryObject memory_SelfOrRealUndef(pFixSizeMemoryObject pVar
  )@@{
@end example
@subsubsection  memory_NewUndef()

@example
pFixSizeMemoryObject memory_NewUndef(pMemoryObject pMo
  )@@{
@end example
@subsubsection  memory_ReplaceVariable()

@example
int memory_ReplaceVariable(pMemoryObject pMo,
                           pFixSizeMemoryObject *Lval,
                           pFixSizeMemoryObject NewValue,
                           pMortalList pMortal,
                           int iDupFlag
  )@@{
@end example
@subsubsection  memory_NewLong()

@example
pFixSizeMemoryObject memory_NewLong(pMemoryObject pMo
  )@@{
@end example
@subsubsection  memory_NewDouble()

@example
pFixSizeMemoryObject memory_NewDouble(pMemoryObject pMo
  )@@{
@end example
@subsubsection  memory_CopyArray

@example
pFixSizeMemoryObject memory_CopyArray(pMemoryObject pMo,
                                      pFixSizeMemoryObject p
  )@@{
@end example
@subsubsection  memory_NewArray()

This function should be used whenever a new array is to be allocated.

@example
pFixSizeMemoryObject memory_NewArray(pMemoryObject pMo,
                                     long LowIndex,
                                     long HighIndex
  )@@{
@end example
The index variables define the indices that are to be used when accessing an
array element. The index values are inclusive.
@subsubsection  memory_ReDimArray()

This function should be used when an array needs redimensioning.
If the redimensioning is succesful the function returns the pointer
to the argument @code{p}. If memory allocation is needed and the memory
allocation fails the function returns @code{NULL}. In this case the 
original array is not changed.

If the redimensioned array is smaller that the original no memory allocation
takes place, only the array elements (pointers) are moved.

@example
pFixSizeMemoryObject memory_ReDimArray(pMemoryObject pMo,
                                       pFixSizeMemoryObject p,
                                       long LowIndex,
                                       long HighIndex
  )@@{
@end example
@subsubsection  memory_CheckArrayIndex()

This function should be called before accessing a certain element of an array.
The function checks that the index is within the index limitsof the array
and in case the index is outside the index limits of the array it redimensionate the
array.

The function returns the pointer passed as parameter @code{p} or NULL in case there is a
memory allocation error.
@example
pFixSizeMemoryObject memory_CheckArrayIndex(pMemoryObject pMo,
                                            pFixSizeMemoryObject p,
                                            long Index
  )@@{
@end example
@subsubsection  memory_Mortalize()

This function should be used when a variable is to be put in a mortal list.

@example
void memory_Mortalize(pFixSizeMemoryObject p,
                      pMortalList pMortal
  )@@{
@end example
Note that care should be taken to be sure that the variable is NOT on a mortal
list. If the variable is already on a mortal list calling this function will
break the original list and therefore may loose the variables that follow this one.
@subsubsection  memory_Immortalize()

Use this function to immortalize a variable. This can be used when the result of an expression
evaluation gets into a mortal variable and instead of copiing the value from the mortal variable to
an immortal variable the caller can immortalize the variable. However it should know which mortal list
the variable is on.

@example
void memory_Immortalize(pFixSizeMemoryObject p,
                        pMortalList pMortal
  )@@{
@end example
@subsubsection  memory_NewMortal()

When an expression is evaluated mortal variables are needed to store
the intermediate results. These variables are called mortal variables.
Such a variable is is allocated using this function and specifying a
variable of type @code{MortalList} to assign the mortal to the list of
mortal variables.

When the expression is evaluated all mortal variables are to be released
and they are calling the function @code{memory_ReleaseMortals} (see @xref{memory_ReleaseMortals()@}).
@example
pFixSizeMemoryObject memory_NewMortal(pMemoryObject pMo,
                                      BYTE type,
                                      unsigned long LargeBlockSize,
                                      pMortalList pMortal
  )@@{
@end example
If the parameter @code{pMortal} is @code{NULL} the generated variable is not mortal.
@subsubsection  memory_DupImmortal()

This function creates a new mortal and copies the argument @code{pVar} into this
new mortal.

@example
pFixSizeMemoryObject memory_DupImmortal(pMemoryObject pMo,
                                        pFixSizeMemoryObject pVar,
                                        int *piErrorCode
  )@@{
@end example
@subsubsection  memory_DupVar()

This function creates a new mortal and copies the argument @code{pVar} into this
new mortal.

@example
pFixSizeMemoryObject memory_DupVar(pMemoryObject pMo,
                                   pFixSizeMemoryObject pVar,
                                   pMortalList pMyMortal,
                                   int *piErrorCode
  )@@{
@end example
This function is vital, when used in operations that convert the
values to @code{long} or @code{double}. Expression evaluation may return an immortal
value, when the expression is a simple variable access. Conversion of the
result would modify the value of the variable itself. Therefore functions and
operators call this function to duplicate the result to be sure that the value
they convert is mortal and to be sure they do not change the value of a variable
when they are not supposed to.

Note that you can duplicate @code{long}, @code{double} and @code{string} values, but you can not
duplicate arrays! The string value is duplicated and the characters are copied to
the new location. This is perfect. However if you do the same with an array the array
pointers will point to the same variables, which are not going to be duplicated. This
result multiple reference to a single value. This situation is currently not supported
by this system as we do not have either garbage collection or any other solution to support
such memory structures.
@subsubsection  memory_DupMortalize()

This function creates a new mortal and copies the argument @code{pVar} into this
new mortal only if the value is immortal. If the value is mortal the it returns
the original value.

@example
pFixSizeMemoryObject memory_DupMortalize(pMemoryObject pMo,
                                         pFixSizeMemoryObject pVar,
                                         pMortalList pMyMortal,
                                         int *piErrorCode
  )@@{
@end example
@subsubsection  memory_ReleaseMortals()

This function should be used to release the mortal variables.

When an expression is evaluated mortal variables are needed to store
the intermediate results. These variables are called mortal variables.
Such a variable is is allocated using this function and specifying a
variable of type @code{MortalList} to assign the mortal to the list of
mortal variables.

@example
void memory_ReleaseMortals(pMemoryObject pMo,
                           pMortalList pMortal
  )@@{
@end example
@subsubsection  memory_DebugDumpVariable()

This function is used for debugging purposes. (To debug ScriptBasic and not
to debug a BASIC program using ScriptBasic. @code{:-o} )

The function prints the content of a variable to the standard output.

@example
void memory_DebugDumpVariable(pMemoryObject pMo,
                              pFixSizeMemoryObject pVar
  )@@{
@end example
@subsubsection  memory_DebugDumpMortals()

This function is used for debugging purposes. (To debug ScriptBasic and not
to debug a BASIC program using ScriptBasic. @code{:-o} )

The function prints the content of the mortal list to the standard output.

@example
void memory_DebugDumpMortals(pMemoryObject pMo,
                             pMortalList pMortal
  )@@{
@end example
@subsubsection  memory_NewMortalString()

@example
pFixSizeMemoryObject memory_NewMortalString(pMemoryObject pMo,
                                            unsigned long StringSize,
                                            pMortalList pMortal
  )@@{
@end example
If the parameter @code{pMortal} is @code{NULL} the generated variable is not mortal.
@subsubsection  memory_NewMortalCString()

@example
pFixSizeMemoryObject memory_NewMortalCString(pMemoryObject pMo,
                                             unsigned long StringSize,
                                             pMortalList pMortal
  )@@{
@end example
If the parameter @code{pMortal} is @code{NULL} the generated variable is not mortal.
@subsubsection  memory_NewMortalLong()

@example
pFixSizeMemoryObject memory_NewMortalLong(pMemoryObject pMo,
                                            pMortalList pMortal
  )@@{
@end example
If the parameter @code{pMortal} is @code{NULL} the generated variable is not mortal.
@subsubsection  memory_NewMortalRef()

This function was never used. It was presented in the code to allow external modules to
create mortal reference variables. However later I found that the variable structure design does
not allow mortal reference variables and thus this function is nonsense.

Not to change the module interface defintion the function still exists but returns NULL, like if
memory were exhausted.

@example
pFixSizeMemoryObject memory_NewMortalRef(pMemoryObject pMo,
                                         pMortalList pMortal
  )@@{
@end example
If the parameter @code{pMortal} is @code{NULL} the generated variable is not mortal.
@subsubsection  memory_NewMortalDouble()

@example
pFixSizeMemoryObject memory_NewMortalDouble(pMemoryObject pMo,
                                            pMortalList pMortal
  )@@{
@end example
If the parameter @code{pMortal} is @code{NULL} the generated variable is not mortal.
@subsubsection  memory_NewMortalArray()

@example
pFixSizeMemoryObject memory_NewMortalArray(pMemoryObject pMo,
                                           pMortalList pMortal,
                                           long IndexLow,
                                           long IndexHigh
  )@@{
@end example
If the parameter @code{pMortal} is @code{NULL} the generated variable is not mortal.
 



@section Error Reporting


@subsection Functions implemented in this module

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.






This file contains a simple error report handling function that prints the error to the standard error.

This is a default reporting function used by most variations of ScriptBasic. However some variations
like the ISAPI one needs to implements a function having the same interface.

@subsubsection  report_report()

This function implements the default error reporting function for both run-time and parse time errors and
warnings.

@example
void report_report(void *filepointer,
                   char *FileName,
                   long LineNumber,
                   unsigned int iErrorCode,
                   int iErrorSeverity,
                   int *piErrorCounter,
                   char *szErrorString,
                   unsigned long *fFlags
  )@@{
@end example
Aguments:
@itemize

@item @code{filepointer} is a @code{void *} pointer. The default value of this pointer is @code{stderr} unless the
variation sets it different. This implementation uses this pointer as a @code{FILE *} pointer. Other implementations
of this function may use it for any other purpose so long as long the usage of this pointer fits the variation.

@item @code{FileName} is the name of the source file where the error was detected. This parameter is @code{NULL} in case of
a run-time error. The reporting function is encouraged to display this information for the user.

@item @code{LineNumber} is the line number within the source file where the error has happened. This parameter is valid
only in case the parameter @code{FileName} is not @code{NULL}

@item @code{iErrorCode} is the error code.

@item @code{iErrorSeverity} should define the severity of the error. It can be
@code{REPORT_INFO},
@code{REPORT_WARNING},
@code{REPORT_ERROR},
@code{REPORT_FATAL},
@code{REPORT_INTERNAL}.
Whenever the error severity is above the warning level the @code{*piErrorCounter} has to be incremented.

@item @code{piErrorCounter} points to an @code{int} counter that counts the number of errors. If there are errors
during syntax analysis the ScriptBasic interpreter stops its execution before starting execution.

@item @code{szErrorString} is an optional error parameter string and not the displayable error message.
The error message is stored in the global constant array @code{en_error_messages}. This string may
contain a @code{%s} control referring to the error parameter string.

@item @code{fFlags} is an @code{unsigned long} bit field. The bits currently used are:
@code{REPORT_F_CGI} is set if the error is to be reported as a CGI script. See the code for more details.
@code{REPORT_F_FRST} is reset when the report function is called first time and is set by the report function. 
This allows the report function to report a header in case it needs.
Other bits are reserved for later use.

@@end itemize
 


@section The Logger Module


The logger module is included in ScriptBasic though it is not a critical part of it. The command line
version itself does not use the functions implemented in this module, though the functions are
available for external modules. The Eszter SB Application Engine uses this module to asynchronously
log hits and other events to ASCII text log files.

This module can be used to log events. The module implements two type of logs.

@itemize
@item synchronous logs
@item asynchronous logs
@@end itemize

@b{Synchronous} logs are just the normal plain logging technic writing messages to a log file. This
is low performance, because the caller has to wait until the logging is performed and written to a file.
On the other hand this is a safe logging.

Asynchronous logging is a fast performance logging method. In this case the caller passes
the log item to the logger. The logger puts the item on a queue and sends it to the log file
in another thread when disk I/O bandwith permits. This is high performance, because the caller
does not need to wait for the log item written to the disk. On the other hand this logging is not
safe because the caller can not be sure that the log was written to the disk.

The program using this module should use asynchronous logging for high volume logs and synchronous
logging for low volume logging. For example a panic log that reports configuration error has to
be written synchronously.

Using this module you can initialize a log specifying the file where to write the log, send logs and
you can tell the log to shut down. When shutting down all waiting logs are written to the file and no more
log items are accepted. When all logs are written the logging thread terminates.

@subsection  log_state()

This function safely returns the actual state of the log. This can be:

@itemize
@item @code{LOGSTATE_NORMAL} the log is normal state accepting log items
@item @code{LOGSTATE_SHUTTING} the log is currently performing shut down, it does not accept any log item
@item @code{LOGSTATE_DEAD} the log is shut down all files are closed
@item @code{LOGSTATE_SYNCHRONOUS} the log is synchronous accepting log items
@@end itemize

@example
int log_state(ptLogger pLOG
  )@@{
@end example
@subsection  log_init()

Initialize a log. The function sets the parameters of a logging thread. 
The parameters are the usual memory allocation and deallocation functions
and the log file name format string. This format string can contain at most four
@code{%d} as formatting element. This will be passed to @code{sprintf} with arguments as
year, month, day and hour in this order. This will ease log rotating.

Note that log file name calculation is a CPU consuming process and therefore it is not
performed for each log item. The log system recalculates the log file name and closes the
old log file and opens a new one whenever the actual log to be written and the last log wrote
is in a different time interval. The time interval is identified by the time stamp value
divided (integer division) by the time span value. This is 3600 when you want to rotate the log
hourly, 86400 if you want to rotate the log daily. Other rotations, like monthly do not work correctly.

To do this the caller has to set the @code{TimeSpan} field of the log structure. There is no support function
to set this.

For example:
@example

  if( log_init(&ErrLog,alloc_Alloc,alloc_Free,pM_AppLog,CONFIG("log.err.file"),LOGTYPE_NORMAL) )
    return 1;
  if( cft_GetEx(&MyCONF,"log.err.span",&ConfNode,NULL,&(ErrLog.TimeSpan),NULL,NULL) )
    ErrLog.TimeSpan = 0;

@end example

as you can see in the file @code{ad.c} Setting TimeSpan to zero results no log rotation.

Note that it is a good practice to set the TimeSpan value to positive (non zero) even if the
log is not rotated. If you ever delete the log file while the logging application is running
the log is not written anymore until the log file is reopened.

The log type can be @code{LOGTYPE_NORMAL} to perform asynchronous high performance logging and
@code{LOGTYPE_SYNCHRONOUS} for syncronous, "panic" logging. Panic logging keeps the file continously
opened until the log is shut down and does not perform log rotation.
@example
int log_init(ptLogger pLOG,
             void *(*memory_allocating_function)(size_t, void *),
             void (*memory_releasing_function)(void *, void *),
             void *pMemorySegment,
             char *pszLogFileName,
             int iLogType
  )@@{
@end example
@subsection  log_printf()

This function can be used to send a formatted log to the log file. The
function creates the formatted string and then puts it onto the log queue.
The log is actually sent to the log file by the asynchronous logger thread.

@example
int log_printf(ptLogger pLOG,
               char *pszFormat,
               ...
  )@@{
@end example
@subsection  log_shutdown()

Calling this function starts the shutdown of a log queue. This function allways return 0 as success.
When the function returns the log queue does not accept more log items, however the queue is not completely
shut down. If the caller wants to wait for the queue to shut down it has to wait and call the function
@xref{log_state@} to ensure that the shutdown procedure has been finished.

@example
int log_shutdown(ptLogger pLOG
  )@@{
@end example
 


@section Hook Functions


This file contains the hook functions that are called by the commands whenever
a command wants to access the operating system functions. The hook functions
implemented here are transparent, they call the operating system. However these hook
functions are called via the HookFunctions function pointer table and external modules
may alter this table supplying their own hook functions.

There are some hook functions, which do not exist by default. In this case the hook functions table
points to @code{NULL}. These functions, if defined are called by ScriptBasic at certain points of execution.
For example the function @code{HOOK_ExecBefore} is called each time before executing a command in case
an external module defines the function altering the hook function table.

The hook functions have the same arguments as the original function preceeded by the
pointer to the execution object @code{pExecuteObject pEo}. For example the function @code{fopen} has two arguments
to @code{char *}, and therefore HOOK_fopen has three. The first should point to @code{pEo} and the second and third should
point to 

@subsection  hook_Init

This function allocates a hook function table and fills the
function pointers to point to the original transparent hook functions.

@example
int hook_Init(pExecuteObject pEo,
              pHookFunctions *pHookers
  )@@{
@end example
@subsection  hook_file_access
@@c  file_access

This function gets a file name as an argument and return an integer code that tells
the caller if the program is allowed to read, write or both read and write to the file.
The default implementation just dumbly answers that the program is allowed both read
and write. This function is called by each other hook functions that access a file via the
file name. If a module wants to restrict the basic code to access files based on the file
name the module does not need to alter all hook functions that access files via file name.

The module has to write its own @code{file_access} hook function instead, alter the hook function table
to point to the module's function and all file accessing functions will ask the module's
hook function if the code may access the file.

The argument @code{pszFileName} is the name of the file that the ScriptBasic program
want to do something. The actual @code{file_access} hook function should decide if the
basic program is

@itemize
@item 0 not allowed to access the file
@item 1 allowed to read the file
@item 2 allowed to write the file (modify)
@item 3 allowed to read and write the file
@@end itemize

The default implementation of this function just
allows the program to do anything. Any extension module may
have its own implementation and restrict the basic program to
certain files.

@example
int hook_file_access(pExecuteObject pEo,
                     char *pszFileName
  )@@{
@end example
@subsection  hook_fopen
@@c  fopen
@example
FILE *hook_fopen(pExecuteObject pEo,
                 char *pszFileName,
                 char *pszOpenMode
  )@@{
@end example
@subsection  hook_fclose
@@c  fclose
@example
void hook_fclose(pExecuteObject pEo,
                  FILE *fp
  )@@{
@end example
@subsection  hook_size
@@c  size
@example
long hook_size(pExecuteObject pEo,
               char *pszFileName
  )@@{
@end example
@subsection  hook_time_accessed
@@c  time_accessed

@example
long hook_time_accessed(pExecuteObject pEo,
                        char *pszFileName
  )@@{
@end example
@subsection  hook_time_modified
@@c  time_modified

@example
long hook_time_modified(pExecuteObject pEo,
                        char *pszFileName
  )@@{
@end example
@subsection  hook_time_created
@@c  time_created

@example
long hook_time_created(pExecuteObject pEo,
                        char *pszFileName
  )@@{
@end example
@subsection  hook_isdir
@@c  isdir

@example
int hook_isdir(pExecuteObject pEo,
               char *pszFileName
  )@@{
@end example
@subsection  hook_isreg
@@c  isreg

@example
int hook_isreg(pExecuteObject pEo,
               char *pszFileName
  )@@{
@end example
@subsection  hook_fileexists
@@c  fileexists

@example
int hook_exists(pExecuteObject pEo,
                char *pszFileName
  )@@{
@end example
@subsection  hook_truncate
@@c  truncate
@example
int hook_truncate(pExecuteObject pEo,
                  FILE *fp,
                  long lNewFileSize
  )@@{
@end example
@subsection  hook_fgetc
@@c  fgetc
@example
int hook_fgetc(pExecuteObject pEo,
               FILE *fp
  )@@{
@end example
@subsection  hook_ferror
@@c  ferror
@example
int hook_ferror(pExecuteObject pEo,
               FILE *fp
  )@@{
@end example
@subsection  hook_fread
@@c  fread
@example
int hook_fread(pExecuteObject pEo,
               char *buf,
               int size,
               int count,
               FILE *fp
  )@@{
@end example
@subsection  hook_setmode
@@c  Set the mode of a file stream to binary or to ASCII

@example
void hook_setmode(pExecuteObject pEo,
                  FILE *fp,
                  int mode
  )@@{
@end example
@subsection  hook_binmode
@@c  Set a file stream to binary mode
@example
void hook_binmode(pExecuteObject pEo,
                  FILE *fp
  )@@{
@end example
@subsection  hook_textmode
@@c  Set a file stream to text mode
@example
void hook_textmode(pExecuteObject pEo,
                   FILE *fp
  )@@{
@end example
@subsection  hook_fwrite
@@c  fwrite
@example
int hook_fwrite(pExecuteObject pEo,
               char *buf,
               int size,
               int count,
               FILE *fp
  )@@{
@end example
@subsection  hook_fputc
@@c  fputc

@example
int hook_fputc(pExecuteObject pEo,
               int c,
               FILE *fp
  )@@{
@end example
@subsection  hook_flock
@@c  flock

@example
int hook_flock(pExecuteObject pEo,
               FILE *fp,
               int iLockType
  )@@{
@end example
@subsection  hook_lock
@@c  lock

@example
int hook_lock(pExecuteObject pEo,
              FILE *fp,
              int iLockType,
              long lStart,
              long lLength
  )@@{
  return file_lock(fp,iLockType,lStart,lLength);
@end example
@subsection  hook_feof
@@c  feof

@example
int hook_feof(pExecuteObject pEo,
              FILE *fp
  )@@{
@end example
@subsection  hook_mkdir
@@c  mkdir

@example
int hook_mkdir(pExecuteObject pEo,
               char *pszDirectoryName
  )@@{
@end example
@subsection  hook_rmdir
@@c  rmdir

@example
int hook_rmdir(pExecuteObject pEo,
               char *pszDirectoryName
  )@@{
@end example
@subsection  hook_remove
@@c  remove

@example
int hook_remove(pExecuteObject pEo,
                char *pszFileName
  )@@{
@end example
@subsection  hook_deltree
@@c  deltree

@example
int hook_deltree(pExecuteObject pEo,
                 char *pszDirectoryName
  )@@{
@end example
@subsection  hook_MakeDirectory
@@c  MakeDirectory

@example
int hook_MakeDirectory(pExecuteObject pEo,
                       char *pszDirectoryName
  )@@{
@end example
@subsection  hook_opendir
@@c  opendir

@example
DIR *hook_opendir(pExecuteObject pEo,
                  char *pszDirectoryName,
                  tDIR *pDirectory
  )@@{
@end example
@subsection  hook_readdir
@@c  readdir

@example
struct dirent *hook_readdir(pExecuteObject pEo,
                            DIR *pDirectory
  )@@{
@end example
@subsection  hook_closedir
@@c  closedir

@example
void hook_closedir(pExecuteObject pEo,
                   DIR *pDirectory
  )@@{
@end example
@subsection  hook_sleep
@@c  sleep

@example
void hook_sleep(pExecuteObject pEo,
                long lSeconds
  )@@{
@end example
@subsection  hook_curdir
@@c  curdir

@example
int hook_curdir(pExecuteObject pEo,
                char *Buffer,
                unsigned long cbBuffer
  )@@{
@end example
@subsection  hook_chdir
@@c  chdir

@example
int hook_chdir(pExecuteObject pEo,
               char *Buffer
  )@@{
@end example
@subsection  hook_chown
@@c  chown

@example
int hook_chown(pExecuteObject pEo,
               char *pszFileName,
               char *pszOwner
  )@@{
@end example
@subsection  hook_SetCreateTime
@@c  SetCreateTime

@example
int hook_SetCreateTime(pExecuteObject pEo,
                       char *pszFileName,
                       long lTime
  )@@{
@end example
@subsection  hook_SetModifyTime
@@c  SetModifyTime

@example
int hook_SetModifyTime(pExecuteObject pEo,
                       char *pszFileName,
                       long lTime
  )@@{
@end example
@subsection  hook_SetAccessTime
@@c  SetAccessTime

@example
int hook_SetAccessTime(pExecuteObject pEo,
                       char *pszFileName,
                       long lTime
  )@@{
@end example
@subsection  hook_gethostname
@@c  gethostname

@example
int hook_gethostname(pExecuteObject pEo,
                     char *pszBuffer,
                     long cbBuffer
  )@@{
@end example
@subsection  hook_gethost
@@c  gethost
@example
int hook_gethost(pExecuteObject pEo,
                 char *pszBuffer,
                 struct hostent *pHost
  )@@{
@end example
@subsection  hook_tcpconnect
@@c  tcpconnect
@example
int hook_tcpconnect(pExecuteObject pEo,
                    SOCKET *sClient,
                    char *pszRemoteSocket
  )@@{
@end example
@subsection  hook_tcpsend
@@c  tcpsend
@example
int hook_tcpsend(pExecuteObject pEo,
                 SOCKET sClient,
                 char *pszBuffer,
                 long cbBuffer,
                 int iFlags
  )@@{
@end example
@subsection  hook_tcprecv
@@c  tcprecv
@example
int hook_tcprecv(pExecuteObject pEo,
                 SOCKET sClient,
                 char *pszBuffer,
                 long cbBuffer,
                 int iFlags
  )@@{
@end example
@subsection  hook_tcpclose
@@c  tcpclose
@example
int hook_tcpclose(pExecuteObject pEo,
                  SOCKET sClient
  )@@{
@end example
@subsection  hook_killproc
@@c  killproc
@example
int hook_killproc(pExecuteObject pEo,
                  long pid
  )@@{
@end example
@subsection  hook_getowner
@@c  getowner
@example
int hook_getowner(pExecuteObject pEo,
                  char *pszFileName,
                  char *pszOwnerBuffer,
                  long cbOwnerBuffer
 )@@{
@end example
@subsection  hook_fcrypt
@@c  fcrypt
@example
char *hook_fcrypt(pExecuteObject pEo,
                  char *buf,
                  char *salt,
                  char *buff
  )@@{
@end example
@subsection  hook_CreateProcess
@@c  CreateProcess
@example
long hook_CreateProcess(pExecuteObject pEo,
                         char *pszCommandLine
  )@@{
@end example
@subsection  hook_CreateProcessEx
@@c  CreateProcessEx
@example
long hook_CreateProcessEx(pExecuteObject pEo,
                          char *pszCommandLine,
                          long lTimeOut,
                          unsigned long *plPid,
                          unsigned long *plExitCode
  )@@{
@end example
@subsection  hook_waitpid
@@c  waitpid
@example
int hook_waitpid(pExecuteObject pEo,
                 long pid,
                 unsigned long *plExitCode
  )@@{
@end example
@subsection  hook_CallScribaFunction
@@c  Start to execute a scriba function

This is a hook function that performs its operation itself without
calling underlying @code{file_} function. This function is called
by external modules whenever the external module wants to execute
certain ScriptBasic function.

The external module has to know the entry point of the ScriptBasic
function.

@example
int hook_CallScribaFunction(pExecuteObject pEo,
                            unsigned long lStartNode,
                            pFixSizeMemoryObject *pArgument,
                            unsigned long NumberOfPassedArguments,
                            pFixSizeMemoryObject *pFunctionResult
  )@@{
@end example
 


@section Handle Pointers in External Modules Support Functions

@@c Handling handle pointer conversion

The functions in this file help the various ScriptBasic extension
modules to avoid crashing the system even if the BASIC programs use 
the values passed by the module in a bad way. 

For example a database handling module opens a database and allocates 
a structure describing the connection. The usual way to identify the structure 
is to return a BASIC string variable to the BASIC code that byte by byte holds 
the value of the pointer. This works on any machine having 32bit or 64bit pointers 
because strings can be arbitrary length in ScriptBasic. 

When another external module function need access to the structure it needs a 
pointer to it. This is easily done by passing the string variable to the module. 
The module converts the string variable back byte by byte to a pointer and all is fine.

Is it?

The issue is that the BASIC program may alter the pointer and pass a string containg garbage
back to the module. The module has no way to check the correctness tries to use it
and crashes the whole interpreter. (Even the other interpreters running in the same process
in different threads.)

=bold
ScriptBasic external modules should never ever pass pointers in strings back to the BASIC code.
=nobold

(Even that some of the modules written by the ScriptBasic developers followed this method formerly.)

The better solution is to store these module pointers in arrays and pass the index of the pointer
in the array to the basic application. This way the BASIC program will get INTEGER values instead
of STRING and will not be able to alter the pointer value and crash the program.

To store the pointer and get the index (we call it a handle) these functions can be used.

Whenever a pointer needs a handle the module has to call @code{GetHandle}. This function stores the
pointer and returns the handle to it. When the BASIC program passes the handle back to the module
and the module needs the pointer associated with the handle it has to call @code{GetPointer}.

When a pointer is not needed anymore the handle should be freed calling @code{FreeHandle}.

This implementation uses arrays to hold the pointers. The handles are the indexes to the array.
The index 0 is never used. Handle value zero is returned as an invalid handle value whenever
some error occures, like out of memory condition.

@subsection  handle_GetHandle
@@c GetHandle

Having a pointer allocate a handle. This function stores the
pointer and returns the handle.

The handle is a small positive integer.

If any error is happened (aka out of memory) zero is returned.
@example
unsigned long handle_GetHandle(void **pHandle,
                               void *pMEM,
                               void *pointer
  )@@{
@end example

@itemize
@item The first argument @code{pHandle} is a pointer to the handle array.
@item The second argument @code{pMEM} is the memory segment that is to be used to allocate
memory.
@item The last argument @code{pointer} is the pointer to store.
@@end itemize

Note that @code{NULL} pointer can not be stored in the array.

The pointer to the handle array @code{pHandle} should be initialized to NULL
before the first call to @code{handle_GetHandle}. For example:
@example
   void *Handle = NULL;
     ....
   if( !handle_GetHandle(&Handle,pMEM,pointer) )return ERROR_CODE;
@end example
@subsection  handle_GetPointer
@@c GetPointer

This function is the opposite of @xref{GetHandle@}. If a pointer was
stored in the handle array this function can be used to retrieve the
pointer knowing the handle.

@example
void *handle_GetPointer(void **pHandle,
                        unsigned long handle
  )@@{
@end example
@itemize
@item The first argument @code{pHandle} is the pointer to the handle array.
=ite, The second argument @code{handle} is the handle of the pointer.
@@end itemize

If there was not pointer registered with that handle the return value of the
function is @code{NULL}.
@subsection  handle_FreeHandle
@@c FreeHandle

Use this function when a pointer is no longer valid. Calling
this function releases the @code{handle} for further pointers.

@example
void handle_FreeHandle(void **pHandle,
                       unsigned long handle
  )@@{
@end example
@subsection  handle_DestroyHandleArray
@@c DestroyHandleArray

Call this function to release the handle array after all handles are
freed and there is no need for the handle heap.

Use the same memory head @code{pMEM} that was used in @xref{GetHandle@}.

@example
void handle_DestroyHandleArray(void **pHandle,
                               void *pMEM
  )@@{
@end example
 


@section Thread Support Functions

@@c thread handling routines

This file implements global thread handling functions. If the programmer uses these functions instead
of the operating system provided functions the result will be Windows NT @emph{and} UNIX portable program.
These routines handling thread and mutex locking functions had been extensively tested in commercial
projects.

@subsection  thread_CreateThread
@@c Create a new thread

This is a simplified implementation of the create thread interface.

The function creates a new @b{detached} thread.
If the thread can not be created for some reason the return value is the error
code returned by the system call @code{pthread_start} on UNIX or @code{GetLastError} on NT.

If the thread was started the return value is 0.

@example
int thread_CreateThread(PTHREADHANDLE pThread,
                      void *pStartFunction,
                      void *pThreadParameter
  )@@{
@end example
The arguments
@itemize
@item @code{pThread} is a thread handle. This should be a pointer to a variable of type @code{THREADHANDLE}. This
argument is set to hold the thread handle returned by @code{CreateThread} on NT or the pointer
returned as first argument of @code{pthread_create} under UNIX. This argument is not used further in this
module but can be used if calling system dependant functions.
@item @code{pStartFunction} should be a pointer pointing to the start function where the thread should start. This
is usually just the name of the function to start in the separate thread.
@item @code{pThreadParameter} is the pointer passed as argument to the start function.
@@end itemize

@subsection  thread_ExitThread
@@c Exit from a thread

Exit from a thread created by @xref{CreateThread@}. The implementation is simple
and does not allow any return value from the thread.

@example
void thread_ExitThread(
  )@@{
@end example
@subsection  thread_InitMutex
@@c Initialize a mutex object

This function initializes a @code{MUTEX} variable. A @code{MUTEX} variable can be used for exclusive access.
If a mutex is locked another lock on that mutex will wait until the first lock is removed. If there are
several threads waiting for a mutex to be released a random thread will get the lock when 
the actually locking thread releases the mutex. In other words
if there are several threads waiting for a mutex there is no guaranteed order of the threads getting the
mutex lock.

Before the first use of a @code{MUTEX} variable it has to be initialized calling this function.

@example
void thread_InitMutex(PMUTEX pMutex
  )@@{
@end example
Arguments:
@itemize
@item @code{pMutex} should point to a mutex variable of the type @code{MUTEX}
@@end itemize
@subsection  thread_FinishMutex
@@c Delete a mutex object

When a mutex is not used anymore by a program it has to be released to free the system resources
allocated to handle the mutex.

@example
void thread_FinishMutex(PMUTEX pMutex
  )@@{
@end example
Arguments:
@itemize
@item @code{pMutex} should point to an initialized mutex variable of the type @code{MUTEX}
@@end itemize
@subsection  thread_LockMutex
@@c Lock a mutex object

Calling this function locks the mutex pointed by the argument. If the mutex is currently locked the
calling thread will wait until the mutex becomes available.

@example
void thread_LockMutex(PMUTEX pMutex
  )@@{
@end example
Arguments:
@itemize
@item @code{pMutex} should point to an initialized mutex variable of the type @code{MUTEX}
@@end itemize
@subsection  thread_UnlockMutex
@@c Unlock a mutex object

Calling this function unlocks the mutex pointed by the argument. Calling this function on a mutex
currently not locked is a programming error and results undefined result. Different operating system
may repond different.

@example
void thread_UnlockMutex(PMUTEX pMutex
  )@@{
@end example
Arguments:
@itemize
@item @code{pMutex} should point to an initialized mutex variable of the type @code{MUTEX}
@@end itemize
@subsection  thread_shlckstry
@@c Shared locks

The following functions implement shared locking. These functions do not call system
dependant functions. These are built on the top of the MUTEX locking functions.

A shareable lock can be @b{READ} locked and @b{WRITE} locked. When a shareable lock is READ locked
another thread can also read lock the lock.

On the other hand a write lock is exclusive. A write lock can appear when there is no read lock on
a shareable lock and not write lock either.

@@cr

The story to understand the workings:

Imagine a reading room with several books. You can get into the room through a small 
entrance room, which is dark. To get in you have to switch on the light. The reading room 
has a light and a switch as well. You are not expected to read in the dark. The reading 
room is very large with several shelves that easily hide the absent minded readers and 
therefore the readers can not easily decide upon leaving if they are the last or not. This 
actually led locking up late readers in the dark or the opposite: lights running all the night.

To avoid this situation the library placed a box in the entrance room where each reader 
entering the room have to place his reader Id card. When they leave they remove the 
card. The first reader coming switches the light on, and the last one switches the light off. 
Coming first and leaving last is easily determined looking at the box after dropping the 
card or after taking the card out. If there is a single card after dropping the reader card 
into you are the first coming and if there is no card in it you took your one then you are 
the last.

To avoid quarreling and to save up energy the readers must switch on the light of the 
entrance room when they come into and should switch it off when they leave. However 
they have to do it only when they go into the reading room, but not when leaving. When 
someone wants to switch a light on, but the light is already on he or she should wait until 
the light is switched off. (Yes, this is a MUTEX.)

When the librarian comes to maintain ensures that no one is inside, switches the light of 
the entrance room on, and then switches the reading room light on. If someone is still 
there he cannot switch the light on as it is already switched on. He waits until the light is 
switched off then he switches it on. When he has switched the light of the reading room on 
he switches the light of the entrance room off and does his job in the reading room. Upon 
leaving he switches off the light of the reading room.

Readers can easily enter through the narrow entrance room one after the other. They can 
also easily leave. When the librarian comes he can not enter until all readers leave the 
reading room. Before getting into the entrance room he has equal chance as any of the 
readers. 

@subsection  thread_InitLock
@@c Initialize a shareable lock

@example
void shared_InitLock(PSHAREDLOCK p
  )@@{
@end example
@subsection  thread_FinishLock
@@c Finish a shareable lock

@example
void shared_FinishLock(PSHAREDLOCK p
  )@@{
@end example
@subsection  thread_LockRead
@@c Lock a shareable lock for shared (read) lock

@example
void shared_LockRead(PSHAREDLOCK p
  )@@{
@end example
@subsection  thread_LockWrite
@@c Lock a shareable lock for exclusive locking

@example
void shared_LockWrite(PSHAREDLOCK p
  )@@{
@end example
@subsection  thread_UnlockRead
@@c Unlock a sharebale lock that was locked shared

@example
void shared_UnlockRead(PSHAREDLOCK p
  )@@{
@end example
@subsection  thread_UnlockWrite
@@c Unlock a sharebale lock that was locked exclusive

@example
void shared_UnlockWrite(PSHAREDLOCK p
  )@@{
@end example
 

@section Dynamic Library Handling Support Functions

@@c Handling Dynamic Load Libraries

The Dynamic Load Libraries are handled different on all operating systems. This file
implements a common functional base handling the DLLs for ScriptBasic. All other modules
of ScriptBasic that want to use DLLs should call only the functions implemented in this
file.

=toc

@subsection  dynlolib_LoadLibrary
@@c Load a library

This function loads a library and returns a pointer that can be used in other functions
referencing the loaded library.
@example
void *dynlolib_LoadLibrary(
  char *pszLibraryFile
  )@@{
@end example
The argument @code{pszLibraryFile} is the ZCHAR file name.

The file name is either absolute or relative. When a relative file name is specified the
directories searched may be different on different operating systems.
@subsection  dynlolib_FreeLibrary
@@c Release a library

This function releases the library that was loaded before using @xref{dynlolib_LoadLibrary@}
@example
void dynlolib_FreeLibrary(
  void *pLibrary
  )@@{
@end example
The argument @code{pLibrary} is the pointer, which was returned by the function @xref{dynlolib_LoadLibrary@}
@subsection  dynlolib_GetFunctionByName
@@c Get the entry point of a function by its name

This function can be used to get the entry point of a function of a loaded module
specifying the name of the function.
@example
void *dynlolib_GetFunctionByName(
  void *pLibrary,
  char *pszFunctionName
  )@@{
@end example
The argument @code{pLibrary} is the pointer, which was returned by the function @xref{dynlolib_LoadLibrary@}

The argument @code{pszFunctionName} is the ZCAR function name.
 

@section Other System Dependant Functions

@@c Handling system specific file operations
=abstract
The file @code{filesys.h} contains file handling primitive functions. The reason for this module
is to have all system specific file handling functions to be separated in a single file.
All other modules use these functions that behave the same on Win32 platform as well as on UNIX.
=end
These functions are to be used by other parts of the program. They implement system
specific operations, and other levels need not care about these system specific stuff.

The function names are prefixed usually with @code{file_}, some are prefixed with @code{sys_}.

=toc

@subsection  file_fopen
@@c Open a file

This is same as fopen.

VMS has some specialities when writing a file.

@example
FILE *file_fopen(
  char *pszFileName,
  char *pszOpenMode
  )@@{
@end example
@subsection  file_fclose
@@c Close a file

This is same as fclose. Nothing special. This is just a placeholder.

@example
void file_fclose(FILE *fp
  )@@{
@end example
@subsection  file_size
@@c return the size of a file

@example
long file_size(char *pszFileName
  )@@{
@end example
@subsection  file_time_accessed
@@c return the time the file was last accessed

@example
long file_time_accessed(char *pszFileName
  )@@{
@end example
@subsection  file_time_modified
@@c return the time the file was modified

@example
long file_time_modified(char *pszFileName
  )@@{
@end example
@subsection  file_time_created
@@c return the time the file was created

@example
long file_time_created(char *pszFileName
  )@@{
@end example
@subsection  file_isdir
@@c return true if the file is a directory

@example
int file_isdir(char *pszFileName
  )@@{
@end example
@subsection  file_isreg
@@c return true if the file is a regular file (not directory)

@example
int file_isreg(char *pszFileName
  )@@{
@end example
@subsection  file_exists
@@c return true if the file exists

@example
int file_exists(char *pszFileName
  )@@{
@end example
@subsection  file_truncate
@@c truncate a file to a given length

It return 0 on success and -1 on error.

@example
int file_truncate(FILE *fp,
                  long lNewFileSize
  )@@{
@end example
@subsection  file_fgetc
@@c Get a single character from a file

Nothing special, it is just a placeholder.

@example
int file_fgetc(FILE *fp
  )@@{
@end example
@subsection  file_ferror
@@c ferror

Nothing special, it is just a placeholder.

@example
int file_ferror(FILE *fp
  )@@{
@end example
@subsection  file_fread
@@c fread

Nothing special, it is just a placeholder.

@example
int file_fread(char *buf,
               int size,
               int count,
               FILE *fp
  )@@{
@end example
@subsection  file_fwrite
@@c fwrite

Nothing special, it is just a placeholder.

@example
int file_fwrite(char *buf,
               int size,
               int count,
               FILE *fp
  )@@{
@end example
@subsection  file_fputc
@@c Get a single character from a file

Nothing special, it is just a placeholder.

@example
int file_fputc(int c, FILE *fp
  )@@{
@end example
@subsection  file_setmode
@@c Set the mode of a file stream to binary or to ASCII

Nothing special, it is just a placeholder. On UNIX this is doing
nothing transparently.

@example
void file_setmode(FILE *fp,
                  int mode
  )@@{
@end example
@subsection  file_binmode
@@c Set a file stream to binary mode
@example
void file_binmode(FILE *fp
  )@@{
@end example
@subsection  file_textmode
@@c Set a file stream to text mode
@example
void file_textmode(FILE *fp
  )@@{
@end example
@subsection  file_flock
@@c Lock a file

@example
int file_flock(FILE *fp,
               int iLockType
  )@@{
@end example
@subsection  file_lock
@@c Lock a range of a file

@example
int file_lock(FILE *fp,
              int iLockType,
              long lStart,
              long lLength
  )@@{
@end example
@subsection  file_feof
@@c Check end of file condition

Nothing special, it is just a placeholder.

@example
int file_feof(FILE *fp
  )@@{
@end example
@subsection  file_mkdir
@@c Create a directory

This is the usual UNIX mkdir function. The difference is that the access code is always 0777 on UNIX
which means that the user, group and others can read, write and execute the directory. If the permission
needed is different from that you have to call the @code{file_chmod} function as soon as it becomes available.

The argument of the function is the name of the desired directory.

@example
int file_mkdir(char *pszDirectoryName
  )@@{
@end example
@subsection  file_rmdir
@@c Remove a directory

This is the usual UNIX rmdir function.

The argument of the function is the name of the directory to be deleted.

@example
int file_rmdir(char *pszDirectoryName
  )@@{
@end example
@subsection  file_remove
@@c Remove a file

Nothing special, it is just a placeholder. This function performs the UNIX @code{remove} functionality. This
function also exists under WIN32, therefore this function is only a placeholder.

@example
int file_remove(char *pszFileName
  )@@{
@end example
@subsection  file_deltree
@@c Delete a directory tree

@example
int file_deltree(char *pszDirectoryName
  )@@{
@end example
@subsection  file_MakeDirectory

This function is a bit out of the line of the other functions in this module. This function uses the
@code{file_mkdir} function to create a directory. The difference is that this function tries to create a
directory recursively. For example you can create the directory

@code{/usr/bin/scriba}

with a simple call and the function will create the directories @code{/usr} if it did not exist, then 
@code{/usr/bin} and finally @code{/usr/bin/scriba} The function fails if the directory can not be created
because of access restrictions or because the directory path or a sub path already exists, and is not
a directory.

The argument of the function is the name of the desired directory.

The function alters the argument replacing each \ character to /

The argument may end with / since v1.0b30

If the argument is a Windows full path including the drive letter, like
'C:' the function tries to create the directory 'C:', which fails, but
ignores this error because only the last creation in the line down the
directory path is significant.

In case of error, the argument may totally be destroyed.

@example
int file_MakeDirectory(char *pszDirectoryName
  )@@{
@end example
@subsection  file_opendir
@@c Open a directory for listing

This function implements the @code{opendir} function of UNIX. The difference between this implementation and
the UNIX version is that this implementation requires a @code{DIR} structure to be passed as an argument. The
reason for this is that the Windows system calls do not allocate memory and pass return values in structures
allocated by the caller. Because we did not want to implement memory allocation in these routines
we followed the Windows like way.

The first argument @code{pszDirectoryName} is a ZCAR directory name to be scanned. The second argument is an
allocated @code{DIR} structure that has to be valid until the @code{file_closedir} is called.

The second parameter under UNIX is not used. However to be safe and portable to Win32 the parameter
should be handled with care.
@example
DIR *file_opendir(char *pszDirectoryName,
                  tDIR *pDirectory
  )@@{
@end example
@subsection  file_readdir
@@c Read next item from a directory

This function is the implementation of the UNIX @code{readdir}

@example
struct dirent *file_readdir(DIR *pDirectory
  )@@{
@end example
@subsection  file_closedir
@@c Close a directory opened for listing

@example
void file_closedir(DIR *pDirectory
  )@@{
@end example
@subsection  file_sleep
@@c Sleep the process

@example
void sys_sleep(long lSeconds
  )@@{
@end example
@subsection  file_curdir
@@c Get the current working directory

The first argument should point to a buffer having space for at least
@code{cbBuffer} characters. The function will copy the name of the current
directory into this buffer. 

Return value is zero on success. If the current directory can not be
retrieved or the buffer is too short the return value is -1.
@example
int file_curdir(char *Buffer,
                unsigned long cbBuffer
  )@@{
@end example
@subsection  file_chdir
@@c Change the current working direcory

@example
int file_chdir(char *Buffer
  )@@{
@end example
@subsection  file_chown
@@c Change owner of a file

This function implements the chown command of the UNIX operating system
on UNIX and Windows NT. The first argument is the ZCHAR terminated
file name. No wild card characters are allowed.

The second argument is the name of the desired new user. The function
sets the owner of the file to the specified user, and returns zero
if the setting was succesful. If the setting fails the function returns
an error code. The error codes are:

COMMAND_ERROR_CHOWN_NOT_SUPPORTED
COMMAND_ERROR_CHOWN_INVALID_USER
COMMAND_ERROR_CHOWN_SET_OWNER

@example
int file_chown(char *pszFile,
               char *pszOwner
  )@@{
@end example
@subsection  file_getowner
@@c Get the owner of a file

@example
int file_getowner(char *pszFileName,
                  char *pszOwnerBuffer,
                  long cbOwnerBuffer
 )@@{
@end example
@subsection  file_SetCreateTime
@@c Set the creation time of a file

Note that this time value does not exist on UNIX and
therefore calling this function under UNIX result error.

The argument to the function is the file name and the desired time
in number of seconds since the epoch. (January 1, 1970. 00:00)

If the time was set the return value is zero. If there is an error the
return value is the error code.
@example
int file_SetCreateTime(char *pszFile,
                       long lTime
  )@@{
@end example
@subsection  file_SetModifyTime
@@c Set the modification time of a file

The argument to the function is the file name and the desired time
in number of seconds since the epoch. (January 1, 1970. 00:00)

If the time was set the return value is zero. If there is an error the
return value is the error code.
@example
int file_SetModifyTime(char *pszFile,
                       long lTime
  )@@{
@end example
@subsection  file_SetAccessTime
@@c Set the access time of a file

The argument to the function is the file name and the desired time
in number of seconds since the epoch. (January 1, 1970. 00:00)

If the time was set the return value is zero. If there is an error the
return value is the error code.
@example
int file_SetAccessTime(char *pszFile,
                       long lTime
  )@@{
@end example
@subsection  file_gethostname
@@c Get the name of the actual host

This function gets the name of the host that runs the program.
The result of the function is positive if no TCP/IP protocol is
available on the machine or some error occured.

In case of success the return value is zero.
@example
int file_gethostname(char *pszBuffer,
                     long cbBuffer
  )@@{
@end example
The first argument should point to the character buffer, and the second
argument should hold the size of the buffer in bytes.
@subsection  file_gethost
@@c Get host by name or by address

This function gets the @code{struct hostent} entry for the given address.
The address can be given as a FQDN or as an IP octet tuple, like
www.digital.com or 16.193.48.55

Optionally the address may contain a port number separated by : from
the name or the IP number. The port number is simply ignored.

@example
int file_gethost(char *pszBuffer,
                 struct hostent *pHost
  )@@{
@end example
@code{pszBuffer} should hold the name or the address of the target machine.
This buffer is not altered during the function.

@code{pHost} should point to a buffer ready to hold the hostent information.

Note that the structure @code{hostent} contains pointers outside the structre.
Those pointers are copied verbatim thus they point to the original content
as returned by the underlying socket layer. This means that the values
the @code{hostent} structure points to should not be freed, altered and 
the values needed later should be copied as soon as possible into a safe
location before any other socket call is done.
@subsection  file_tcpconnect
@@c Connect a socket to a server:port

This function tries to connect to the remote port of a remote server.
The first argument of the function should be a pointer to @code{SOCKET}
variable as defined in @code{filesys.h} or in the Windows header files. The
second argument is a string that contains the name of the remote host,
or the IP number of the remote host and the desired port number following
the name separated by a colon. For example @code{index.hu:80} tries to connect
to the http port of the server @code{index.hu}. You can also write
@code{16.192.80.33:80} to get a connection. The function automatically recognizes
IP numbers and host names. The socket is created automatically calling the
system function @code{socket}.

If the function successfully connected to the remote server the return value
is zero. Otherwise the return value is the error code.

@example
int file_tcpconnect(SOCKET *sClient,
                    char *pszRemoteSocket
  )@@{
@end example
@subsection  file_tcpsend
@@c send bytes to remote server via socket

@example
int file_tcpsend(SOCKET sClient,
                 char *pszBuffer,
                 long cbBuffer,
                 int iFlags
  )@@{
@end example
@subsection  file_tcprecv
@@c receive bytes from remote server via socket

@example
int file_tcprecv(SOCKET sClient,
                 char *pszBuffer,
                 long cbBuffer,
                 int iFlags
  )@@{
@end example
@subsection  file_tcpclose
@@c close a tcp connection

@example
int file_tcpclose(SOCKET sClient
  )@@{
@end example
@subsection  file_killproc
@@c Kill a process


This function kills a process identified by the process ID (PID).

If the process is killed successfully the return value is zero, otherwise
a positive value.
@example
int file_killproc(long pid
  )@@{
@end example
@subsection  file_fcrypt
@@c Calculate encrypted password

This function implements the password encryption algorithm
using the DES function. The first argument is the clear text
password, the second argument is the two character salt value.
This need not be zero terminated. The third argument should
point to a 13 characters char array to get the encoded
password. @code{buff[13]} will contain the terminating zchar upon return.

@example
char *file_fcrypt(char *buf, char *salt, char *buff
  )@@{
@end example
@subsection  file_CreateProcess
@@c Run a new program

This function creates a new process using the argument as command line.
The function does NOT wait the new process to be finished but returns
the pid of the new process.

If the new process can not be started the return value is zero.

The success of the new process however can not be determined by the
return value. On UNIX this value is generated by the fork system call
and it still may fail to replace the executeable image calling @code{exevp}.
By that time the new program creation is already in the newprocess and
is not able to send back any error information to the caller.

The caller of this function should also check other outputs of the
created process that of the pid is returned. For example if the
@code{execv} call failed the process exit code is @code{1}. This is usually an
error information of a process.

@example
long file_CreateProcess(char *pszCommandLine
  )@@{
@end example
@subsection  file_CreateProcessEx
@@c Run a new program and wait for it

This function starts a new process and starts to wait for the process.
The caller can specify a timeout period in seconds until the function
waits.

When the process terminates or the timeout period is over the function returns.
@example
int file_CreateProcessEx(char *pszCommandLine,
                          long lTimeOut,
                          unsigned long *plPid,
                          unsigned long *plExitCode
  )@@{
@end example
Arguments:
@itemize
@item @code{pszCommandLine} the command to execute
@item @code{lTimeOut} the maximum number of seconds to wait for the process to finish. If this is zero the
function will not wait for the process. If the value is @code{-1} the function wait without limit until the created
process finishes.
@item @code{plPid} pointer to variable where the PID of the new process is placed.
This parameter can be @code{NULL}. If the function returns after the new process has terminated this
value is more or less useless. However this parameter can be used to kill processes that reach the
timeout period and do not terminate.
@item @code{plExitCode} pointer to a variable where the exit code of the new process is placed. If the
process is still running when the function returns this parameter is unaltered.
@@end itemize

The return value indicates the success of the execution of the new process:

@itemize
@item @code{FILESYSE_SUCCESS} The process was started and terminated within the specified timeout period.
@item @code{FILESYSE_NOTSTARTED} The function could not start the new process. (not used under UNIX)
@item @code{FILESYSE_TIMEOUT} The process was started but did not finish during the timeout period.
@item @code{FILESYSE_NOCODE} The process was started and finished within the timeout period but
it was not possible to retrieve the exit code.
@@end itemize

Note that the behaviour of this function is slightly different on Windows NT and on UNIX. On Windows NT
the function will return @code{FILESYSE_NOTSTARTED} when the new process can not be started. Under UNIX
the process performs a @code{fork()} and then an @code{execv}. The @code{fork()} does not return an error value. When the
@code{execvp} fails it is already in the new process and can not return an error code. It exists using the
exit code 1. This may not be distinguished from the program started and returning an exit code 1.

@subsection  file_waitpid
@@c Check on a process


This function checks if a process identified by the
process ID (PID) is still running.

If the process is live the return value is zero (FALSE), otherwise
a positive value (TRUE) is returned and the second parameter contains
the exited process's final status.
@example
int file_waitpid(long pid,
                 unsigned long *plExitCode
   )@@{
@end example
 

@section Module Management

@@c Module management

This file contains all the functions that handle external module management.

Note that all function names are prepended by @code{modu_}

@subsection  modu_Init
@@c Initialize the module management

This function allocates memory for the external module interface table and
initializes the function pointers.

If the interface already exists and the function is called again it just
silently returns.

The second argument can be zero or 1. The normal operation is zero. If @code{iForce}
is true the function sets each function pointer to its initial value even if an
initialization has already occured before.

This can be used in a rare case when a module modifies the interface table and
want to reinitialize it to the original value. Be carefule with such
constructions.

@example
int modu_Init(pExecuteObject pEo,
              int iForce
  )@@{
@end example
@subsection  modu_Preload
@@c Preload the modules configured in the configuration file

@example
int modu_Preload(pExecuteObject pEo
  )@@{
@end example
@subsection  modu_GetModuleFunctionByName
@@c Get a function entry point from a module

This function gets the entrypoint of a module function. This module can either
be statically or dynamically linked to ScriptBasic. This function is one level higher than
@xref{GetStaticFunctionByName@} or 
@xref{dynlolib_GetFunctionByName@}. The first argument to this function
is not the module handle as returned by @xref{dynlolib_LoadLibrary@} but rather the pointer to the
module description structure that holds other information on the modula. Namely the information
that the module is loaded from dll or so, or if the module is linked to the interpreter static.

@example
void *modu_GetModuleFunctionByName(
  pModule pThisModule,
  char *pszFunctionName
  )@@{
@end example
@subsection  modu_GetStaticFunctionByName
@@c Get a function entry point from a statically linked library

Get the entry point of a function that was linked to the ScriptBasic environment statically.

This is the counterpart of the function @code{dynlolib_GetFunctionByName} for functions in library
linked static. This function searches the @code{SLFST} table for the named function and returns the
entry point or @code{NULL} if there is no functions with the given name defined.

@example
void *modu_GetStaticFunctionByName(
  void *pLibrary,
  char *pszFunctionName
  )@@{
@end example
@subsection  modu_LoadModule
@@c Load a module

This function loads a module and returns the module pointer to in the argument
@code{pThisModule}. If the module is already loaded it just returns the module
pointer.

When the function is called first time for a module it loads the module, calls
the version negotiation function and the module initializer.

If module file name given in the argument @code{pszLibrary} file name is an absolute
file name this is used as it is. Otherwise the different configured module
directories are seached for the module file, and the operating system specific
extension is also appended to the file name automatically.

If the caller does not need the pointer to the module the argument @code{pThisModule}
can be @code{NULL}.
@example
int modu_LoadModule(pExecuteObject pEo,
                    char *pszLibraryFile,
                    pModule **pThisModule
  )@@{
@end example
@subsection  modu_GetFunctionByName

This function can be called to get the entry point of a function from an external module.
If the module was not loaded yet it is automatically loaded.

@example
int modu_GetFunctionByName(pExecuteObject pEo,
                           char *pszLibraryFile,
                           char *pszFunctionName,
                           void **ppFunction,
                           pModule **pThisModule
  )@@{
@end example
@subsection  modu_UnloadAllModules
@@c Unload all loaded modules

This function unloads all modules. This is called via the command finalizer mechanizm. If ever any module
was loaded via a "declare sub" statement the command execution sets the command finalizer function
pointer to point to this function.
@example
int modu_UnloadAllModules(pExecuteObject pEo
  )@@{
@end example

In a multi-threaded environment this function calls the keeper function of the module and in case the
keeper returns 1 the module is kept in memory, though the module finalizer function is called. This
lets multi-thread external modules to keep themselfs in memory even those times when there is not any
interpreter thread using the very module running.

In that case the module is put on the module list of the process SB object. That list is used to shut down
the modules when the whole process is shut down.

If there is no process SB object (pEo->pEPo is NULL) then the variation is a single process single thread
implementation of ScriptBasic. In this case this function first calls the module finalizer function
that is usally called in multi-threaded environment every time an interpreter thread is about to finish and
after this the module shutdown function is called, which is called in a multi-thread environment when
the whole process is to be shut down. After that the module is unloaded even if the keeper function said
that the module wants to stay in memory.

Don't worry about this: it is not abuse. The keeper function saying 1 means that the module has to 
stay in memory after the actual interpreter thread has finished until the process finishes. However
in this very case the process also terminates.

@b{Note:} A one-process one-thread implementation may also behave like a multi thread implementation
allocating a separate process SB object and a program object to run. Then it should inherit the
support table and the execution object of the process SB object to the runnable program object. After
running finish the runned program object and call the shutdown process for the process SB object.
But that is tricky for a single thread implementation.
@subsection  modu_UnloadModule
@@c Unload the named module

This function unloads the named module. Note that this function is not
called unless some extension module calls it to unload another module.

Currently there is no support for a module to unload itself.

@example
int modu_UnloadModule(pExecuteObject pEo,
                      char *pszLibraryFile
  )@@{
@end example
@subsection  modu_ShutdownModule
@@c Shut down a module

This function calls the shutdown function of a module.

If the shutdown function performs well and returns SUCCESS this function
also returns success. If the shutdown function returns error code
it means that the module has running thread and thus can not be unloaded.

@example
int modu_ShutdownModule(pExecuteObject pEo,
                        pModule pThisModule
  )@@{
@end example
 

@section Run Time Options Handling

@@c Setting and getting option values

Each BASIC interpreter maintains a symbol table holding option values.
These option values can be set using the BASIC command @code{OPTION} and an
option value can be retrieved using the function @code{OPTION()}.

An option has an integer value (@code{long}). Options are usually used to
alter the behaviour of some commands or modules, altough BASIC programs
are free to use any string to name an option. For example the option
@code{compare} may alter the behavior of the string comparision function
to be case sensitive or insensitive:

@example
OPTION compare 1
@end example

Unitialized options are treated as being zero. There is no special option value for uninitialized 
options. In other words BASIC programs can not distinguish between unitialized options and
options having the value zero.

This file contains the functions that handle the option symbol table. The option
symbol tableis pointed by the field @code{OptionsTable} of the execution object. This
pointer is initialized to be @code{NULL}, which means no options are available, or in other
words all options are zero.
@subsection  options_Reset
@@c Clear an option data

Calling this function resets an option. This means that the memory holding
the @code{long} value is released and the pointer that was pointing to it is set @code{NULL}.

@example
int options_Reset(pExecuteObject pEo,
                  char *name
  )@@{
@end example
@subsection  options_Set
@@c Set option data

This function sets a long value for an option. If the option
did not exist before in the symbol table it is inserted. If the
symbol table was empty (aka @code{OptionsTable} pointed @code{NULL}) the
symbol table is also created.

If the symbol already existed with some @code{long} value then the new value
is stored in the already allocated place and thus the caller
may store the pointer to the long returned by @xref{GetR@} and access 
possibly updated data without searching the table again and again.

@example
int options_Set(pExecuteObject pEo,
                char *name,
                long value
  )@@{
@end example
The function returns zero if the option was set or @code{1} if there was a memory failure.
@subsection  options_Get
@@c Get option data

This function retrieves and returns the value of an option data.

@example
long options_Get(pExecuteObject pEo,
                 char *name
  )@@{
@end example
The return value is the option value or zero in case the option is not set.
@subsection  options_GetR
@@c Get option data

This function retrieves and returns the value of an option data.

@example
long *options_GetR(pExecuteObject pEo,
                 char *name
  )@@{
@end example
The return value is a @code{long *} pointer to the option value or @code{NULL} if the option is
not set. If the caller sets the @code{long} variable pointed by the returned pointer the value of the
option is changed directly.
 

@section Simple Pattern Matching

@@c Simple Pattern Matching

=abstract
A simple, non-regular expression pattern matching module mainly to perform
file name pattern matching, like @code{*.txt} or @code{file0?.bin} and alikes.
=end

This is a simple and fast pattern matching algorithm.
This can be used when the matching does not require
regular expression complexity and the processign on 
the other hand should be fast.

There are two major tasks implemented here. One is to match a string against a pattern.
The second is to create a replacement string. When a pattern is matched by a string an
array of string values are created. Each contains a substring that matches a joker character.
Combining this array and a format string a replacement string can be created.

For example:

@example

String = "mortal  combat"
Pattern = "mo?tal co*"

@end example

the joker characters are the ?, the space (matching one or more space) and the * character.
They are matched by @code{r}, two spaces and @code{mbat}. If we use the format string

@example
Format string = "@$1u@$2"
@end example

we get the result string @code{rumbat}. The format string can contain @code{@$n} placeholders
where @code{n} starts with 1 and is replaced by the actual value of the n-th joker character.


@subsection  match_index
@@c Return the joker index of the character

There are a few characters that can be used as joker character. These are

@example
*#@$@@?&%!+/|<>
@end example

@code{match_index} returns the serial number of the character.
@example
unsigned long match_index(char ch
)@@{
@end example
@subsection  InitSets
@@c Initialize a set collection

Call this function to initialize a set collection. The argument should point to
a @code{MatchSets} structure and the function fills in the default values.

@example
void match_InitSets(pMatchSets pMS
  )@@{
@end example
@subsection  ModifySet
@@c Modify a joker set

This function can be used to modify a joker set. The first argument @code{pMS} points to the
joker set collection. The second argument @code{JokerCharacter} specifies the joker character
for which the set has to be modified.

The argument @code{nChars} and @code{pch} give the characters that are to be modified in the set.
@code{nChars} is the number of characters in the character array pointed by @code{pch}.

The last argument @code{fAction} specifies what to do. The following constants can be used in
logical OR.

@example
TO_HEADER:

#define MATCH_ADDC 0x0001 //add characters to the set
#define MATCH_REMC 0x0002 //remove characters from the set
#define MATCH_INVC 0x0004 //invert the character
#define MATCH_SNOJ 0x0008 //set becomes no-joker
#define MATCH_SSIJ 0x0010 //set becomes single joker
#define MATCH_SMUJ 0x0020 //set becomes multiple joker
#define MATCH_NULS 0x0040 //nullify the set
#define MATCH_FULS 0x0080 //fullify the set

*/
@end example

The function first checks if it has to modify the state of the joker character. If
any of the bits @code{MATCH_SNOJ}, @code{MATCH_SSIJ} or @code{MATCH_SMUJ} is set in the field
@code{fAction} the type of the set is modified.

If more than one bit of these is set then result is undefined. Current implementation
checks these bits in a specific order, but later versions may change.

If the bit @code{MATCH_NULS} is set all the characters are removed from the set. If
the bit @code{MATCH_FULS} is set all characters are put into the set.

If more than one bit of these is set then result is undefined. Current implementation
checks these bits in a specific order, but later versions may change.

@code{MATCH_NULS} or @code{MATCH_FULS} can be used in a single call to initialize the set before
adding or removing the specific characters.

The bits @code{MATCH_ADDC}, @code{MATCH_REMC} and @code{MATCH_INVC} can be used to add characters to the set,
remove characters from the set or to invert character membership. The characters are taken
from the character array pointed by the function argument @code{pch}.

If more than one bit of these is set then result is undefined. Current implementation
checks these bits in a specific order, but later versions may change.

If none of these bits is set the value of the pointer @code{pch} is ignored.

It is no problem if a character is already in the set and is added or if it is not member of the set
and is removed. Although it has no practical importance the array pointed by @code{pch} may contain a
character many times.

@example
void match_ModifySet(pMatchSets pMS,
                     char JokerCharacter,
                     int nChars,
                     unsigned char *pch,
                     int fAction
  )@@{
@end example
@subsection  match
@@c Match pattern to string
FUNCTION:

@code{match} checks if pszString matches the pattern pszPattern.
pszPattern is a string containing joker characters. These are:

@example
 * matches one or more any character
 # matches one or more digit
 @$ matches one or more alphanumeric character
 @@ matches one or more alpha character
   (space) matches one or more spaces
 ? matches a single character
@end example

 @code{~x} matches @code{x} even if @code{x} is pattern matching character or tilde

 @code{x} matches character @code{x} unless it is a joker character

RETURN VALUE:

The function returns zero if no error occures and returns an error code
in case some of the memory buffer does not have enough space. (Either
pszBuffer or ParameterArray)

PARAMETERS:

@code{pszPattern} IN
the pattern to match

--

@code{cbPattern} IN
the number of characters in the pattern

--

@code{pszString} IN 
the string which is compared to the pattern

--

@code{cbString} IN
the number of characters in the string

--

@code{ParameterArray} OUT
is an uninitialized character pointer array. Upon return
@code{ParameterArray[i]} points the string that matches the
@code{i}-th joker character.

--

@code{pcbParameterArray} OUT
is an uninititalized @code{unsigned long} array. Upon return
@code{pcbParameterArray[i]} contains the length of the
output parameter @code{ParameterArray[i]}.

--

@code{pszBuffer} OUT
should point to a buffer. The size of the buffer
should be specified by cbBufferSize. A size equal

@example
             cbString
@end example
is a safe size. The actual strings matching the joker characters
will get into this buffer zero terminated one after the other:

--

@code{cArraySize} IN
number of elements in the array @code{ParameterArray}

--

@code{cbBufferSize} IN
size of the buffer pointed by pszBuffer

--

@code{fCase} IN
pattern matching is performed case sensitive if this value if TRUE.

--

@code{iResult} OUT
TRUE if @code{pszString} matches the pattern @code{pszPattern}.
FALSE otherwise.

NOTE:

@code{pszPattern} and @code{pszString} are NOT changed.

If the function returns non-zero (error code) none of the output
variables can be reliably used.
@example
int match_match(char *pszPattern,
                unsigned long cbPattern,
                char *pszString,
                unsigned long cbString,
                char **ParameterArray,
                unsigned long *pcbParameterArray,
                char *pszBuffer,
                int cArraySize,
                int cbBufferSize,
                int fCase,
                pMatchSets pThisMatchSets,
                int *iResult
  )@@{
@end example
@subsection  count
@@c Count the joker characters in a pattern

This function counts the number of jokers in the string and returns it.
This function should be used to calculate the safe length of the pszBuffer
given as a parameter to match.
@example
int match_count(char *pszPattern,
                unsigned long cbPattern
  )@@{
@end example
@subsection  parameter
@@c Fill parameters into format string

This function takes a format string and a string array and
copies the format string replacing @code{@$0}, @code{@$1} ... @code{@$n} values with
the appropriate string values given in the array pointed by
ParameterArray.

RETURN VALUE:

The function returns zero if no error occures and returns an error code
in case some of the memory buffer does not have enough space or invalid
parameter is referenced.

PARAMETERS:
@code{pszFormat} IN
The format string containing the @$i placeholders.

--

@code{cbFormat} IN
The number of characters in the format string

--

@code{ParameterArray} IN
string array so that @code{ParameterArray[i]} is to be inserted in place of the @code{@$i} placeholders

--

@code{pcbParameterArray} IN
array of @code{unsigned long} values. @code{pcbParameterArray[i]} gives the length of the i-th string parameter.

--

@code{pszBuffer} OUT
buffer to put the result

--

@code{cArraySize} IN
Number of parameters given in the ParameterArray

--

@code{pcbBufferSize} IN/OUT
Available bytes in buffer pointed by @code{pszBuffer}. Upon return it contains the number of characters
that were placed in the buffer.

--

NOTE:

If the function returns non-zero (error code) none of the output
variables can be reliably used.
@example
int match_parameter(char *pszFormat,
                    unsigned long cbFormat,
                    char **ParameterArray,
                    unsigned long *pcbParameterArray,
                    char *pszBuffer,
                    int cArraySize,
                    unsigned long *pcbBufferSize
  )@@{
@end example
@subsection  size
@@c Calculate the neccessary buffer size

Calculate the size of the output. The IN/OUT parameter @code{cbBufferSize}
is increased by the number of needed characters.

The return value is zero if no error occured or the error code.

NOTE: cbBuffer size should be initialized to 0 if you want to get the
size of the buffer needed.
@example
int match_size(char *pszFormat,
               unsigned long cbFormat,
               unsigned long *pcbParameterArray,
               int cArraySize,
               int *cbBufferSize
  )@@{
@end example
 


@section Symbol Table Handling
The functions in this module implement a general purpose symbol table handling.

Generally a symbol table is a binding functionality that associates symbols with
attributes. Symbols in this implementation is a zero terminated string, and the 
attribute is a @code{void *} pointer. This is a general approach that can be used to store and retrieve any kind of symbols.

The symbol table handling functions usually always return a @code{void **} that can be modified to point to the actual structure storing the attributes of the symbol.

The internal structure of a symbol table is a hash table of @code{PRIME} elements (211). Each hash stores a binary table sorting the symbols.




@subsection  sym_NewSymbolTable()

This function creates a new symbol table. Later this symbol table should be used
to store and retrieve symbol information.
@example
SymbolTable sym_NewSymbolTable(
  void* (*memory_allocating_function)(size_t,void *),
  void *pMemorySegment
  )@@{
@end example
The second argument should point to the memory allocating function that the
symbol table creation process should use. The last argument is an pointer to a memory
segment which is passed to the memory allocation function. The actual arguments of the
memory allocation function fits the allocation function from the package alloc. However the
defintion is general enough to use any other function.
@subsection  sym_FreeSymbolTable()

This function should be used to release the memory allocated for a symbol table.
This function releases all the memory that was allocated during symbol table creation
and during symbol insertion.

Note that the memory allocated outside the symbol table handling routines is not
released. This means that it is the caller responsibility to relase all memory
that holds the actual values associated with the symbols.
@example
void sym_FreeSymbolTable(
  SymbolTable table,
  void (*memory_releasing_function)(void *,void *),
  void *pMemorySegment
  )@@{
@end example
@subsection  sym_TraverseSymbolTable()

This function can be used to traverse through all the symbols stored
in a symbol table. The function starts to go through the symbols and
for each symbol calls the function @code{call_back_function}.
@example
void sym_TraverseSymbolTable(
  SymbolTable table,
  void (*call_back_function)(char *SymbolName, void *SymbolValue, void *f),
  void *f
  )@@{
@end example
The first argument is the symbol table to traverse. The second argument is the
function to be called for each symbol. This function gets three arguments. The
first is a pointer to the symbol string. The second is the pointer to the symbol
arguments. The third argument is a general pointer which is passed to the
function @code{sym_TraverseSymbolTable}.

Note that the call back function gets the pointer to the symbol arguments and
not the pointer to the pointer to the symbol arguments, and therefore call back
function can not change the actual symbol value pointer.
@subsection  sym_LookupSymbol()

This function should be used to search a symbol or to insert a new symbol.

@example
void **sym_LookupSymbol(
  char *s,                 /* zero terminated string containing the symbol                 */
  SymbolTable hashtable,   /* the symbol table                                             */
  int insert,              /* should a new empty symbol inserted, or return NULL instead   */
  void* (*memory_allocating_function)(size_t, void *),
  void (*memory_releasing_function)(void *, void *),
  void *pMemorySegment
  )@@{
@end example

This function usually returns a pointer to the @code{void *} pointer which is
supposed to point to the structure, which actually holds the parameters for
the symbol. When a symbol is not found in the symbol table the parameter @code{insert}
is used to decide what to do. If this parameter is zero the function returns @code{NULL}.
If this parameter is 1 the function creates a new symbol and returns a pointer to the
@code{void *} pointer associated with the symbol.

If a new symbol is to be inserted and the function returns @code{NULL} means that the memory 
allocation function has failed.

If the new symbol was created and a pointer to the @code{void *} pointer is returned the value of
the pointer is @code{NULL}. In other words:

@example

void **a;

a = sym_LookupSymbol(s,table,1,mymema,mymemr,p);

if( a == NULL )error("memory releasing error");
if( *a == NULL )error("symbol not found");

@end example

@subsection  sym_DeleteSymbol()

This function should be used to delete a symbol from the symbol table

@example
int sym_DeleteSymbol(
  char *s,                 /* zero terminated string containing the symbol                 */
  SymbolTable hashtable,   /* the symbol table                                             */
  void (*memory_releasing_function)(void *, void *),
  void *pMemorySegment
  )@@{
@end example

This function searches the given symbol and if the symbol is found it deletes it from the
symbol table. If the symbol was found in the symbol table the return value is zero. If
the symbol was not found the return value is 1. This may be interpreted by the caller as
an error or as a warning.

Note that this function only deletes the memory that was part of the symbol table. The
memory allocated by the caller and handled via the pointer @code{value} usually returned by
@xref{sym_LookupSymbol()@} should be released by the caller.

 



@chapter Embedding the Interpreter

ScriptBasic was designed from the very start to be embeddable. This means that C programmers having their own application can fairly easy compile and link ScriptBasic together with their application and have ScriptBasic as a built in scripting language in their application.

To do this the C programmer should use the C api implemented in the file @file{scriba.c}. In this chapter we detail the C API as a reference listing all callable function, but before that there are some sections that describe a bit the overall model of ScriptBasiC. The next section will talk about what object orientation means for ScriptBasic and how to follow this object oriented approach when programming a ScriptBasic extended application in C.

@section Object Oriented Model of ScriptBasic

Although ScriptBasic is implemented in pure C the coding and developing concept is rather object oriented. Such is the concept of the C API calling interface. This means that you have to deal with an abstract ScriptBasic program object when you want to execute a program. The structure of this program object is totally private to ScriptBasic and as a programmer embedding the interpreter you need not worry about it. The only action you have to do is to create such an object before doing any other function call calling @xref{scriba_new()} and to destroy it after the BASIC program was executed and is not going to be used any more calling the function @xref{scriba_destroy()}.

The object is stored in memory and this piece of memory is allocated by ScriptBasic. The function @xref{scriba_new()} allocates this memory and returns a pointer to this "object". Later this pointer has to be used to refer to this object.

Because C is not object oriented the functions called should explicitly get this pointer as first argument. When programming C++ the class pointer is used to access the class methods, and that also implicitly passes the object pointer to the method. The pointer passing code is generated by the C++ compiler. When calling ScriptBasic API the programmer has to store the "object" pointer and pass it as first argument to any function.

The type of the object pointer is @code{pSbProgram}.

@section Sample Embedding

The best way of learning is learning by example. Therefore here we will discuss the most obvious embedding application: the command line variation of ScriptBasic. The command line variation of ScriptBasic can be found in the file @file{scribacmd.c} in the source directory @file{variations/standard}. You may also find there a file named @file{basiccmd.c} that contains the code that was used before the @code{scriba_} C API was introduced. Have a look at it and bless God you have the new API.

In this section we will present the code from the file, but for brevity some code will not be copied to here. Also note that the code is copied and as the program develops the actual code may change while the one copied here most probably remains the same. (The API definitions are not "hand" copied, but rather taken from the C file when the documentation is compiled, so whenever the API changes the new documentation recompiled reflects the change.)


@subsection Include Header Files


The main program of the standalone variation is implemented in the file @file{scribacmd.c}. If you look at the start of this program you can see that it start including the file @file{scriba.h}. This file contains all definitions that are needed by the C compiler to compile the code calling the @code{scriba_} API functions.

@example
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../../getopt.h"
#include "../../scriba.h"

#include "../../basext.h"
@end example

In case you miss the file @file{scriba.h} then you should generate it using the program @file{headerer.pl} or @file{headerer.bas} which are also part of the distribution. C header files in ScriptBasic are not maintained by themselves. The text is rather maintained inside the C code, and is extracted using one of these scripts. (They do the same task.) The reason for this is to eliminate the double maintenance of function prototypes in the C and in the header file.

The file @file{basext.h} is also @code{#include}d by the main program. This is not usually needed by other main programs. The standalone version needs it for the sole reason to be able to print out on the usage screen the extension module interface version that the actual interpreter support. This version is defined in the macro @code{INTERFACE_VERSION}. Other than that there is no reason or need to include any other file than @file{scriba.h}.

@subsection Function main(), Variable Declarations


After some macro definitions that I do not list here the start of the function @code{main} comes:

@example
main(int argc, char *argv[], char *env[])@{

. . . .  variable declarations . . . . . 


  pSbProgram pProgram;


. . . .  variable declarations . . . . . 

@end example

This piece of code defines the local variables. The variable @code{pProgram} will hold the pointer to the program object or simply saying @code{pProgram} is the program object variable. The other variables are not described here, their names and the code where they are used should make their usage and purpose clear.

@subsection Command Line handling


The next piece of code is the command line option handling. This is not described here, because this is nothing special to ScriptBasic.

@subsection Creating Program Object


The real interesting piece of code starts at this fragment:

@example
  pProgram = scriba_new(malloc,free);
@end example


This code first of all creates a new program object calling @xref{scriba_new()}. The two arguments to this function should be two pointers to two functions that will be used by the interpreter to allocate and release memory. The two functions should exhibit behavior like @code{malloc} and @code{free}. All lower layers inherit these functions and call these functions to get and to release memory. In case there are more than one program objects used they may one after the other or in different threads at the same time use the same functions or different functions. The only requirement is that the functions pointed by the arguments should be thread safe if different threads are started executing ScriptBasic interpreters. Thread safeness also may play important role when some extension module is multi-thread.

@subsection Loading Configuration

@example
  scriba_LoadConfiguration(pProgram,pszForcedConfigurationFileName);
@end example

The next function call is @xref{scriba_LoadConfiguration()}. This function gets the configuration information from the compiled configuration file. The details of configuration files is detailed in section
@xref{Configuration File Handling}.

It is not a must to call this function from the embedding application, but with some few exceptions most embedding applications will do. Most ScriptBasic interpreter program objects need configuration information to be executed successfully.

To get the configuration for a program object there are two ways:

@itemize
@item Load the configuration from a file.
@item Inherit the configuration information from another program object.
@end itemize

The second approach is necessary to gain performance in case there are several interpreters running one after the other or in parallel threads in the same process. If all these interpreters need the same configuration information they can use the same memory data, because the configuration information is not alterable by the interpreter. This way you can save the successive file loading and the extra memory space.

When the configuration is inherited it is very important that the program object holding the configuration is not destroyed while any of the inheriting program objects are alive. Therefore such applications usually create a program object that does not run any program but holds the configuration information loaded calling @xref{ scriba_LoadConfiguration()} and that exists for the life of the whole process.

For more information how to inherit the configuration information see the function @xref{scriba_InheritConfiguration()}.



@subsection Loading Internal Preprocessors

The next function call loads the internal preprocessors. This is not necessary needed for the applications. This is needed only if there is some way to load an internal preprocessor before the program code is loaded. In the case of the standalone variation the command line option @option{-i} can specify internal preprocessor names.

@example
  iError = scriba_LoadInternalPreprocessor(pProgram,pszIPreproc);
  if( iError ){
    report_report(stderr,"",0,iError,REPORT_ERROR,&iErrorCounter,NULL,&fErrorFlags);
    ERREXIT;
    }
@end example

If this function is not called by the main program for the program object the interpreter will still process internal preprocessors that are referenced by the program code using the statement @code{use}.

@subsection Setting the File Name

To successfully load a program there is a need for the name of the file that holds the source code. To specify this file name for a program object the function @xref{ scriba_SetFileName()} should be used.

@example
  scriba_SetFileName(pProgram,szInputFile);
@end example

This is the usual way getting the program into the program object, but there is another way. Some applications do not store the BASIC program string in text files, but in some other mass media, like relation database. In that case the application has to load the program string into the application memory and call @xref{ scriba_LoadProgramString()} to compile and execute the BASIC program. However in this case the program should not contain any @code{include} or @code{import} statement.

@subsection Using the Cache

ScriptBasic is powerful being able to store the compiled version of BASIC programs in binary format in file. The next piece of code checks if there is already a compiled version of the BASIC program in the configured cache directory calling the function @xref{scriba_UseCacheFile()}

@example
  if( scriba_UseCacheFile(pProgram) == SCRIBA_ERROR_SUCCESS )@{
    if( (iError = scriba_LoadBinaryProgram(pProgram)) != 0 )@{
      ERREXIT;
      @}
@end example

The function @xref{scriba_LoadBinaryProgram()} loads the binary program.

@subsection Run External Preprocessors

If the cache file is not usable then the source text has to be loaded and compiled. Before that the external preprocessors has to do their jobs if there is any. To do this the function @xref{scriba_RunExternalPreprocessor()} is called.

@example
    iError=scriba_RunExternalPreprocessor(pProgram,pszEPreproc);
@end example

It is not a must for an application to call this function. Some application may require the user to write their program in pure BASIC and not to use any preprocessor.

@subsection Loading the Source Program

When the external preprocessors are done the program has to be loaded calling the function @xref{scriba_LoadSourceProgram()}.

@example
    if( scriba_LoadSourceProgram(pProgram) )ERREXIT;
@end example

This call loads the program source and processes it up to the point of execution. All interpreter processing, file reading, inclusion of other files, lexical, syntactical analysis and program building is done calling this function.

@subsection Saving Binary File

Before executing the loaded program the application may save the compiled binary version of the program. This can be done calling the function @xref{scriba_SaveCode()} to save the binary code into a specific file, or calling the function @xref{scriba_SaveCacheFile()} to save the binary code into the cache with an automatically calculated name.

@example
    if( szOutputFile ){
      if( isCoutput )
        scriba_SaveCCode(pProgram,szOutputFile);
      else
        scriba_SaveCode(pProgram,szOutputFile);
      if( !execute )exit(0);
      }
     if( ! nocache )scriba_SaveCacheFile(pProgram);
 @end example

@subsection Execute the BASIC Program

This is the step that all the previous steps were done. This function call to @xref{scriba_Run()} executes the program.

@example
  if( iError=scriba_Run(pProgram,CmdLinBuffer) ){
 report_report(stderr,"",0,iError,REPORT_ERROR,&iErrorCounter,NULL,&fErrorFlags);
    ERREXIT;
    }
@end example

@subsection Destroying the Program Object

Although the program is executed and has finished still there is something extremely important that the application has to do: clean-up.

@example
  scriba_destroy(pProgram);


@end example

The call to @xref{scriba_destroy} releases all resources (memory) that were allocated to execute the BASIC program. Calling this function is not mandatory in a single process application that executes only one interpreter and exits from the process. In that case not calling this function the operating system is going to release the resources. However this is a bad practice.

@section ScriptBasic C API

The ScriptBasic C API is the high level programming interface that any programmer wanting to embed ScriptBasic into any application should use. This is the interface that the readily available variations of ScriptBasic use. This interface provides a general, high level abstraction interface to the ScriptBasic compilation and run-time system.

The API provides easy to use, and simple functions that can be used straightforward as well as more sophisticated, complex, harder to understand functions for special purpose application. The programmer can start with the simple functions and use the more complex ones as he or she developer the needs not fulfilled with the simpler functions.

The API delivers an object oriented calling interface even though this API is purely C and not C++. The object oriented interface means that you have to call @code{scriba_new} to create a ScriptBasic object before any other call and you have to pass the returned pointer to each called function as first argument to operate on the actual BASIC program object.

This approach allow the programmer to allocate, load, compile, run, re-run, release multiple ScriptBasic programs even in multiple threads simultaneously with the limits that the operating system imposes not ScriptBasic.



@subsection  scriba_new()

To create a new @code{SbProgram} object you have to call this function. The two arguments
should point to @code{malloc} and @code{free} or similar functions. All later memory allocation
and releasing will be performed using these functions.

Note that this is the only function that does not require a pointer to an
@code{SbProgram} object.

@example
pSbProgram scriba_new(void * (*maf)(size_t),
                      void   (*mrf)(void *)
  )@@{
@end example
@subsection  scriba_destroy()

After a ScriptBasic program was successfully execued and there is no need to
run it anymore call this function to release all memory associated with the
code.

@example
void scriba_destroy(pSbProgram pProgram
  )@@{
@end example
@subsection  scriba_NewSbData()

Allocate and return a pointer to the allocated @code{SbData} structure.

This structure can be used to store ScriptBasic variable data,
long, double or string. This function is called by other functions
from this module. Usually the programmer, who embeds ScriptBasic will rarely
call this function directly. Rather he/she will use @xref{scriba_NewSbLong()@} (as an example)
that creates a variable capable holding a @code{long}, sets the type to 
be @code{SBT_LNG} and stores initial value.

See also @xref{scriba_NewSbLong()@}, @xref{scriba_NewSbDouble()@}, @xref{scriba_NewSbUndef()@}, @xref{scriba_NewSbString()@},
@xref{scriba_NewSbBytes()@}, @xref{scriba_DestroySbData()@}.

@example
pSbData scriba_NewSbData(pSbProgram pProgram
  )@@{
@end example
@subsection  scriba_InitSbData()

This function initializes an SbData structure to hold undef value.
This function should be used to initialize an allocated @code{SbData}
memory structure. This function internally is called by @xref{scriba_NewSbData()@}.

See also @xref{scriba_NewSbLong()@}, @xref{scriba_NewSbDouble()@}, @xref{scriba_NewSbUndef()@}, @xref{scriba_NewSbString()@},
@xref{scriba_NewSbBytes()@}, @xref{scriba_DestroySbData()@}.

@example
void scriba_InitSbData(pSbProgram pProgram,
                         pSbData p
  )@@{
@end example
@subsection  scriba_UndefSbData()

This function sets an @code{SbData} structure to hold the undefined value.

This function should should not be used instead of @xref{scriba_InitSbData()@}.
While that function should be used to inititalize the memory structure this
function should be used to set the value of an alreasdy initialized and probably
used @code{SbData} variable to @code{undef}.

The difference inside is that if the @code{SbData} structure is a string then this
function releases the memory occupied by the string, while @xref{scriba_InitSbData()@} does not.

See also @xref{scriba_NewSbLong()@}, @xref{scriba_NewSbDouble()@}, @xref{scriba_NewSbUndef()@}, @xref{scriba_NewSbString()@},
@xref{scriba_NewSbBytes()@}, @xref{scriba_DestroySbData()@}.

@example
void scriba_UndefSbData(pSbProgram pProgram,
                        pSbData p
  )@@{
@end example
@subsection  scriba_NewSbLong()

This function allocates and returns a pointer pointing to a structure of
type @code{SbData} holding a @code{long} value. If the allocation failed the return
value is @code{NULL}. If the memory allocation was successful the allocated
structure will have the type @code{SBT_LONG} and will hold the initial value
specified by the argument @code{lInitValue}.

@example
pSbData scriba_NewSbLong(pSbProgram pProgram,
                         long lInitValue
  )@@{
@end example
See also @xref{scriba_NewSbLong()@}, @xref{scriba_NewSbDouble()@}, @xref{scriba_NewSbUndef()@}, @xref{scriba_NewSbString()@},
@xref{scriba_NewSbBytes()@}, @xref{scriba_DestroySbData()@}.
@subsection  scriba_NewSbDouble()

This function allocates and returns a pointer pointing to a structure of
type @code{SbData} holding a @code{double} value. If the allocation failed the return
value is @code{NULL}. If the memory allocation was successful the allocated
structure will have the type @code{SBT_DOUBLE} and will hold the initial value
specified by the argument @code{dInitValue}.

@example
pSbData scriba_NewSbDouble(pSbProgram pProgram,
                           double dInitValue
  )@@{
@end example
See also @xref{scriba_NewSbLong()@}, @xref{scriba_NewSbDouble()@}, @xref{scriba_NewSbUndef()@}, @xref{scriba_NewSbString()@},
@xref{scriba_NewSbBytes()@}, @xref{scriba_DestroySbData()@}.
@subsection  scriba_NewSbUndef()

This function allocates and returns a pointer pointing to a structure of
type @code{SbData} holding an @code{undef} value. If the allocation failed the return
value is @code{NULL}. If the memory allocation was successful the allocated
structure will have the type @code{SBT_UNDEF}.

@example
pSbData scriba_NewSbUndef(pSbProgram pProgram
  )@@{
@end example
See also @xref{scriba_NewSbLong()@}, @xref{scriba_NewSbDouble()@}, @xref{scriba_NewSbUndef()@}, @xref{scriba_NewSbString()@},
@xref{scriba_NewSbBytes()@}, @xref{scriba_DestroySbData()@}.
@subsection  scriba_NewSbString()

This function allocates and returns a pointer pointing to a structure of
type @code{SbData} holding a string value. If the allocation failed the return
value is @code{NULL}. If the memory allocation was successful the allocated
structure will have the type @code{SBT_STRING} and will hold the initial value
specified by the argument @code{pszInitValue}.

@example
pSbData scriba_NewSbString(pSbProgram pProgram,
                           char *pszInitValue
  )@@{
@end example
@b{Note on ZCHAR termination:}

The init value @code{pszInitValue} should be a zchar terminated string. Note that
ScriptBasic internally stores the strings as series byte and the length of the
string without any terminating zchar. Therefore the length of the string
that is stored should have been @code{strlen(pszInitValue)}. This does not contain the
terminating zchar.

In reality however we allocate an extra byte that stores the zchar, but the
size of the string is one character less. Therefore ScriptBasic routines
will recognize the size of the string correct and also the caller can
use the string using the macro @code{scriba_GetString} as a zchar terminated
C string. This requires an extra byte of storage for each string passed from the
embedding C application to ScriptBasic, but saves a lot of hedeache and also
memory copy when the string has to be used as a zchar terminated string.

See also @xref{scriba_NewSbLong()@}, @xref{scriba_NewSbDouble()@}, @xref{scriba_NewSbUndef()@}, @xref{scriba_NewSbString()@},
@xref{scriba_NewSbBytes()@}, @xref{scriba_DestroySbData()@}.
@subsection  scriba_NewSbBytes()

This function allocates and returns a pointer pointing to a structure of
type @code{SbData} holding a string value. If the allocation failed the return
value is @code{NULL}. If the memory allocation was successful the allocated
structure will have the type @code{SBT_STRING} and will hold the initial value
specified by the argument @code{pszInitValue} of the length @code{len}.

@example
pSbData scriba_NewSbBytes(pSbProgram pProgram,
                          unsigned long len,
                          unsigned char *pszInitValue
  )@@{
@end example
This function allocates @code{len}+1 number of bytes data and
stores the initial value pointed by @code{pszInitValue} in it.

The extra plus one byte is an extra terminating zero char
that may help the C programmers to handle the string
in case it is not binary. Please also read the not on the terminating ZChar
in the function @xref{scriba_NewSbString()@}.

See also @xref{scriba_NewSbLong()@}, @xref{scriba_NewSbDouble()@}, @xref{scriba_NewSbUndef()@}, @xref{scriba_NewSbString()@},
@xref{scriba_NewSbBytes()@}, @xref{scriba_DestroySbData()@}.
@subsection  scriba_DestroySbData()

Call this function to release the memory that was allocated by any
of the @code{NewSbXXX} functions. This function releases the memory and
also cares to release the memory occupied by the characters in case the
value had the type @code{SBT_STRING}.

@example
void scriba_DestroySbData(pSbProgram pProgram,
                          pSbData p
  )@@{
@end example
See also @xref{scriba_NewSbLong()@}, @xref{scriba_NewSbDouble()@}, @xref{scriba_NewSbUndef()@}, @xref{scriba_NewSbString()@},
@xref{scriba_NewSbBytes()@}, @xref{scriba_DestroySbData()@}.
@subsection  scriba_PurgeReaderMemory()

Call this function to release all memory that was allocated by the
reader module. The memory data is needed so long as long the lexical analyzer
has finished.
@example
void scriba_PurgeReaderMemory(pSbProgram pProgram
  )@@{
@end example
@subsection  scriba_PurgeLexerMemory()

@example
void scriba_PurgeLexerMemory(pSbProgram pProgram
  )@@{
@end example
@subsection  scriba_PurgeSyntaxerMemory()

@example
void scriba_PurgeSyntaxerMemory(pSbProgram pProgram
  )@@{
@end example
@subsection  scriba_PurgeBuilderMemory()

@example
void scriba_PurgeBuilderMemory(pSbProgram pProgram
  )@@{
@end example
@subsection  scriba_PurgePreprocessorMemory()

This function purges the memory that was needed to run the preprocessors.

@example
void scriba_PurgePreprocessorMemory(pSbProgram pProgram
  )@@{
@end example
@subsection  scriba_PurgeExecuteMemory()

This function purges the memory that was needed to execute the program,
but before that it executes the finalization part of the execution.

@example
void scriba_PurgeExecuteMemory(pSbProgram pProgram
  )@@{
@end example
@subsection  scriba_SetFileName()

Call this function to set the file name where the source informaton is.
This file name is used by the functions @xref{scriba_LoadBinaryProgram()@} and
@xref{scriba_LoadSourceProgram@} as well as error reporting functions to display
the location of the error.

@example
int scriba_SetFileName(pSbProgram pProgram,
                       char *pszFileName
  )@@{
@end example
The argument @code{pszFileName} should be zchar terminated
string holding the file name.
@subsection  scriba_GettingConfiguration()

@xref{scriba_LoadConfiguration()@} and @xref{scriba_InheritConfiguration()@} can be used to
specify configuration information for a ScriptBasic program. Here
we describe the differences and how to use the two functions for
single-process single-basic and for single-process multiple-basic
applications.

To execute a ScriptBasic program you usually need configuration information.
The configuration information for the interpreter is stored in a file.
The function @xref{scriba_LoadConfiguration()@} reads the file and loads it into memory
into the @code{SbProgram} object. When the object is destroyed the configuration
information is automatically purged from memory.

Some implementations like the Eszter SB Engine variation of ScriptBasic starts
several interpreter thread within the same process. In this case the configuration
information is read only once and all the running interpreters share the same
configuration information.

To do this the embedding program has to create a pseudo @code{SbProgram} object that
does not run any ScriptBasic program, but is used only to load the configuration
information calling the function @xref{scriba_LoadConfiguration()@}. Other @code{SbProgram} objects
that do intepret ScriptBasic program should inherit this configuration calling the
function @xref{scriba_InheritConfiguration()@}. When a @code{SbProgram} object is destroyed the
configuration is not destroyed if that was inherited belonging to a different object.
It remains in memory and can later be used by other intrepreter instances.

Inheriting the configuration is fast because it does not require loading the
configuration information from file. This is essentially sets a pointer in the
internal interpreter structure to point to the configuration information held
by the other object and all the parallel running interpreters structures
point to the same piece of memory holding the common configuration information.

See the configuration handling functions @xref{scriba_LoadConfiguration()@} and @xref{scriba_InheritConfiguration()@}.
@subsection  scriba_LoadConfiguration()

This function should be used to load the configuration information
from a file.

The return value is zero on success and the error code when error happens.
@example
int scriba_LoadConfiguration(pSbProgram pProgram,
                             char *pszForcedConfigurationFileName
  )@@{
@end example
@subsection  scriba_GetConfigFileName()

This function tells whet the configuration file is. There is no need to call this function to read the configuration file.
This is needed only when the main program want to manipulate the configuration file in some way. For example the command
line version of ScriptBasic uses this function when the option @code{-k} is used to compile a configuration file.

The first argument has to be a valid ScriptBasic program object. The second argument should point to a valid @code{char *} pointer that
will get the pointer value to the configuration file name after the function returns.
@example
int scriba_GetConfigFileName(pSbProgram pProgram,
                             char **ppszFileName
  )@@{
@end example
The function returns zero if no error happens, or the error code.
@subsection  scriba_InheritConfiguration()

Use this function to get the configuration from another program object.

The return value is zero on success and error code if error has happened.
@example
int scriba_InheritConfiguration(pSbProgram pProgram,
                                pSbProgram pFrom
  )@@{
@end example
@subsection  scriba_InitModuleInterface()

Initialize the Support Function Table of a process level ScriptBasic program object to be inherited
by other program objects. If you read it first time, read on until you understand what this
function really does and rather how to use it!

This is going to be a bit long, but you better read it along with the documentation of the
function @xref{scriba_InheritModuleInterface()@}.

This function is needed only for programs that are
@itemize
@item multi thread running several interpreters simultaneous in a single process
@item support modules like the sample module @code{mt} that support multithread behaviour and
      need to implement worker thread needing call-back functions.
@@end itemize

You most probably know that modules can access system and ScriptBasic fucntions via a
call-back table. That is a huge @code{struct} containing pointers to the functions that
ScriptBasic implements. This is the @code{ST} (aka support table).

This helps module writers to write system independent
code as well as to access ScriptBasic functions easily. On the other hand modules are
also free to alter this table and because many functions, tough not all are called via this
table by ScriptBasic itself a module may alter the core behavior of ScriptBasic.

For this reason each interpreter has its own copy of @code{ST}.
This means that if an interpreter alters the table it has no effect on another interpreter
running in the same process in anther thread.

This is fine so far. How about modules that run asynchronous threads? For example the very first
interpter thread that uses the module @code{mt} starts in the initialization a thread that later 
deletes all sessions that time out. This thread lives a long life.

The thread that starts the worker thread is an interpreter thread and has its own copy of the @code{ST}.
The thread started asynchronous however should not use this @code{ST} because the table is purged 
from memory when the interpreter instance it blelonged to finishes.

To have @code{ST} for worker threads there is a need for a program object that is not purged
from memory so long as long the process is alive. Fortunately there is such an object: the
configuration program object. Configuration is usually read only once by multi-thread implementations
and the same configuration information is shared by the serveral threads. The same way the
several program objects may share a @code{ST}.

The difference is that configuration is NOT altered by the interpreter or by any module in any way
but @code{ST} may. Thus each  execution object has two pointers: @code{pST} and @code{pSTI}. While @code{pST} points to
the support table that belongs to the interpreter instance the secondpointer @code{pSTI} points to
a @code{ST} that is global for the whole process and is permanent. This @code{ST} is to be used by worker threads
and should not be altered by the module without really good reason.

Thus: Don't call this function for normal program objects! For usualy program objects module
interface is automatically initialized when the first module function is called. Call this function
to initialize a @code{ST} for a pseudo program object that is never executed but rather used to inherit this
@code{ST} for worker threads.

@example
int scriba_InitModuleInterface(pSbProgram pProgram
  )@@{
@end example
@subsection  scriba_InheritModuleInterface()

Inherit the support function table (@code{ST}) from another program object.

Note that the program object is going to initialize its own @code{ST} the normal
way. The inherited @code{ST} will only be used by worker threads that live a long
life and may exist when the initiating interpreter thread already exists.

For further information please read the description of the function @xref{scriba_InitModuleInterface()@}.

@example
int scriba_InheritModuleInterface(pSbProgram pProgram,
                                  pSbProgram pFrom
  )@@{
@end example
@subsection  scriba_InheritExecuteObject()

@example
int scriba_InheritExecuteObject(pSbProgram pProgram,
                                  pSbProgram pFrom
  )@@{
@end example
@subsection  scriba_SetProcessSbObject()

Use this program in multi-thread environment to tell the actual interpreter
which object is the process level pseudo object that 

@itemize
@item holds the shared (among interpreter thread objects) configuration 
information (see @xref{scriba_InheritConfiguration()@})
@item holds the process level module interface (see @xref{scriba_InheritModuleInterface()@})
@item holds the list of loaded modules that are not unloaded by the thread loaded the module
@@end itemize

If the embeddingprogram calls this function there is no need to call @xref{scriba_InheritConfiguration()@}
and @xref{scriba_InheritModuleInterface()@}. This function call does all those tasks and also other things.

@example
int scriba_SetProcessSbObject(pSbProgram pProgram,
                              pSbProgram pProcessObject
  )@@{
@end example
@subsection  scriba_ShutdownMtModules()

A multi threaded application should call this function for the process SB object
when the process finishes. Calling this function will call each of the shutdown
functions of those external modules that decided to keep in memory and export
the shutdown function named @code{shutmodu}. This allows these modules to gracefully
shut down their operation. As an example cached data can be written to disk, or
database connections can be closed.

@example
int scriba_ShutdownMtModules(pSbProgram pProgram
  )@@{
@end example
@subsection  scriba_SetCgiFlag()

You can call this function to tell the reporting subsystem that
this code runs in a CGI environment and therefore it should format
error messages according to the CGI standard sending to the 
standard output including HTTP headers and HTML code pieces.

@example
void scriba_SetCgiFlag(pSbProgram pProgram
  )@@{
@end example
@subsection  scriba_SetReportFunction()

This function should be used to set the report function for a program. The report function
is used to send info, warning, error, fatal and internal error messages to the user.

In case you want to implement a specific report function see the sample implementation in the
file @code{report.c}. The documentation of the function @code{report_report} describes not only the details
of the sample implementation but also the implementation requests for other reporting functions.

@example
void scriba_SetReportFunction(pSbProgram pProgram,
                              void *fpReportFunction
  )@@{
@end example
@subsection  scriba_SetReportPointer()

This pointer will be passed to the reporting function. The default
reporting uses this pointer as a @code{FILE *} pointer. The default value
for this pointer is @code{stderr}.

Other implementations of the reporting function may use this pointer
according their needs. For example the WIN32 IIS ISAPI implementation
uses this pointer to point to the extension controll block structure.
@example
void scriba_SetReportPointer(pSbProgram pProgram,
                             void *pReportPointer
  )@@{
@end example
@subsection  scriba_SetStdin()

You can call this function to define a special standard input function. This
pointer should point to a function that accepts a @code{void *} pointer
as argument. Whenever the ScriptBasic program tries to read from the
standard input it calls this function pasing the embedder pointer as
argument.

If the @code{stdin} function is not defined or the parameter is @code{NULL}
the interpreter will read the normal @code{stdin} stream.

@example
void scriba_SetStdin(pSbProgram pProgram,
                     void *fpStdinFunction
  )@@{
@end example
@subsection  scriba_SetStdout()

You can call this function to define a special standard output function. This
pointer should point to a function that accepts a @code{(char, void *)} arguments.
Whenever the ScriptBasic program tries to send a character to the standard output
it calls this function. The first parameter is the character to write, the second
is the embedder pointer.

If the standard output function is not defined or the parameter is @code{NULL}
the interpreter will write the normal @code{stdout} stream.

@example
void scriba_SetStdout(pSbProgram pProgram,
                      void *fpStdoutFunction
  )@@{
@end example
@subsection  scriba_SetEmbedPointer()

This function should be used to set the embed pointer.

The embed pointer is a pointer that is not used by ScriptBasic itself. This
pointer is remembered by ScriptBasic and is passed to call-back functions.
Like the standard input, output and environment functions that the embedding
application may provide this pointer is also available to external modules implemented
in C or other compiled language in DLL or SO files.

The embedder pointer should usually point to the @code{struct} of the thread local data.
For example the Windows NT IIS variation of ScriptBasic sets this variable to point to
the extension control block.

If this pointer is not set ScriptBasic will pass @code{NULL} pointer to the extensions and
to the call-back function.
@example
void scriba_SetEmbedPointer(pSbProgram pProgram,
                            void *pEmbedder
  )@@{
@end example
@subsection  scriba_SetEnvironment()

You can call this function to define a special environment query function. This
pointer should point to a function that accepts a @code{(void *, char *, long )} arguments.

Whenever the ScriptBasic program tries to get the value of an enviroment variable
it calls this function. The first argument is the embedder pointer.

The second argument is the name of the environment variable to retrieve or @code{NULL}.

The third argument is either zero or is the serial number of the environment variable.

ScriptBasic never calls this function with both specifying the environment variable name
and the serial number.

The return value of the function should either be @code{NULL} or should point to a string that
holds the zero character terminated value of the environment variable. This string is not
changed by ScriptBasic.

If the special environment function is not defined or is @code{NULL} ScriptBasic uses the
usual environment of the process calling the system function@code{getenv}.

@example
void scriba_SetEnvironment(pSbProgram pProgram,
                           void *fpEnvirFunction
  )@@{
@end example
For a good example of a self-written environment function see the source of the Eszter SB Engine
that alters the environment function so that the ScriptBasic programs feel as if they were executed in a
real CGI environment.
@subsection  scriba_LoadBinaryProgramWithOffset()

Use this function to load ScriptBasic program from a file that is already compiled into
internal form, and the content of the program is starting on @code{lOffset}

The return value is the number of errors (hopefully zero) during program load.

@example
int scriba_LoadBinaryProgramWithOffset(pSbProgram pProgram,
                                       long lOffset,
                                       long lEOFfset
  )@@{
@end example
Before calling this function the function @xref{scriba_SetFileName()@} should have been called specifying the
file name.
@subsection  scriba_LoadBinaryProgram()

Use this function to load ScriptBasic program from a file that is already compiled into
internal form.

The return value is the number of errors (hopefully zero) during program load.

@example
int scriba_LoadBinaryProgram(pSbProgram pProgram
  )@@{
@end example
Before calling this function the function @xref{scriba_SetFileName()@} should have been called specifying the
file name.
@subsection  scriba_InheritBinaryProgram()

Use this function in application that keeps the program code in memory.

@example
int scriba_InheritBinaryProgram(pSbProgram pProgram,
                                pSbProgram pFrom
  )@@{
@end example

The function inherits the binary code from the program object @code{pFrom}.
In server type applications the compiled binary code of a BASIC program may
be kept in memory. To do this a pseudo program object should be created that
loads the binary code and is not destroyed.

The program object used to execute the code should inherit the binary code from
this pseudo object calling this function. This is similar to the configuration
inheritance.

@subsection  scriba_LoadInternalPreprocessor()

This function can be used by embedding applications to load an
internal preprocessor into the interpereter. Note that preprocessors
are usually loaded by the reader module when a @code{preprocess} statement
is found. However some preprocessors in some variation of the interpreter
may be loaded due to configuration or command line option and not
because the source requests it.

The preprocessors that are requested to be loaded because the source
contains a @code{preprocess} line usually implement special language
fetures. The preprocessors that are loaded independent of the source
because command line option or some other information tells the variation
to call this function are usually debuggers, profilers.

(To be honest, by the time I write it there is no any internal preprocessors
developed except the test one, but the statement above will become true.)

@example
int scriba_LoadInternalPreprocessor(pSbProgram pProgram,
                            char *ppszPreprocessorName[]
  )@@{
@end example
The first argument is the program object. If the program object does not
have a preprocessor object the time it is called the preprocessor object is
created and initiated.

The second argument is the array of names of the preprocessor as it is present
in the configuration file. This is not the name of the DLL/SO file, but
rather the symbolic name, which is associated with the file. The final element
of the array has to be @code{NULL}.

The return value is zero or the error code.
@subsection  scriba_ReadSource()

Loads the source code of a ScriptBasic program from a text file.

The return code is the number of errors happened during read.

@example
int scriba_ReadSource(pSbProgram pProgram
  )@@{
@end example
@b{Do not get confused!} This function only reads the source. Does not compile it.
You will usually need @xref{scriba_LoadSourceProgram()@} that does reading, analyzing, building
and all memory releases leaving finally a ready-to-run code in memory.

Before calling this function the function @xref{scriba_SetFileName()@} should have been called specifying the
file name.

See also @xref{scriba_ReadSource()@}, @xref{scriba_DoLexicalAnalysis()@},
@xref{scriba_DoSyntaxAnalysis()@}, @xref{scriba_BuildCode()@}.
@subsection  scriba_DoLexicalAnalysis()

This function performs lexical analysis after the source file has beed read.

This function is rarely needeed by applicationdevelopers. See @xref{scriba_LoadSourceProgram()@}
instead.
@example
int scriba_DoLexicalAnalysis(pSbProgram pProgram
  )@@{
@end example
See also @xref{scriba_ReadSource()@}, @xref{scriba_DoLexicalAnalysis()@},
@xref{scriba_DoSyntaxAnalysis()@}, @xref{scriba_BuildCode()@}.
@subsection  scriba_DoSyntaxAnalysis()

This function performs syntax analysis after the lexical analysis has been finished.

This function is rarely needeed by applicationdevelopers. See @xref{scriba_LoadSourceProgram()@}
instead.
@example
int scriba_DoSyntaxAnalysis(pSbProgram pProgram
  )@@{
@end example
See also @xref{scriba_ReadSource()@}, @xref{scriba_DoLexicalAnalysis()@},
@xref{scriba_DoSyntaxAnalysis()@}, @xref{scriba_BuildCode()@}.
@subsection  scriba_BuildCode()

This function builds the finall ready-to-run code after the syntax
analisys has been finished.

This function is rarely needeed by applicationdevelopers. See @xref{scriba_LoadSourceProgram()@}
instead.
@example
int scriba_BuildCode(pSbProgram pProgram
  )@@{
@end example
See also @xref{scriba_ReadSource()@}, @xref{scriba_DoLexicalAnalysis()@},
@xref{scriba_DoSyntaxAnalysis()@}, @xref{scriba_BuildCode()@}.
@subsection  scriba_IsFileBinaryFormat()

This function decides if a file is a correct binary format ScriptBasic
code file and returns true if it is binary. If the file is a ScriptBasic
source file or an older version binary of ScriptBasic or any other file
it returns zero.

This function just calls the function @code{build_IsFileBinaryFormat}

@example
int scriba_IsFileBinaryFormat(pSbProgram pProgram
  )@@{
@end example
@subsection  scriba_GetCacheFileName()

Calculate the name of the cache file for the given source file name and
store the calculated file name in the program object.

@example
int scriba_GetCacheFileName(pSbProgram pProgram
  )@@{
@end example
The program returns zero or the error code. It returns @code{SCRIBA_ERROR_FAIL} if there
is no cache directory configured.

The code uses a local buffer of length 256 bytes. The full cached file name should
fit into this otherwise the program will return @code{SCRIBA_ERROR_BUFFER_SHORT}.

The code does not check if there exists an appropriate cache directory or file. It
just calculates the file name.
@subsection  scriba_UseCacheFile()

Call this function to test that the cache file is usable. This function
calls the function @xref{scriba_GetCacheFileName()@} to calculate the cache file name.

If 
@itemize
@item the cache file exists
@item is newer than the source file set by @xref{scriba_SetFileName()@}
@item is a correct ScriptBasic binary file
@@end itemize
then this function alters the source file name property (@code{pszFileName})
of the program object so that the call to @xref{scriba_LoadBinaryProgram()@} will try to
load the cache file.

@example
int scriba_UseCacheFile(pSbProgram pProgram
  )@@{
@end example
The function returns zero or the error code. The function returns @code{SCRIBA_ERROR_FAIL}
in case the cache file is old, or not valid. Therefore returning a positive value
does not neccessarily mean a hard error.
@subsection  scriba_SaveCacheFile()

Call this function to generate a cache file after
a successful program compilation.

@example
int scriba_SaveCacheFile(pSbProgram pProgram
  )@@{
@end example
The function returns zero (@code{SCRIBA_ERROR_SUCCESS}) if there was no error.
This does not mean that the cache file was saved. If there is no cache
directory configured doing nothing is success.

Returning any positive error code means that ScriptBasic tried to write a
cache file but it could not.
@subsection  scriba_RunExternalPreprocessor()

This function should be called to execute external preprocessors.

This function does almost nothing else but calls the function
@code{epreproc()}.

@example
int scriba_RunExternalPreprocessor(pSbProgram pProgram,
                                   char **ppszArgPreprocessor
  )@@{
@end example
The argument @code{ppszArgPreprocessor} should point to a string array. This string array
should contain the configured names of the preprocessors that are applied one after the
other in the order they are listed in the array.

Note that this array should contain the symbolic names of the preprocessors. The actual
preprocessor executable programs, or command lines are defined in the configuration
file.

After calling this function the source file name property of the program object (@code{pszFileName})
is also modified so that it points to the result of the preprocessor. This means that after the
successful return of this function the application may immediately call @xref{scriba_LoadSourceProgram()@}.

If there is any error during the preprocessor execution the function returns some error code
(returned by @code{epreproc}) otherwise the return value is zero.
@subsection  scriba_SaveCode()

Call this function to save the compiled byte code of the program
into a specific file. This function is called by the function @xref{scriba_SaveCacheFile()@}.
@example
int scriba_SaveCode(pSbProgram pProgram,
                     char *pszCodeFileName
  )@@{
@end example
The function does nothing else, but calls @code{build_SaveCode}.

The return code is zero or the error code returned by @code{build_SaveCode}.
@subsection  scriba_SaveCCode()

@example
void scriba_SaveCCode(pSbProgram pProgram,
                      char *pszCodeFileName
  )@@{
@end example
@subsection  scriba_SaveECode()

@example
void scriba_SaveECode(pSbProgram pProgram,
                      char *pszInterpreter,
                      char *pszCodeFileName
  )@@{
@end example
@subsection  scriba_LoadSourceProgram()

Call this function to load a BASIC program from its source format after
optionally checking that there is no available cache file and after
executing all required preprocessors. This function calls
@xref{scriba_ReadSource()@}, @xref{scriba_DoLexicalAnalysis()@}, @xref{scriba_DoSyntaxAnalysis()@}, @xref{scriba_BuildCode()@},
and also releases the memory that was needed only for code building
calling @xref{scriba_PurgeReaderMemory()@}, @xref{scriba_PurgeLexerMemory()@}, @xref{scriba_PurgeSyntaxerMemory()@}.

After the successful completion of this program the BASIC program is in
the memory in the ready-to-run state.
@example
int scriba_LoadSourceProgram(pSbProgram pProgram
  )@@{
@end example
Before calling this function the function @xref{scriba_SetFileName()@} should have been called specifying the
file name.

The return value is zero (@code{SCRIBA_ERROR_SUCCESS}) or the error code returned by the
underlying layer that has detected the error.
@subsection  scriba_LoadProgramString()

Use this function to convert a string containing a BASIC program
that is already in memory to ready-to-run binary format. This function
is same as @xref{scriba_LoadSourceProgram()@} except that this function reads the source
code from a string instead of a file.
@example
int scriba_LoadProgramString(pSbProgram pProgram,
                             char *pszSourceCode,
                             unsigned long cbSourceCode
  )@@{
@end example
The argument @code{pProgram} is the program object. The argument @code{pszSourceCode}
is the BASIC program itself in text format. Because the source code may
contain ZCHAR just for any chance the caller has to provide the number of
characters in the buffer via the argument @code{cbSourceCode}. In case the
source program is zero terminated the caller can simply say
@code{strlen(pszSourceCode)} to give this argument.

Before calling this function the function @xref{scriba_SetFileName()@} may be called. Altough
the source code is read from memory and thus there is no source file the
BASIC program may use the command @code{include} or @code{import} that includes
another source file after reading the code. If the program does so the reader
functions need to know the actual file name of the source code to find
the file to be included. To help this process the caller using this function
may set the file name calling @xref{scriba_SetFileName()@}. However that file is never used
and need not even exist. It is used only to calculate the path of included files
that are specified using relative path.

The return value is zero (@code{SCRIBA_ERROR_SUCCESS}) or the error code returned by the
underlying layer that has detected the error.
@subsection  scriba_Run()

Call this function to execute a program. Note that you can call this function
many times. Repetitive execution of the same program will execute the
ScriptBasic code again and again with the global variables keeping their values.

If you want to reset the global variables you have to call @xref{scriba_ResetVariables()@}.

There is no way to keep the value of the local variables.

The argument @code{pszCommandLineArgument} is the command part that is passed to the
BASIC program.
@example
int scriba_Run(pSbProgram pProgram,
               char *pszCommandLineArgument
  )@@{
@end example
The return value is zero in case of success or the error code returned by the underlying
execution layers.

Note that you can not call BASIC subroutines or functions without initializations that
@code{scriba_Run} performs. You also can not access global variables. Therefore you either have
to call @code{scriba_Run} or its brother @xref{scriba_NoRun()@} that performs the initializations without execution.

You also have to call @xref{scriba_NoRun()@} if you want to execute a program with some global variables
having preset values that you want to set from the embedding C program. In that case you
have to call @xref{scriba_NoRun()@} then one or more times @xref{scriba_SetVariable()@} and finally @code{Run}.

@subsection  scriba_NoRun()

In case the embedding program want to set global variables and
execute subroutines without or before starting the main program it has to call this
function first. It does all the initializations that are done by
@xref{scriba_Run()@} except that it does not actually execute the program.

After calling this function the main program may access global variables
and call BASIC functions.

@example
int scriba_NoRun(pSbProgram pProgram
  )@@{
@end example
See also @xref{scriba_Run()@}.
@subsection  scriba_ResetVariables()

Call this function if you want to execute a program object that was already executed
but you do not want the global variables to keep their value they had when
the last execution of the BASIC code finished.

Global variables in ScriptBasic are guaranteed to be @code{undef} before they get any other
value and some programs depend on this.

@example
void scriba_ResetVariables(pSbProgram pProgram
  )@@{
@end example
See also @xref{scriba_SetVariable()@}, @xref{scriba_Run()@}, @xref{scriba_NoRun()@}.
@subsection  scriba_Call()

This function can be used to call a function or subroutine. This function does not
get any arguments and does not provide any return value.

@example
int scriba_Call(pSbProgram pProgram,
                unsigned long lEntryNode
  )@@{
@end example
The return value is zero or the error code returned by the interpreter.

@b{Note on how to get the Entry Node value:}

The argument @code{lEntryNode} should be the node index of the subroutine or function that
we want to execute. This can be retrieved using the function @xref{scriba_LookupFunctionByName()@} if the
name of the function or subroutine is know. Another method is that the BASIC program
stored this value in some global variables. BASIC programs can access this information
calling the BASIC function @code{Address( f() )}.
@subsection  scriba_CallArg()

This function can be used to call a function or subroutine with arguments passed by value.
Neither the return value of the SUB nor the modified argument variables are not accessible 
via this function. @code{CallArg} is a simple interface to call a ScriptBasic subroutine or
function with argument.

@example
int scriba_CallArg(pSbProgram pProgram,
                   unsigned long lEntryNode,
                   char *pszFormat, ...
  )@@{
@end example
Arguments

@itemize
@item @code{pProgram} is the class variable.
@item @code{lEntryNode} is the start node of the SUB. (See @xref{scriba_Call()@} note on how to get the entry node value.)
@item @code{pszFormat} is a format string that defines the rest of the areguments
@@end itemize

The format string is case insensitive. The characters @code{u}, @code{i}, @code{r}, @code{b} and @code{s} have meaning.
All other characters are ignored. The format characters define the type of the arguments
from left to right.

@itemize
@item @code{u} means to pass an @code{undef} to the SUB. This format character is exceptional that it does not
consume any function argument.
@item @code{i} means that the next argument has to be @code{long} and it is passed to the BASIC SUB as an integer.
@item @code{r} means that the next argument has to be @code{double} and it is passed to the BASIC SUB as a real.
@item @code{s} means that the next argument has to be @code{char *} and it is passed to the BASIC SUB as a string.
@item @code{b} means that the next two arguments has to be @code{long cbBuffer} and @code{unsigned char *Buffer}.
The @code{cbBuffer} defines the length of the @code{Buffer}.
@@end itemize

Note that this SUB calling function is a simple interface and has no access to the modified values of the argument
after the call or the return value.

If you need any of the functionalities that are not implemented in this function call a more sophisticated
function.

Example:
@example

  iErrorCode = scriba_CallArg(&MyProgram,lEntry,"i i s d",13,22,"My string.",54.12);

@end example

@subsection  scriba_DestroySbArgs()

This function can be used to release the memory used by arguments created by the
function @xref{scriba_NewSbArgs()@}.

@example
void scriba_DestroySbArgs(pSbProgram pProgram,
                          pSbData Args,
                          unsigned long cArgs
  )@@{
@end example

Arguments:
@itemize
@item @code{pProgram} class variable
@item @code{Args} pointer returned by @xref{scriba_NewSbArgs()@}
@item @code{cArgs} the number of arguments pointed by @code{Args}
@@end itemize

@subsection  scriba_NewSbArgs()

Whenever you want to handle the variable values that are returned by the scriba subroutine
you have to call @xref{scriba_CallArgEx()@}. This function needs the arguments passed in an array of @code{SbDtata} type.

This function is a usefuly tool to convert C variables to an array of @code{SbData}

@example
pSbData scriba_NewSbArgs(pSbProgram pProgram,
                         char *pszFormat, ...
  )@@{
@end example
The arguments passed are 

@itemize
@item @code{pProgram} is the class variable
@item @code{pszFormat} is the format string
@@end itemize

The format string is case insensitive. The characters @code{u}, @code{i}, @code{r}, @code{b} and @code{s} have meaning.
All other characters are ignored. The format characters define the type of the arguments
from left to right.

@itemize
@item @code{u} means to pass an @code{undef} to the SUB. This format character is exceptional that it does not
consume any function argument.
@item @code{i} means that the next argument has to be @code{long} and it is passed to the BASIC SUB as an integer.
@item @code{r} means that the next argument has to be @code{double} and it is passed to the BASIC SUB as a real.
@item @code{s} means that the next argument has to be @code{char *} and it is passed to the BASIC SUB as a string.
@item @code{b} means that the next two arguments has to be @code{long cbBuffer} and @code{unsigned char *Buffer}.
The @code{cbBuffer} defines the leng of the @code{Buffer}.
@@end itemize

Example:

@example

pSbData MyArgs;


  MyArgs = scriba_NewSbArgs(pProgram,"i i r s b",13,14,3.14,"string",2,"two character string");
  if( MyArgs == NULL )error("memory alloc");

  scriba_CallArgEx(pProgram,lEntry,NULL,5,MyArgs);

@end example

This example passes five arguments to the ScriptBasic subroutine. Note that the last one is only
two character string, the rest of the characters are ignored.

@subsection  scriba_CallArgEx()

This is the most sophisticated function of the ones that call a ScriptBasic subroutine.
This function is capable handling parameters to scriba subroutines, and returning the
modified argument variables and the return value.

@example
int scriba_CallArgEx(pSbProgram pProgram,
                     unsigned long lEntryNode,
                     pSbData ReturnValue,
                     unsigned long cArgs,
                     pSbData Args
  )@@{
@end example
The arguments:
@itemize
@item @code{pProgram} is the program object pointer.
@item @code{lEntryNode} is the entry node index where the BASIC subroutine or function starts
      (See @xref{scriba_Call()@} note on how to get the entry node value.)
@item @code{ReturnValue} is the return value of the function or subroutine
@item @code{cArgs} is the number of argments passed to the function
@item @code{Args} argument data array
@@end itemize
@subsection  scriba_LookupFunctionByName()

This function should be used to get the entry point of a function
knowing the name of the function. The entry point should not be treated as a
numerical value rather as a handle and to pass it to functions like
@xref{scriba_CallArgEx()@}.

@example
long scriba_LookupFunctionByName(pSbProgram pProgram,
                                 char *pszFunctionName
  )@@{
@end example
The return value of the function is the entry node index of the function named or
zero if the function is not present in the program.
@subsection  scriba_LookupVariableByName()

This function can be used to get the serial number of a global variable
knowing the name of the variable.

Note that all variables belong to a name space. Therefore if you want to
retrieve the global variable @code{foo} you have to name it @code{main::foo}.

@example
long scriba_LookupVariableByName(pSbProgram pProgram,
                                 char *pszVariableName
  )@@{
@end example
The return value is the serial number of the global avriable or zero if
there is no variable with that name.

Note that the second argument, the name of the global variable, is not
going under the usual name space manipulation. You have to specify the
variable name together with the name space. For example the variable @code{a} will
not be found, but the variable @code{main::a} will be.
@subsection  scriba_GetVariableType()

Get the type of the value that a variable is currently holding. This
value can be

@itemize
@item @code{SBT_UNDEF}
@item @code{SBT_DOUBLE}
@item @code{SBT_LONG}
@item @code{SBT_STRING}
@@end itemize

@example
long scriba_GetVariableType(pSbProgram pProgram,
                            long lSerial
  )@@{
@end example
The argument @code{lSerial} should be the serial number of 
the variable as returned by @xref{scriba_LookupVariableByName()@}.

If there is no variable for the specified serian mumber (@code{lSerial} is not positive
or larger than the number of variables) the function returns @code{SBT_UNDEF}.
@subsection  scriba_GetVariable()

This function retrieves the value of a variable.
A new @code{SbData} object is created and the pointer to it
is returned in @code{pVariable}. This memory space is automatically
reclaimed when the program object is destroyed or the function
@code{DestroySbData} can be called.

@example
int scriba_GetVariable(pSbProgram pProgram,
                       long lSerial,
                       pSbData *pVariable
  )@@{
@end example
The argument @code{lSerial} should be the serial number of the global variable
as returned by @xref{scriba_LookupVariableByName()@}.

The funtion returns @code{SCRIBA_ERROR_SUCCESS} on success,

@code{SCRIBA_ERROR_MEMORY_LOW} if the data cannot be created or

@code{SCRIBA_ERROR_FAIL} if the parameter @code{lSerial} is invalid.
@subsection  scriba_SetVariable()

This function sets the value of a global BASIC variable. You can call this function after
executing the program before it is reexecuted or after successfull call to @xref{scriba_NoRun()@}.

@example
int scriba_SetVariable(pSbProgram pProgram,
                       long lSerial,
                       int type,
                       long lSetValue,
                       double dSetValue,
                       char *pszSetValue,
                       unsigned long size
  )@@{
@end example
The argument @code{lSerial} should be the serial number of the global variable
as returned by @xref{scriba_LookupVariableByName()@}.

The argument @code{type} should be one of the followings:

@itemize
@item @code{SBT_UNDEF}
@item @code{SBT_DOUBLE}
@item @code{SBT_LONG}
@item @code{SBT_STRING}
@item @code{SBT_ZCHAR}
@@end itemize

The function uses one of the arguments @code{lSetValue}, @code{dSetValue} or @code{pszSetValue} and
the other two are ignored based on the value of the argument @code{type}.

If the value of the argument @code{type} is @code{SBT_UNDEF} all initialization arguments are ignored and the
global variable will get the value @code{undef}.

If the value of the argument @code{type} is @code{SBT_DOUBLE} the argument @code{dSetValue} will be used and the global
variable will be double holding the value.

If the value of the argument @code{type} is @code{SBT_LONG} the argument @code{lSetValue} will be used and the global
variable will be long holding the value.

If the value of the argument @code{type} is @code{SBT_STRING} the argument @code{pszSetValue} 
will be used and the global variable will be long holding the value. The length of the string
should in this case be specified by the variable @code{size}.

If the value of the argument @code{type} is @code{SBT_ZCHAR} the argument @code{pszSetValue} 
will be used and the global variable will be long holding the value. The length of the string
is automatically calculated and the value passed in the variable @code{size} is ignored. In this case the
string @code{pszSetValue} should be zero character terminated.

The funtion returns @code{SCRIBA_ERROR_SUCCESS} on success,

@code{SCRIBA_ERROR_MEMORY_LOW} if the data cannot be created or

@code{SCRIBA_ERROR_FAIL} if the parameter @code{lSerial} is invalid. 
@subsection  scriba_InitStaticModules()

This function calls the initialization functions of the modules that are statically linked
into the interpreter. This is essential to call this fucntion from the embedding @code{main()} program
in a variation that has one or more external modules staticallyl linked. If this function is not
called the module initialization will not be called, because the module is never actually loaded and
thus the operating system does not call the @code{DllMain} or @code{_init} function.

The function has to be called before the first interpreter thread starts. In case of a single
thread variation this means that the function has to be called before the BASIC program starts.

The function does not take any argument and does not return any value.

@example
void scriba_InitStaticModules(void
  )@@{
@end example
@subsection  scriba_FinishStaticModules()

This function calls the finalization functions of the modules that are statically linked
to the interpreter. Such a function for a dynamically loaded module is started by the operating
system. Because the sttaically linked modules are not loaded the @code{_fini} function is not called
by the UNIX loader and similarly the function @code{DllMain} is not called by Windows NT. Because some
modules depend on the execution of this function this function has to be called after the last
interpreter thread has finished.

@example
void scriba_FinishStaticModules(void
  )@@{
@end example
 


@chapter Extension Modules

Extension modules are written usually using the language C and implement functions that can not be efficiently implemented in BASIC. These functions can be called from the BASIC programs just as if they were written in BASIC.

@section How Extension Modules are Used

To write external modules it is a good practice to learn first how ScriptBasic uses the modules.

External functions and external commands in ScriptBasic are declared using the declare sub or declare command statements. An example of such a statement is

@example
declare sub alma alias "trial" lib "ext_tial"
@end example
or
@example
declare command iff alias "iff" lib "ext_tial"
@end example

Following this declaration the function or the command can be used just as it were implemented in BASIC.

@example
call alma(1,2,3)
@end example

The difference between external functions and external commands is the way ScriptBasic handles the arguments passed to them. Both external functions and external commands are implemented as C functions in the extension module compiled into a DLL or shareable object. Both of them look like user defined functions in the BASIC source code.

The difference is that external functions are called after the actual arguments are evaluated, while external commands are called without evaluating the arguments. Because of this external functions and external commands are implemented in C functions that have different prototypes. There is a prototype for external functions and a different one for external commands. 

When ScriptBasic compiles this line the function or subroutine @code{alma} is defined just as a normal function or subroutine defined using the instructions of the basic language. Note that there are no differences other than syntax between subroutines and functions in ScriptBasic. When the program calls the function @code{alma} the ScriptBasic run-time system performs a function call to the basic function alma. In other words there is no difference from the caller point of view between the line above and the line:
@example
Sub alma(a,b)
End sub
@end example

The function call can be performed in two different ways. One way is when the function appears in an expression. The other way is when the function is called using the @code{call} statement. There is no difference between the two calling possibilities from the internal operation point of view of the interpreter. This is because @code{CALL} statement is implemented in a very simple way to simply evaluate the expression after the call statement and drop the result. 

The calling code does not evaluate the expressions passed to the function as arguments. This is usually the task of the functions. The functions get the node pointer to the expression list where the actual values for the arguments are and they can evaluate them.

The two different declarations @code{declare sub} and @code{declare command} differ in the way ScriptBasic interpreter handles the arguments. When an external function is declared using the command @code{declare sub} the arguments are evaluated by the interpreter before the function implemented in the external module is called. When an external command is declared using the command @code{declare command} the arguments are @emph{NOT} evaluated by the ScriptBasic interpreter before calling the function implemented in the external module. In the latter case the external function has to decide if it wants certain arguments to be evaluated and can call the ScriptBasic function @code{execute_Evaluate} via the extension call-back table to evaluate the arguments. Also the prototype of a function declared using the statement @code{declare command} is different from the prototype of a function declared using the command @code{declare sub}.

When a function is implemented externally ScriptBasic sees a @code{declare sub} statement instead of a @code{function} or @code{sub} statement and starts to execute this statement calling the code implemented in the file @file{external.c} in the source directory @file{commands}.

The name of the example function is @code{alma} as declared in the statement above. However this is only a symbolic name that exists only during syntax analysis and is not available when the code is executed. The alias for the function is @code{trial}. This is the name of the function as it is implemented in the external module. When the interpreter executes this line the function name @code{trial} is used in the system call to locate the entry point. The module that contains the function is @code{ext_trial}. The actual file name is @file{ext_trial.dll} or @file{ext_trial.so} or some other name containing the given name and an extension specific to the operating system. During module load ScriptBasic automatically appends the appropriate extension as defined in the configuration file of ScriptBasic. (For further information on ScriptBasic configuration file syntax and location see the ScriptBasic Users' Guide!) ScriptBasic searches the module in the directories defined in the configuration file and tries to load it using absolute file name. This way the system specific search paths are not taken into account.

When function implemented in an external module is first called the interpreter checks if the module is loaded or not. If the module is not loaded the interpreter loads the module and calls module initialization functions. If the module was already loaded it locates the entry point of the function and calls the function.

During module load ScriptBasic appends the appropriate dynamic load library extension and tries to load the module from the directories defined in the configuration file. It takes the directories in the order they are specified in the configuration file and in case it can load the module from a directory listed it stops trying.


When the module is loaded ScriptBasic locates the function @code{versmodu} and calls it. The task of this function is to negotiate the interface version between the external module and ScriptBasic. The current interface version is defined in the file @file{basext.c} with the C macro @code{INTERFACE_VERSION}. ScriptBasic calls this function to tell the module what version ScriptBasic supports. The function can decide if the module can work with the indicated version and can answer: @emph{yes it is OK, no it is not OK or yes, but I can support only version X.} This is a negotiation process that finally result some agreement or the module is abandoned if no agreement can be reached.

The function @code{versmodu} gets three arguments:

@example
int versmodu(int Version, char *pszVariation, void **ppModuleInternal)
@end example

The first argument is the version of the interface. The second argument is the ZCHAR terminated 8-character string of the variation. This is STANDARD for the standard, stand alone, command line version of ScriptBasic. The @code{ppModuleInternal} pointer points to the module pointer initialized to @code{NULL}. This pointer is hardly ever used in this function, but its address is passed as a third argument in case some application needs it. The role of this pointer will be discussed later.

The function should check the parameters passed and return either zero in case it can not accept the interface or the highest interface it can handle. If this is the same as the version passed in the first argument the module should be accepted. If this is smaller than the interface version offered by ScriptBasic the interpreter can decide if it can support the older interface required by the module.

If the function @code{versmodu} returns a version larger than the version offered the interpreter will interpret this as a negotiation failure and will treat the module as not loaded.

If there is no function named @code{versmodu} in the library ScriptBasic crosses the fingers and hopes the best and assumes that the module will be able to work with the interface ScriptBasic offers. (should we change it to be configurable to disallow such modules?)

After the successful version negotiation the interpreter calls the function named @code{bootmodu}. This function gets four arguments.

@example

int bootmodu(pSupportTable pSt,
             void **ppModuleInternal, 
             pFixSizeMemoryObject pParameters,
             pFixSizeMemoryObject *pReturnValue)
@end example

The first parameter is a pointer to the interface structure. This interface structure can and should be used to communicate with ScriptBasic. The second parameter points to the module pointer. The last two parameters are NULL for this function. The reason to pass two NULL pointers is that this is the prototype of each function callable by ScriptBasic implemented in the module. The last two parameters point to the parameters of the function and to the left value where the function value is to be returned. @code{bootmodu} actually does not get any parameter and should not pass any value back.

This function can be used to initialize the module, to allocate memory for the common storage if the functions implemented in the module keep some state information. If there is no function named @code{bootmodu} in the library file ScriptBasic assumes that the module does not need initialization. If the function @code{bootmodu} exists it should return zero indicating success or an error code. If an error code is returned the module is treated as failed. And an error is raised. (Errors can be captured using the BASIC @code{ON ERROR GOTO} command.

When this function returns the ScriptBasic interpreter evaluates the arguments and performs a call to the function named trial in our example.

When the program has finished the interpreter tries to locate the function @code{finimodu} in the module. This function may exist and should have the same prototype as any other function (except @code{versmodu}):

@example
int finimodu(pSupportTable pSt,
             void **ppModuleInternal,
             pFixSizeMemoryObject pParameters,
             pFixSizeMemoryObject *pReturnValue)
@end example

This function can be used to perform clean-up tasks. The interpreter may call the @code{finimodu} functions of different modules in different threads asynchronously. (However it does not currently.)

Note that there is no need to release the allocated memory in case the module allocates memory using the memory allocation methods provided by the interface. Other resources may need release; for example files may need closing.


@section A Simple Sample Module

After you have got a slight overview how ScriptBasic handles the modules get a jump-start looking at the simplest sample module @code{trial.c}!

This module was the very first module the developers wrote to test the module handling functionality of ScriptBasic. This does almost nothing, but prints out some trace messages so that you can see how the different functions are called in the module. There is only one function in this module that the basic code can call. This is trial. This function increments a long value and returns the actual value of this state variable.

Here is the whole code:

@example
#include <stdio.h>

#include "../../basext.h"

besVERSION_NEGOTIATE

  printf("The function bootmodu was started and the requested version is %d\n",Version);
  printf("The variation is: %s\n",pszVariation);
  printf("We are returning accepted version %d\n",(int)INTERFACE_VERSION);

  return (int)INTERFACE_VERSION;

besEND

besSUB_START
  long *pL;

  besMODULEPOINTER = besALLOC(sizeof(long));
  if( besMODULEPOINTER == NULL )return 0;
  pL = (long *)besMODULEPOINTER;
  *pL = 0L;

  printf("The function bootmodu was started.\n");

besEND


besSUB_FINISH
  printf("The function finimodu was started.\n");
besEND

besFUNCTION(trial)

  long *pL;

  printf("Function trial was started...\n");
  pL = (long *)besMODULEPOINTER;
  (*pL)++;
  besRETURNVALUE = besNEWMORTALLONG;
  LONGVALUE(besRETURNVALUE) = *pL;

  printf("Module directory is %s\n",besCONFIG("module"));
  printf("dll extension is %s\n",besCONFIG("dll"));
  printf("include directory is %s\n",besCONFIG("include"));

besEND

besCOMMAND(iff)
  NODE nItem;
  VARIABLE Op1;
  long ConditionValue;


  USE_CALLER_MORTALS;

  /* evaluate the parameter */
  nItem = besPARAMETERLIST;
  if( ! nItem ){
    RESULT = NULL;
    RETURN;
    }
  Op1 = besEVALUATEEXPRESSION(CAR(nItem));
  ASSERTOKE;

  if( Op1 == NULL )ConditionValue = 0;
  else{
    Op1 = besCONVERT2LONG(Op1);
    ConditionValue = LONGVALUE(Op1);
    }

  if( ! ConditionValue )
    nItem = CDR(nItem);

  if( ! nItem ){
    RESULT = NULL;
    RETURN;
    }
  nItem = CDR(nItem);

  RESULT = besEVALUATEEXPRESSION(CAR(nItem));
  ASSERTOKE;
  
  RETURN;
besEND_COMMAND
@end example



As you can see there is a lot of code hidden behind the macros. You can not see @code{versmodu}, @code{bootmodu} or @code{finimodu}, because they are implemented using the macro @code{besVERSION_NEGOTIATE}, @code{besSUB_START} and @code{bes_SUB_FINISH}. These macros are provided in the header file @file{basext.h}, along with other type definitions and include statements that are needed to compile a module. To have a deeper understanding feel free to have a look at the file @file{basext.c} containing the source for @code{basext.h}.

All the macros defined in the header file for the extensions start with the three letters @code{bes}. These stand for @code{b}asic @code{e}xtension @code{s}upport.

The version negotiation function prototype and function start is created using the macro @code{besVERSION_NEGOTIATE}. This macro generates the function head with the parameters named @code{Version}, @code{pszVariation} and @code{ppModuleInternal}. The accepted version is returned using the macro @code{INTERFACE_VERSION}. The reason to use this macro is to ease maintainability.

The current version of the interface is 10 (or more). Later interfaces may probably support more callback interface functions, but it is unlikely that the interfaces become incompatible on the source level. When the module is recompiled in an environment that uses a newer interface it will automatically return the interface version that it really supports. If the interfaces become incompatible in source level the compilation phase will most probably fail.

The @code{bootmodu} function is created using the macro @code{besSUB_START}. In this example this allocates a state variable, which is a long. The memory allocation is performed using a callback function and with the aid of the macro @code{besALLOC}.

Here we can stop a bit and examine, how the callback functions work. The ScriptBasic interpreter has several functions that are available for the extensions. To access these functions the module should know the entry point (address) of the functions. To get the entry points ScriptBasic creates a table of the callback functions. A pointer to this table is passed as the first argument to each module function except the version negotiation function @code{versmodu}. In C syntax this table is a @code{struct} named @code{SupportTable}.

There are numerous functions that an extension can and should use to communicate with ScriptBasic. One of the most important functions is memory allocation. The field of the @code{SupportTable} named @code{Alloc} is initialized to point to the function @code{alloc_Alloc} defined in the file @file{myalloc.c}. This allocation function needs the size of the needed memory block and a pointer to a so-called memory segment. The memory segment pointer to be used is available via the @code{SupportTable}. The first member of the table is a pointer to another table containing the current interpreter execution environment. This environment is also a &code{struct} and contains the memory segment pointer.

This is a bit complicated and you can get confused. To ease coding use the macros available. These will hide all these nifty details. However know that these macros assume that you use them together. In other words @code{besALLOC} can only be used in a function when the function head was created using the macro @code{besFUNCTION} (or @code{besSUB_START} or @code{besSUB_FINISH} in case of @code{bootmodu} and @code{finimodu}). This is because the macros assume certain variable names in the arguments.

The function @code{finimodu} is created using the macro @code{besSUB_FINISH}. This function in this example does nothing but prints a test message. There is no need to release the memory allocated using @code{besALLOC}, because the memory is administered to belong to the segment of the interpreter execution environment and is released by the interpreter before the exits.

The real function of the module is named trial and is defined using the macro @code{besFUNCTION}. It gets the state variable via the module pointer. The module pointer is always passed to the module functions as the second argument. The functions can access it using the macro @code{besMODULEPOINTER}. Using this macro it looks like a local variable.


To return the counter value the function needs a basic variable. This variable should hold a long value and should be mortal. This is created using the macro @code{besNEWMORTALLONG}. The variable is actually a @code{struct} and the field containing the long value can be accessed using the macro @code{LONGVALUE}.



You can notice that this macro does not start with the letters @code{bes}. The reason is that this macro comes from a different header file @file{command.h}. This header file is included by @file{basext.h} and the definitions in that file are mainly for implementing internal commands linked statically. However some of the macros can be used for dynamic modules as well.

The function trial finally writes out some configuration data. On one hand this is another example of a callback function used via a macro named @code{besCONFIG}. But this is more important than that. This shows you that the modules can access any configuration data. 

There is no need for any module to process separate configuration files. ScriptBasic reads the configuration file and stores each key and value pair it finds. It stores even those that do not mean anything for ScriptBasic itself, because they may be meaningful and needed by modules. The example module trial does not have its own data, therefore we print out the configuration data that ScriptBasic surely has.

@section Compiling a Module

Compiling a module is easy and straightforward. Just do it as you would do for any dynamic load library. On Linux you have to compile the source code to object file, saying
@example
cc -c -o trial.o trial.c
ld -d -warn-section-align -sort-comon -shared -o trial.so trial.o
@end example
assuming that the name of the file to compile is @file{trial.c}. On other Unix operating systems you have to issue similar commands.

On Windows NT you can use Visual C++ and create an empty project using the work space wizard to create a new dll file. You have to add your source code to the project, select release version and compile the program.

Note that Windows NT dll files do not automatically export each non-static function of a program. They have to be declared in a DEF file or the functions should be denoted with a special type casting keyword. If you use the predefined macros available including the file @file{basext.h} your functions will be exported without creating a def file.

@section Installing a Module

A module is usually composed of two files. One file is the binary library module with the extension @code{.dll} under Windows NT or @code{.so} under Unix. The other file is an include file, which contains the declare sub statement for each external function.

To install a module you have to copy or move the module binary to one of the directories specified in the configuration file as ScriptBasic module directory and you have to copy or move the include file into one of the directories specified in the configuration file as ScriptBasic include directory.

The basic program that uses the module includes the include file and it is ready to call the functions declared in that file. Currently there are no install programs available that place the file at the appropriate locations.

@section Module Support Functions

Module support functions and macros are to ease the life of the extension programmers. They are defined in the file @file{basext.c} and in the file @file{basext.h} generated from @file{basext.c} using the tool @file{headerer.pl}.

It is highly recommended that the extensions use these functions and that the extensions use the macros to call the functions the way the documentation suggests. The reason for this is to create readable code and to provide maintainability.



@subsection  Basic Extension Support functions, structures and macros

@subsection  besALLOC(X)

Use this macro to allocate memory in an extension like you would use
@code{malloc} in a normal, old fashioned C program. The argument is the size of the memory in
byte count to be allocated. The result is the pointer to the allocated memory or @code{NULL} if there
is not enough memory available.

The allocated memory is assigned to the memory segment of the execution thread and thus this memory
is released automatically when the module is unloaded from the interpreter. In other words if
a module uses @code{besALLOC} to allocate memory there is no need to call @xref{besFREE(X)@}.

Modules written for multi-thread variations of ScriptBasic should also be aware of the fact that
the memory allocated by this macro is released whent he calling interpreter thread finishes.

This macro calls the function @xref{alloc_Alloc()@}

@subsection  besPROCALLOC(X)

Use this macro in multi-thread supporting modules to allocate memory that is
not freed when the actual interpreter finishes but stays in memory so long
as long the process is alive.


@subsection  besFREE(X)

Use this macro to release memory that was allocated by @xref{besALLOC(X)@}.

Altough all memory allocated by @xref{besALLOC()@} is automatically released when the
interpreter thread calling @xref{besALLOC()@} finishes it is advised to release all
memory chunks, especially large onces when they are not needed anymore.

This macro also @code{NULL}ifies the argument.

This macro calls the function @xref{alloc_Free()@}

@subsection  besPROCFREE(X)

This is the counterpart of @xref{besPROCALLOC@} releasing memory allocated
for process life time.

@subsection  besPROCMEMORYSEGMENT

Use this macro in case you need to pass the process level memory
segment to a function.

@subsection  besNEWMORTALSTRING(X)

Create a new mortal string and return a pointer to it. The argument should be the
number of characters in the string.
This macro calls the function @xref{memory_NewMortalString()@}.

See also 
@itemize
@item @xref{besNEWMORTALSTRING@}
@item @xref{besNEWMORTALLONG@}
@item @xref{besNEWMORTALREF@}
@item @xref{besNEWMORTALDOUBLE@}
@item @xref{besNEWMORTALARRAY@}
@@end itemize

@subsection  besNEWMORTALLONG

Create a new mortal @code{long} and return the pointer to it.
This macro calls the function @xref{memory_NewMortalLong()@}.

See also 
@itemize
@item @xref{besNEWMORTALSTRING@}
@item @xref{besNEWMORTALLONG@}
@item @xref{besNEWMORTALREF@}
@item @xref{besNEWMORTALDOUBLE@}
@item @xref{besNEWMORTALARRAY@}
@@end itemize

@subsection  besNEWMORTALREF

Create a new mortal reference and return the pointer to it.
This macro calls the function @xref{memory_NewMortalRef()@}.

See also 
@itemize
@item @xref{besNEWMORTALSTRING@}
@item @xref{besNEWMORTALLONG@}
@item @xref{besNEWMORTALREF@}
@item @xref{besNEWMORTALDOUBLE@}
@item @xref{besNEWMORTALARRAY@}
@@end itemize

@subsection  besNEWMORTALDOUBLE

Create a new mortal @code{double} and return the pointer to it.
This macro calls the function @xref{memory_NewMortalDouble()@}.

See also 
@itemize
@item @xref{besNEWMORTALSTRING@}
@item @xref{besNEWMORTALLONG@}
@item @xref{besNEWMORTALREF@}
@item @xref{besNEWMORTALDOUBLE@}
@item @xref{besNEWMORTALARRAY@}
@@end itemize

@subsection  besNEWMORTALARRAY(X,Y)

Create a new mortal array and return the pointer to it. The arguments define the array
low index and the array high index. This macro calls the function @xref{memory_NewMortalArray()@}.

See also 
@itemize
@item @xref{besNEWMORTALSTRING@}
@item @xref{besNEWMORTALLONG@}
@item @xref{besNEWMORTALREF@}
@item @xref{besNEWMORTALDOUBLE@}
@item @xref{besNEWMORTALARRAY@}
@@end itemize

@subsection  besNEWSTRING(X)

Create a new string and return the pointer to it. The argument defines the number
of bytes in the string. This macro calls the function @xref{memory_NewString()@}.

See also 
@itemize
@item @xref{besNEWSTRING@}
@item @xref{besNEWLONG@}
@item @xref{besNEWREF@}
@item @xref{besNEWDOUBLE@}
@item @xref{besNEWARRAY@}
@@end itemize

@subsection  besNEWLONG

Create a new @code{long} and return the pointer to it. This macro calls the function
@xref{memory_NewLong()@}.

See also 
@itemize
@item @xref{besNEWSTRING@}
@item @xref{besNEWLONG@}
@item @xref{besNEWREF@}
@item @xref{besNEWDOUBLE@}
@item @xref{besNEWARRAY@}
@@end itemize

@subsection  besNEWREF

Create a new reference variable and return the pointer to it. This macro calls the function
@xref{memory_NewRef()@}.

See also 
@itemize
@item @xref{besNEWSTRING@}
@item @xref{besNEWLONG@}
@item @xref{besNEWREF@}
@item @xref{besNEWDOUBLE@}
@item @xref{besNEWARRAY@}
@@end itemize

@subsection  besNEWDOUBLE

Create a new @code{double} and return the pointer to it. This macro calls the function
@xref{memory_NewDouble()@}.

See also 
@itemize
@item @xref{besNEWSTRING@}
@item @xref{besNEWLONG@}
@item @xref{besNEWREF@}
@item @xref{besNEWDOUBLE@}
@item @xref{besNEWARRAY@}
@@end itemize

@subsection  besNEWARRAY(X,Y)

Create a new array and return the pointer to it. The arguments define the array
low index and the array high index. This macro calls the function @xref{memory_NewArray()@}.

See also 
@itemize
@item @xref{besNEWSTRING@}
@item @xref{besNEWLONG@}
@item @xref{besNEWREF@}
@item @xref{besNEWDOUBLE@}
@item @xref{besNEWARRAY@}
@@end itemize

@subsection  besRELEASE(X)

Use this macro to release a non-mortal variable. This macro calls the function
@xref{memory_ReleaseVariable()@} with the appropriate memory segment arguments.

See also 
@itemize
@item @xref{besNEWSTRING@}
@item @xref{besNEWLONG@}
@item @xref{besNEWREF@}
@item @xref{besNEWDOUBLE@}
@item @xref{besNEWARRAY@}
@@end itemize

@subsection  besSETREF(VAR,VAL)

Use this macro in external modules to set the value of a variable to a reference to another variable.
The argument @code{VAR} is the variable and the argument @code{VAL} is the variable to be referenced.

@subsection  besCONFIG(X)

Get a configuration value that is supposed to be a string. This macro uses the
configuration of the callign interpreter thread and it calls the function
@xref{cft_GetString@}.

@subsection  besCONFIGFINDNODE(X,Y,Z)
This macro calls the function @xref{cft_FindNode@}. Use this macro for sophisticated
configuration handling that needs configuration key enumeration.

@subsection  besCONFIGEX(CT,CS,NS,CSS,LS,DS,IS)

This macro calls the function @xref{cft_GetEx@}. Use this macro to retrieve
configuration information that is not a string or the type is not known.

@subsection  besCONFIGENUMFIRST(X,Y)

This macro calls the function @xref{cft_EnumFirst@}.

@subsection  besCONFIGENUMNEXT(X,Y)

This macro calls the function @xref{cft_EnumNext@}.

@subsection  besCONFIGGETKEY(X,Y)

This macro calls the function @xref{cft_GetKey@}.

@subsection  besNEWSYMBOLTABLE

This macro allocates a new symbol table and returns the handle pointer to it. This
macro calls the function @xref{sym_NewSymbolTable@}. The allocation function and the memory
segment used to allocate the symbol table is the default one that is used by the interpreter.

@subsection  besFREESYMBOLTABLE(X)

This macro releases a symbol table calling the function @xref{sym_FreeSymbolTable@}.
The allocation function and the memory segment used to allocate the symbol table
is the default one that is used by the interpreter.

@subsection  besTRAVERSESYMBOLTABLE(X,Y,Z)

This macro calls the function @xref{sym_TraverseSymbolTable@}.

@subsection  besLOOKUPSYMBOL(X,Y,Z)

This macro calls the function @xref{sym_LookupSymbol@}.

@subsection  besDeleteSymbol(X,Y,Z)

This macro calls the function @xref{sym_DeleteSymbol@}.

@subsection  besLOADLIBRARY(X)

This macro calls the function @xref{dynlolib_LoadLibrary()@}.

@subsection  besFREELIBRARY(X)

This macro calls the function @xref{dynlolib_FreeLibrary()@}.

@subsection  besGETFUNCTIONBYNAME(X)

This macro calls the function @xref{dynlolib_GetFunctionByName()@}.

@subsection  besFOPEN

This macro calls the function @xref{file_fopen@}.

@subsection  besFCLOSE

This macro calls the function @xref{file_fclose@}.

@subsection  besSIZE

This macro calls the function @xref{file_size@}.

@subsection  besTIME_ACCESSED

This macro calls the function @xref{file_time_accessed@}.

@subsection  besTIME_MODIFIED

This macro calls the function @xref{file_time_modified@}.

@subsection  besTIME_CREATED

This macro calls the function @xref{file_time_created@}.

@subsection  besISDIR

This macro calls the function @xref{file_isdir@}.

@subsection  besISREG

This macro calls the function @xref{file_isreg@}.

@subsection  besEXISTS

This macro calls the function @xref{file_fileexists@}.

@subsection  besTRUNCATE

This macro calls the function @xref{file_truncate@}.

@subsection  besFGETC

This macro calls the function @xref{file_fgetc@}.

@subsection  besFREAD

This macro calls the function @xref{file_fread@}.

@subsection  besFWRITE

This macro calls the function @xref{file_fwrite@}.

@subsection  besSETMODE

This macro calls the function @xref{file_setmode@}.

@subsection  besBINMODE

This macro calls the function @xref{file_binmode@}.

@subsection  besTEXTMODE

This macro calls the function @xref{file_textmode@}.

@subsection  besFERROR

This macro calls the function @xref{file_ferror@}.

@subsection  besFPUTC

This macro calls the function @xref{file_fputc@}.

@subsection  besFLOCK

This macro calls the function @xref{file_flock@}.

@subsection  besLOCK

This macro calls the function @xref{file_lock@}.

@subsection  besFEOF

This macro calls the function @xref{file_feof@}.

@subsection  besMKDIR

This macro calls the function @xref{file_mkdir@}.

@subsection  besRMDIR

This macro calls the function @xref{file_rmdir@}.

@subsection  besREMOVE

This macro calls the function @xref{file_remove@}.

@subsection  besDELTREE

This macro calls the function @xref{file_deltree@}.

@subsection  besMAKEDIRECTORY

This macro calls the function @xref{file_MakeDirectory@}.

@subsection  besOPENDIR

This macro calls the function @xref{file_opendir@}.

@subsection  besREADDIR

This macro calls the function @xref{file_readdir@}.

@subsection  besCLOSEDIR

This macro calls the function @xref{file_closedir@}.

@subsection  besOPTION(X)
Get the @code{long} value of the option @code{X}. This macro calls the function
@xref{options_Get@}. The macro uses the default execution context.

@subsection  besSETOPTION(x,y)
Set the @code{y} @code{long} value of the option @code{x}. This macro calls the function
@xref{options_Set@}. The macro uses the default execution context.

@subsection  besRESETOPTION(X)
Reset the option @code{X}. This macro calls the function @xref{options_Reset@}.
The macro uses the default execution context.

@subsection  besCONVERT2STRING(x)

Use this macro to convert a mortal @code{VARIABLE} to string. The macro calls the
function @xref{execute_Convert2String@} and uses the global mortal list.

@subsection  besCONVERT2LONG(x)
Use this macro to convert a mortal @code{VARIABLE} to @code{long}. The macro calls the
function @xref{execute_Convert2Long@} and uses the global mortal list.

@subsection  besGETLONGVALUE(x)
Use this macro to get the long value of a variable. This macro is not the same as @code{LONGVALUE}.
The macro @code{LONGVALUE} simply accesses the long value of a variable and thus can also be used
as a left value assigning value to. On the other hand @code{besGETLONGVALUE} is a function call that
returns a long value when the argumentum variable is @code{NULL}, @code{double}, string or some other value.
In such situation using @code{LONGVALUE} would be erroneous.

The macro @code{LONGVALUE} should be used to access the long value of a variable that is known to
hold a long value or when the long value of a variable is to be set.

The macro @code{besGETLONGVALUE} has to be used in a situation when we want to use a variable
for its value being long. It is faster and consumes less memory than converting the variable to
long allocating a new mortal just to access the long value of the new mortal using @code{LONGVALUE}.

The same statements hold for @code{DOUBLEVALUE} and @xref{besGETDOUBLEVALUE@}.

@subsection  besCONVERT2DOUBLE(x)
Use this macro to convert a mortal @code{VARIABLE} to @code{double}. The macro calls the
function @xref{execute_Convert2Double@} and uses the global mortal list.


@subsection  besGETDOUBLEVALUE(x)
Use this macro to get the double value of a variable.

For comparision of @code{DOUBLEVALUE} and this macro see the explanation in @xref{besGETLONGVALUE@}.


@subsection  besISSTRINGINTEGER(x)

Use this macro to decide if a string contains caharacters copnvertible to an
integer value. This macro calls the function @xref{execute_IsStringInteger@}.

@subsection  besCONVERT2ZCHAR(x)

Use this macro to convert a @code{VARIABLE} that is already STRING type to zero character
terminated string. This is needed many times when a BASIC string has to be passed to
operating system functions.

The macro argument @code{x} is converted to zero character terminated string and the
result will be pointed by @code{y}. @code{y} has to be a @code{(char *)} C variable.

If there is not enough memory the macro returns from the function with the error code
@code{COMMAND_ERROR_MEMORY_LOW} thus there is no need to check the value of the variable @code{y}
if it is @code{NULL}.

The memory allocated to store the ZCHAR string should be released by the macro @xref{besFREE@}.

Note that the macro does not check wheter the string already contains a zero character or not.
It simply allocates a buffer that has length n+1 bytes to store the n bytes of the original
BASIC string and an extra zero character.

@subsection  besREINITINTERFACE

This macro calls the function @xref{modu_Init@} to reset the module interface to
point to the original functions.

External modules are allowed to alter the support function table implementing their
own functions and thus altering the behavior of other extensions. These extensions
usually set some of the entries of the support function table to point to functions
implemented in the external module. However these functions are available only so long
as long the extension is in memory. When the extension is exiting the pointers should
be restored. Otherwise it may happen that the extension is already unloaded and the function
is used by another module exiting later.

Because there is no guaranteed order of extension module unload the modules should call
this function to restore the support function table and should not rely on altered
function calls during module exit code is executed.


@subsection  besLOADMODULE(x,y)

This macro calls the function @xref{modu_LoadModule@}. The execution
environment (@code{ExecuteObject}) used by the macro while calling the
function is the default execution environment.

@subsection  besGETMODULEFUNCTIONBYNAME

This macro calls the function @xref{modu_GetFunctionByName@}. The execution
environment (@code{ExecuteObject}) used by the macro while calling the
function is the default execution environment.

@subsection  besUNLOADALLMODULES

This macro calls the function @xref{modu_UnloadAllModules@}. This will unload all modules that are
not active. Because this macro is called by an extension that is a module itself the calling module
will not be unloaded.

A module is active if there is a function called in the module and the module did not return from the
function call yet. Typically there can be only one active module at a time unless some
modules call each other in tricky ways through the ScriptBasic module calling functions. Therefore
calling this macro practically unloads all modules but the very one using this macro.

See also @xref{besUNLOADMODULE@}.

@subsection  besUNLOADMODULE(x)

This macro calls the function @xref{modu_UnloadModule@} to unload the named
module. Note that the module name @code{x} should be the same
string that was used to load the module and it can not be the actual module or
any other module that is active.

See also @xref{besUNLOADALLMODULES@}.

@subsection  besSLEEP(x)

This macro calls @xref{file_sleep@} to sleep @code{x} number of seconds.

@subsection  besCURDIR(x,y)

This function calls @xref{file_curdir@} to get the current working directory.

@subsection  besCHDIR(x)

This function calls @xref{file_chdir@} to set the current working directory.
Be careful changing the working directory because it may prevent the extension
module being used in multi-thread variation of ScriptBasic.

@subsection  besCHOWN(x,y)

This macro calls the function @xref{file_chown@}.

@subsection  besSETCREATETIME(x,y)

This macro calls the function @xref{file_SetCreateTime@}.

@subsection  besSETMODIFYTIME(x,y)

This macro calls the function @xref{file_SetModifyTime@}.

@subsection  besSETACCESSTIME(x,y)

This macro calls the function @xref{file_SetAccessTime@}.

@subsection  besGETHOSTNAME(x,y)

This macro calls the function @xref{file_GetHostName@}.

@subsection  besGETHOST(x,y)

This macro calls the function @xref{file_GetHost@}.

@subsection  besTCPCONNECT(x,y)

This macro calls the function @xref{file_TcpConnect@}.

@subsection  besTCPSEND(x,y,z)

This macro calls the function @xref{file_TcpSend@}.

@subsection  besTCPRECV(x,y,z)

This macro calls the function @xref{file_TcpRecv@}.

@subsection  besTCPCLOSE(y)

This macro calls the function @xref{file_TcpClose@}.

@subsection  besKILLPROC(x)

This macro calls the function @xref{file_KillProc@}.

@subsection  besGETOWNER(x,y,z)

This macro calls the function @xref{file_GetOwner@}.

@subsection  besCRYPT(x,y,z)

This macro calls the function @xref{file_fcrypt@}.

@subsection  besMD5INIT(C)

This macro calls the function @code{MD5Init}.

@subsection  besMD5UPDATE(C,I,L)

This macro calls the function @code{MD5Update}.

@subsection  besMD5FINAL(D,C)

This macro calls the function @code{MD5Final}.

@subsection  besCREATEPROCESS(X)

This macro calls the function @xref{file_CreateProcess@}.

@subsection  besCOPYCOMMANDTABLE(X)

This macro calls the function @xref{execute_CopyCommandTable@}.

@subsection  besGETCOMMANDBYNAME(X,Y)

This macro calls the function @xref{execute_GetCommandByName@}.

@subsection  besEVALUATEEXPRESSION(X)

This macro evaluates an expression and returns the result @code{VARIABLE}.
This should usually be used only in extension @xref{besCOMMAND@} commands
and not in @xref{besFUNCTION@}. The result is duplicated and mortalized
and therefore the command is free to modify the
@code{VARIABLE}. 


@subsection  _besEVALUATEEXPRESSION(X)

This macro evaluates an expression and returns the result @code{VARIABLE}.
This should usually be used only in extension @xref{besCOMMAND@} commands
and not in @xref{besFUNCTION@}. The result is @b{NOT} duplicated and @b{NOT}
mortalized and therefore the command modifying the @code{VARIABLE} may happen
to modify a BASIC variable.

This should not be done! There are other ways to modify the value of a
variable.

@subsection  _besEVALUATEEXPRESSION_A(X)

This macro evaluates an expression and returns the result @code{VARIABLE}.
This macro is the same as @xref{_besEVALUATEEXPRESSION@} except that this
macro may result a whole array.

@subsection  besEVALUATELEFTVALUE(X)

This macro evaluates a left value. This left-value is a pointer to a @code{VARIABLE}.
If this is not @code{NULL} it has to be released first using the macro @xref{besRELEASE@}
and a new immortal value may be assigned to it afterwards.

@subsection  besEVALUATELEFTVALUE_A(X)

This macro evaluates a left value. This macro is the same as @xref{besEVALUATELEFTVALUE@}
except that this macro may result a whole array.

@subsection  besIMMORTALIZE(x)

This macro calls the function @xref{memory_Immortalize()@}. Use this macro
to immortalize a mortal variable before assigning it to a BASIC variable.


@subsection  besDEREFERENCE(X)

This macro calls @xref{execute_DereferenceS@}. 


@subsection  besMatchIndex(X)

This macro calls @xref{match_index@}.

@subsection  besMatchIniSets(X)

This macro calls @xref{match_InitSets@}.

@subsection  besMatchModifySet(X,Y,Z,W,Q)

This macro calls @xref{match_ModifySet@}.

@subsection  besMatchMatch(P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12)

This macro calls @xref{match_match@}.

@subsection  besMatchCount(X,Y)

This macro calls @xref{match_count@}.

@subsection  besMatchParameter(P1,P2,P3,P4,P5,P6,P7)

This macro calls @xref{match_parameter@}.

@subsection  besMatchSize(P1,P2,P3,P4,P5)

This macro calls @xref{match_size()@}.

@subsection  besCreateThread(X,Y,Z)

This macro calls @xref{thread_CreateThread@}.

@subsection  besExitThread

This macro calls @xref{thread_ExitThread@}.

@subsection  besInitMutex(X)

This macro calls @xref{thread_InitMutex@}.

@subsection  besFinishMutex(X)

This macro calls @xref{thread_FinishMutex@}.

@subsection  besLockMutex(X)

This macro calls @xref{thread_LockMutex@}.

@subsection  besUnlockMutex(X)

This macro calls @xref{thread_UnlockMutex@}.

@subsection  besInitSharedLock(X)

This macro calls @xref{thread_InitLock@}.

@subsection  besFinishSharedLock(X)

This macro calls @xref{thread_FinishLock@}.

@subsection  besLockSharedRead(X)

This macro calls @xref{thread_LockRead@}.

@subsection  besLockSharedWrite(X)

This macro calls @xref{thread_LockWrite@}.

@subsection  besUnlockSharedRead(X)

This macro calls @xref{thread_UnlockRead@}.

@subsection  besUnlockSharedWrite(X)

This macro calls @xref{thread_UnlockWrite@}.

@subsection  besScribaNew(F0,F1)

This macro calls @xref{scriba_new@}

@subsection  besScribaDestroy(F0)

This macro calls @xref{scriba_destroy@}

@subsection  besScribaNewSbData(F0)

This macro calls @xref{scriba_NewSbData@}

@subsection  besScribaNewSbLong(F0,F1)

This macro calls @xref{scriba_NewSbLong@}

@subsection  besScribaNewSbDouble(F0,F1)

This macro calls @xref{scriba_NewSbDouble@}

@subsection  besScribaNewSbUndef(F0)

This macro calls @xref{scriba_NewSbUndef@}

@subsection  besScribaNewSbString(F0,F1)

This macro calls @xref{scriba_NewSbString@}

@subsection  besScribaNewSbBytes(F0,F1,F2)

This macro calls @xref{scriba_NewSbBytes@}

@subsection  besScribaDestroySbData(F0,F1)

This macro calls @xref{scriba_DestroySbData@}

@subsection  besScribaPurgeReaderMemory(F0)

This macro calls @xref{scriba_PurgeReaderMemory@}

@subsection  besScribaPurgeLexerMemory(F0)

This macro calls @xref{scriba_PurgeLexerMemory@}

@subsection  besScribaPurgeSyntaxerMemory(F0)

This macro calls @xref{scriba_PurgeSyntaxerMemory@}

@subsection  besScribaPurgeBuilderMemory(F0)

This macro calls @xref{scriba_PurgeBuilderMemory@}

@subsection  besScribaPurgeExecuteMemory(F0)

This macro calls @xref{scriba_PurgeExecuteMemory@}

@subsection  besScribaSetFileName(F0,F1)

This macro calls @xref{scriba_SetFileName@}

@subsection  besScribaLoadConfiguration(F0,F1)

This macro calls @xref{scriba_LoadConfiguration@}

@subsection  besScribaInheritConfiguration(F0,F1)

This macro calls @xref{scriba_InheritConfiguration@}

@subsection  besScribaSetCgiFlag(F0)

This macro calls @xref{scriba_SetCgiFlag@}

@subsection  besScribaSetReportFunction(F0,F1)

This macro calls @xref{scriba_SetReportFunction@}

@subsection  besScribaSetReportPointer(F0,F1)

This macro calls @xref{scriba_SetReportPointer@}

@subsection  besScribaSetStdin(F0,F1)

This macro calls @xref{scriba_SetStdin@}

@subsection  besScribaSetStdout(F0,F1)

This macro calls @xref{scriba_SetStdout@}

@subsection  besScribaSetEmbedPointer(F0,F1)

This macro calls @xref{scriba_SetEmbedPointer@}

@subsection  besScribaSetEnvironment(F0,F1)

This macro calls @xref{scriba_SetEnvironment@}

@subsection  besScribaLoadBinaryProgram(F0)

This macro calls @xref{scriba_LoadBinaryProgram@}

@subsection  besScribaInheritBinaryProgram(F0,F1)

This macro calls @xref{scriba_InheritBinaryProgram@}

@subsection  besScribaReadSource(F0)

This macro calls @xref{scriba_ReadSource@}

@subsection  besScribaDoLexicalAnalysis(F0)

This macro calls @xref{scriba_DoLexicalAnalysis@}

@subsection  besScribaDoSyntaxAnalysis(F0)

This macro calls @xref{scriba_DoSyntaxAnalysis@}

@subsection  besScribaBuildCode(F0)

This macro calls @xref{scriba_BuildCode@}

@subsection  besScribaIsFileBinaryFormat(F0)

This macro calls @xref{scriba_IsFileBinaryFormat@}

@subsection  besScribaGetCacheFileName(F0)

This macro calls @xref{scriba_GetCacheFileName@}

@subsection  besScribaUseCacheFile(F0)

This macro calls @xref{scriba_UseCacheFile@}

@subsection  besScribaSaveCacheFile(F0)

This macro calls @xref{scriba_SaveCacheFile@}

@subsection  besScribaRunExternalPreprocessor(F0,F1)

This macro calls @xref{scriba_RunExternalPreprocessor@}

@subsection  besScribaSaveCode(F0,F1)

This macro calls @xref{scriba_SaveCode@}

@subsection  besScribaSaveCCode(F0,F1)

This macro calls @xref{scriba_SaveCCode@}

@subsection  besScribaLoadSourceProgram(F0)

This macro calls @xref{scriba_LoadSourceProgram@}

@subsection  besScribaRun(F0,F1)

This macro calls @xref{scriba_Run@}

@subsection  besScribaNoRun(F0)

This macro calls @xref{scriba_NoRun@}

@subsection  besScribaResetVariables(F0)

This macro calls @xref{scriba_ResetVariables@}

@subsection  besScribaCall(F0,F1)

This macro calls @xref{scriba_Call@}

@subsection  besScribaCallArg(F0,F1,F2,F3)

This macro calls @xref{scriba_CallArg@}

@subsection  besScribaDestroySbArgs(F0,F1,F2)

This macro calls @xref{scriba_DestroySbArgs@}

@subsection  besScribaNewSbArgs(F0,F1,F2)

This macro calls @xref{scriba_NewSbArgs@}

@subsection  besScribaCallArgEx(F0,F1,F2,F3,F4)

This macro calls @xref{scriba_CallArgEx@}

@subsection  besScribaLookupFunctionByName(F0,F1)

This macro calls @xref{scriba_LookupFunctionByName@}

@subsection  besScribaLookupVariableByName(F0,F1)

This macro calls @xref{scriba_LookupVariableByName@}

@subsection  besScribaGetVariableType(F0,F1)

This macro calls @xref{scriba_GetVariableType@}

@subsection  besScribaGetVariable(F0,F1,F2)

This macro calls @xref{scriba_GetVariable@}

@subsection  besScribaSetVariable(F0,F1,F2,F3,F4,F5,F6)

This macro calls @xref{scriba_SetVariable@}

@subsection  besLogState(X)

This macro calls @xref{log_state@}

@subsection  besLogInit(F0,F1,F2,F3,F4,F5)

This macro calls @xref{log_init@}

@subsection  besLogPrintf(pLOG,FORMAT, ...)

This macro calls @xref{log_printf@}

@subsection  besLogShutdown(pLOG)

This macro calls @xref{log_shutdown@}

@subsection  besHandleGetHandle(X,Y)

This macro calls @xref{handle_GetHandle@}. The memory segment used by the
macro is the default.

Example:

@example
  void *H;
  int i;
    ....
  i = besHandleGetPointer(H,pointer);
@end example


@subsection  besHandleGetPointer(X,Y)

This macro calls @xref{handle_GetPointer@}. The memory segment used by the
macro is the default.

Example:

@example
  void *H,*pointer;
    ....
  pointer = besHandleGetPointer(H,handle);
@end example


@subsection  besHandleFreeHandle(X,Y)

This macro calls @xref{handle_FreeHandle@}

@subsection  besHandleDestroyHandleArray(X)

This macro calls @xref{handle_DestroyHandleArray@}


Use this macro to declare and process the arguments of a besFUNCTION. The
macro should be placed right after the variable declaration and before
any other code, because it declares the variable @code{iError}.

The macro calls the function @xref{basext_GetArgsF@} and returns with error in case
some error has happened during the parsing of the arguments.

Example:

@example
besARGUMENTS("llzz")
&my_first_long , &my_second_long, &my_string1 , &my_string2
besARGEND
@end example

@subsection  besINIT_SEGMENT(MAF,MRF)
This macro calls the function @xref{alloc_InitSegment@}

@subsection  besSEGMENT_LIMIT(PMS,L)
This macro calls the function @xref{alloc_SegmentLimit@}

@subsection  besFREE_SEGMENT(PMS)
This macro calls the function @xref{alloc_FreeSegment@}

@subsection  besFINISH_SEGMENT(PMS)
This macro calls the function @xref{alloc_FinishSegment@}

@subsection  besFUNCTION(X)

Use this macro to start an extension module interface function. The macro argument @code{X}
is the name of the function as it is used in the BASIC statement

@example
declare sub ::Function alias "X" lib "module"
@end example

This macro handles all system dependant function decoration declarations and
declares the argument variables. Altough it is possible to name the argument
variables in a different way it is strongly recommended that the programmer
writing external module uses this macro and thus uses the argument names, because
the @code{besXXX} macros rely on these variable names.

@subsection  besASSERT_FUNCTION

Use this macro to check inside a besFUNCTION that the function was called
as a sub and not command. If the include file declares the function as

@example
declare command XXX alias "xxx" lib "library"
@end example

instead of

@example
declare sub XXX alias "xxx" lib "library"
@end example

then you can not execute the rest of the code safely. This macro returns
with the error code @code{COMMAND_ERROR_BAD_CALL} if the function was
declared the wrong way.

@subsection  besCOMMAND(X)

Use this macro to start an extension module interface command. The macro argument @code{X}
is the name of the command as it is used in the BASIC statement

@example
declare command ::Function alias "X" lib "module"
@end example

This macro handles all system dependant function decoration declarations and
declares the argument variables. Altough it is possible to name the argument
variables in a different way it is strongly recommended that the programmer
writing external module uses this macro and thus uses the argument names, because
the @code{besXXX} macros rely on these variable names.

In addition to the arguments this macro also declares some mandatory local variables
thatshould be used in most of the module implemented commands and are used by some
macros.

Note that interface functions get their arguments already evaluated while interface
commands may decide if an argument is evaluated or not, or even evaluated multiple
times.

@subsection  besASSERT_COMMAND

Use this macro to check inside a besCOMMAND that the command was called
as a command. If the include file declares the function as

@example
declare sub XXX alias "xxx" lib "library"
@end example

instead of

@example
declare command XXX alias "xxx" lib "library"
@end example

then you can not execute the rest of the code safely. This macro returns
with the error code @code{COMMAND_ERROR_BAD_CALL} if the function was
declared the wrong way.


@subsection  besEND_COMMAND

Use this macro to finish an extension module command.

Note that this macro uses the macro @code{FINISH} that is empty by default. However a command
may decide to perform some action after the mortals are released. To do so the macro
@code{FINISH} can be redefined.

@subsection  besARGNR

This macro returns the number of arguments passed to the extension module interface function.

@subsection  besARGUMENT(X)
To access the function arguments the module can use the macro. The argument is the
ordinal number of the argument starting from 1. You can overindex the arguments. In
that case the macro value is @code{NULL}.

Note that this macro can only be used in interface functions and not in interface commands.

@subsection  besPARAMETERLIST

Get the ordinal number of the node, where the parameter list starts for the
extenal module interface command. This macro should not be used in interface
functions only in interface commands.

@subsection  besLEFTVALUE(X,Y)

Use this macro to evaluate an argument as left value in an interface command.
This macro should not be used in interface functions.

@subsection  besVERSION_NEGOTIATE

Use this macro to start the module interface version negotiation function. The simplest
example is:

@example
besVERSION_NEGOTIATE
  return (int)INTERFACE_VERSION;
besEND
@end example

@subsection  besSUB_START

Use this macro to start the module initialization function.

@example
besSUB_START
  ....
besEND
@end example

@subsection  besSUB_FINISH

Use this macro to start the module finalization function.

@example
besSUB_FINISH
  ....
besEND
@end example

@subsection  besSUB_ERRMSG
Use this macro to start the error message function of an external module.

@example
besSUB_ERRMSG
  ....
besEND
@end example

@subsection  besSUB_PROCESS_START

Use this macro to start the function that will be invoked when the module is loaded by the
operating system. This is @code{_init} under UNIX and @code{DllMain} under Windows NT. Using this
macro the programmer can hide the OS dependant code.

@subsection  besSUB_PROCESS_FINISH

Use this macro to start the function that will be invoked when the module is unloaded by the
operating system. This is @code{_fini} under UNIX and @code{DllMain} under Windows NT. Using this
macro the programmer can hide the OS dependant code.

@subsection  besSUB_KEEP

Use this macro to start the module kepper function. This function should return 1 when the
module wants to remain in memory and 0 when the module can be unloaded.

@subsection  besSUB_SHUTDOWN

Use this macro to start a module shutdown function.

This shutdown function is called before a module is unloaded from the process 
space. The function is similar to @xref{besSUB_FINISH@}. That function is called when
the interpreter finishes. When there are many interpreter threads in a single process
that uses the module the function @xref{besSUB_FINISH@} is called each time an
interpreter finishes. The function @xref{besSUB_SHUTDOWN@} is called only once, before the
interpreter unloads the extesion from memory.

The difference between @code{besSUB_SHUTDOWN} and @xref{besSUB_PROCESS_FINISH@} is that @code{besSUB_SHUTDOWN}
is called by the interpreter, @xref{besSUB_PROCESS_FINISH@} is called by the operating system.
@code{besSUB_SHUTDOWN} can access the support functions because it gets the @code{pSt} argument,
@xref{besSUB_PROCESS_FINISH@} can not access these functions.

When a single thread interpreter finishes it first calls the function @xref{besSUB_FINISH@} to unload
the module and after that it calls @code{besSUB_SHUTDOWN}.

This is not an error if a module does not implement these functions.

The function should return @code{COMMAND_ERROR_SUCCESS} if the module has no remaining activity and
is ready to be unloaded.

The function should return @code{COMMAND_ERROR_STAYS_IN_MEMORY} if there are unstopped threads
that use the module code. In this case unloading the module would cause segmentation
fault that would interfere with the still running shutdown procedures. In that case the module
is not unloaded by the program, but only when the process finishes by the operating system.

@subsection  besSUB_AUTO

Use this macro to start the external module autoloader function.


@subsection  besEND

Use this macro to close an extension module interface function.

@subsection  besRETURNVALUE
Use this macro to access the extension function or command return value pointer. Assign allocated
mortal variable to this pointer.

@subsection  besMODULEPOINTER
Use this macro to access the extension module pointer.

@subsection  besALLOC_RETURN_STRING(X)

Use this macro to allocate a string as a return value. If there is not enough space to store the
result the macro returns from the function with the error code @code{COMMAND_ERROR_MEMORY_LOW}.

The argument should be the number of bytes of the return value. After using this macro the
macro @code{STRINGVALUE(besRETURNVALUE)} can be used to access the byte-buffer of the return
value. Usually the program uses @code{memcpy} to copy the bytes there.

@subsection  besALLOC_RETURN_POINTER

Use this macro to allocate a string as a return value to return a pointer. If there is not enough space to store the
result the macro returns from the function with the error code @code{COMMAND_ERROR_MEMORY_LOW}.

After using this macro the macro @code{STRINGVALUE(besRETURNVALUE)} can be used to access the byte-buffer of the return
value. Usually the program uses @code{memcpy} to copy the bytes there.

@subsection  besALLOC_RETURN_LONG

Use this macro to allocate a @code{long} as a return value. If there is not enough space to store the
result the macro returns from the function with the error code @code{COMMAND_ERROR_MEMORY_LOW}.

After using this macro the
macro @code{LONGVALUE(besRETURNVALUE)} can be used to access the long value of the return
value.

@subsection  besALLOC_RETURN_DOUBLE

Use this macro to allocate a @code{double} as a return value. If there is not enough space to store the
result the macro returns from the function with the error code @code{COMMAND_ERROR_MEMORY_LOW}.

After using this macro the
macro @code{DOUBLEVALUE(besRETURNVALUE)} can be used to access the double value of the return
value.

@subsection  besRETURN_STRING(X)

Use this program to return a string value. The argument of the macro should be a zero terminated
string. 

The macro allocates the return string, copies the content of the string to the allocated space and
returns from the function using the macro with no error (COMMAND_ERROR_SUCCESS).

If the return value can not be allocated the macro returns with COMMAND_ERROR_MEMORY_LOW.

If the argument is @code{NULL} the macro will return the BASIC value @code{undef}.

The macro evaluates its argument twice.

@subsection  besSET_RETURN_STRING(X)

Use this program to return a string value. The argument of the macro should be a zero terminated
string. 

The macro allocates the return string, copies the content of the string to the allocated space.
This macro does NOT return from the function that uses it. It allows the function to execute
some extra code before returning from the function, for example to release the string
variable passed as argument to this macro.

If the return value can not be allocated the macro returns with COMMAND_ERROR_MEMORY_LOW.

If the argument is @code{NULL} the macro will set the return value to be @code{NULL} (BASIC value @code{undef}).

The macro evaluates its argument twice.

@subsection  besRETURN_MEM(X,Y)

Use this program to return a binary string value. The arguments of the macro should be a pointer
to the binary string and the @code{long} length of the binary string. 

The macro allocates the return string, copies the content of the string to the allocated space and
returns from the function using the macro with no error (COMMAND_ERROR_SUCCESS).

If the return value can not be allocated the macro returns with COMMAND_ERROR_MEMORY_LOW.

The macro evaluates its argument twice.

@subsection  besRETURN_POINTER(X)

Use this macro to return a pointer. The argument of the macro should be the pointer to return. The
BASIC program will see this value as a string of four (32 bit machines) or eight (64bit machines)
characters. The BASIC program should not alter the value but pass it back to the module wherever
the program needs. In other words the program should treat the value as an abstract handle
and not try to manipulate it.

The macro allocates the return string, copies the pointer into the string and returns from the function
using the macro with no error (COMMAND_ERROR_SUCCESS).

If the return value can not be allocated the macro returns with COMMAND_ERROR_MEMORY_LOW.

If the pointer is @code{NULL} the function will return the BASIC value @code{undef}. This way you can not pass a
@code{NULL} pointer back to the BASIC program stored as four (or eight) zero characters in a string. On the other
hand this is usually not what you really want and the BASIC program can check @code{undef}indeness of the value.
When @code{undef} is passed back to the module the argument handling functions convert it back to @code{NULL}.

@subsection  besRETURN_LONG(X)

Use this macro to return a long value. The argument should be a @code{long} value to return.

The macro allocates the BASIC variable to return the value, sets the value to it to the actual
value of the macro argument and returns from the funcion using the macro with no error (COMMAND_ERROR_SUCCESS).

If the return value can not be allocated the macro returns with COMMAND_ERROR_MEMORY_LOW.

@subsection  besRETURN_DOUBLE


Use this macro to return a double value. The argument should be a @code{double} value to return.

The macro allocates the BASIC variable to return the value, sets the value to it to the actual
value of the macro argument and returns from the funcion using the macro with no error (COMMAND_ERROR_SUCCESS).

If the return value can not be allocated the macro returns with COMMAND_ERROR_MEMORY_LOW.

@subsection  besSETCOMMAND(X,Y)
Use this macro to alter the command table. @code{X} is the command code and @code{Y} is the
new function implementing the command.

@subsection  besGETCOMMAND(X)
Use this macro to get the command function currently assigned to the command @code{X}.

@subsection  INTERFACE_VERSION
The current external module interface version. This is an integer number.

@subsection  besHOOK_FILE_ACCESS
This macro calls the function @xref{hook_file_access@}

@subsection  besHOOK_FOPEN
This macro calls the function @xref{hook_fopen@}

@subsection  besHOOK_FCLOSE
This macro calls the function @xref{hook_fclose@}

@subsection  besHOOK_SIZE
This macro calls the function @xref{hook_size@}

@subsection  besHOOK_TIME_ACCESSED
This macro calls the function @xref{hook_time_accessed@}

@subsection  besHOOK_TIME_MODIFIED
This macro calls the function @xref{hook_time_modified@}

@subsection  besHOOK_TIME_CREATED
This macro calls the function @xref{hook_time_created@}

@subsection  besHOOK_ISDIR
This macro calls the function @xref{hook_isdir@}

@subsection  besHOOK_ISREG
This macro calls the function @xref{hook_isreg@}

@subsection  besHOOK_EXISTS
This macro calls the function @xref{hook_fileexists@}

@subsection  besHOOK_TRUNCATE
This macro calls the function @xref{hook_truncate@}

@subsection  besHOOK_FGETC
This macro calls the function @xref{hook_fgetc@}

@subsection  besHOOK_FREAD
This macro calls the function @xref{hook_fread@}

@subsection  besHOOK_FWRITE
This macro calls the function @xref{hook_fwrite@}

@subsection  besHOOK_FERROR
This macro calls the function @xref{hook_ferror@}

@subsection  besHOOK_PUTC
This macro calls the function @xref{hook_fputc@}

@subsection  besHOOK_FLOCK
This macro calls the function @xref{hook_flock@}

@subsection  besHOOK_LOCK
This macro calls the function @xref{hook_lock@}

@subsection  besHOOK_FEOF
This macro calls the function @xref{hook_feof@}

@subsection  besHOOK_MKDIR
This macro calls the function @xref{hook_mkdir@}

@subsection  besHOOK_RMDIR
This macro calls the function @xref{hook_rmdir@}

@subsection  besHOOK_REMOVE
This macro calls the function @xref{hook_remove@}

@subsection  besHOOK_DELTREE
This macro calls the function @xref{hook_deltree@}

@subsection  besHOOK_MAKEDIRECTORY
This macro calls the function @xref{hook_MakeDirectory@}

@subsection  besHOOK_OPENDIR
This macro calls the function @xref{hook_opendir@}

@subsection  besHOOK_READDIR
This macro calls the function @xref{hook_readdir@}

@subsection  besHOOK_CLOSEDIR
This macro calls the function @xref{hook_closedir@}

@subsection  besHOOK_SLEEP
This macro calls the function @xref{hook_sleep@}

@subsection  besHOOK_CURDIR
This macro calls the function @xref{hook_curdir@}

@subsection  besHOOK_CHDIR
This macro calls the function @xref{hook_chdir@}

@subsection  besHOOK_CHOWN
This macro calls the function @xref{hook_chown@}

@subsection  besHOOK_SETCREATETIME
This macro calls the function @xref{hook_SetCreateTime@}

@subsection  besHOOK_SETMODIFYTIME
This macro calls the function @xref{hook_SetModifyTime@}

@subsection  besHOOK_SETACCESSTIME
This macro calls the function @xref{hook_SetAccessTime@}

@subsection  besHOOK_GETHOSTNAME
This macro calls the function @xref{hook_GetHostName@}

@subsection  besHOOK_GETHOST
This macro calls the function @xref{hook_GetHost@}

@subsection  besHOOK_TCPCONNECT
This macro calls the function @xref{hook_TcpConnect@}

@subsection  besHOOK_TCPSEND
This macro calls the function @xref{hook_TcpSend@}

@subsection  besHOOK_TCPRECV
This macro calls the function @xref{hook_TcpRecv@}

@subsection  besHOOK_TCPCLOSE
This macro calls the function @xref{hook_TcpClose@}

@subsection  besHOOK_KILLPROC
This macro calls the function @xref{hook_KillProc@}

@subsection  besHOOK_GETOWNER
This macro calls the function @xref{hook_GetOwner@}

@subsection  besHOOK_CREATEPROCESS
This macro calls the function @xref{hook_CreateProcess@}

@subsection  besHOOK_CALLSCRIBAFUNCTION
This macro calls the function @xref{hook_CallScribaFunction@}

@subsection  besSETHOOK(X,Y)
Use this macro to alter the hook function table.

@subsection  besDLL_MAIN

process header macro makes UNIX like dll loading and unloading
on Win32. This just defines a wrapper DllMain that calls _init() and
_fini() that a the default library loading and unloading functions
under UNIX.

Use of this macro may be needed for modules that serve multi thread
interpreters and share resources on the process level

@subsection  INITLOCK

Whent he process first time loads an extension and the extension wants to decide whether
to unload it or keep in memory it needs a counter and a mutex to access the counter
to declare the counter the extension should use the macro SUPPORT_MULTITHREAD and
to initialize it it should use the macro INIT_MULTITHREAD

Note that the call-back functions to handle the mutexes OS independant are not available
by the time when the OS calls DllMain on NT or _init on UNIX, thus the code should call
system dependant functions directly

IsThisTheVeryFirstThreadCallingTheModule <- name of the function
 
@subsection  basext_GetArgsF()

This function can be used to get arguments simple and fast in extension modules.
All functionality of this function can be individually programmed using the
@code{besXXX} macros. Here it is to ease the programming of extension modules for most of
the cases.

This function should be called like

@example
  iError = besGETARGS "ldz",&l1,&d1,&s besGETARGE
@end example

The macro @code{besGETARGS} (read GET ARGument Start) hides the complexity of the
function call and the macro @code{besGETARGE} (read Get ARGument End) simply closes the
function call.

The first argument is format string. Each character specifies how the next argument
should be treated.

@example
int basext_GetArgsF(pSupportTable pSt,
                    pFixSizeMemoryObject pParameters,
                    char *pszFormat,
                    ...
  )@@{
@end example
The following characters are recognized:

@itemize
@item @code{i} the next argument of the function call should point to a @code{long} variable.
           The ScriptBasic argument will be converted to @code{long} using the macro
           @code{besCONVERT2LONG} and will be stored in the @code{long} variable.
@item @code{r} the same as @code{l} except that the argument should point a @code{double} and the
           basic argument is converted to @code{double} using @code{besCONVERT2DOUBLE}.
@item @code{z} the next argument should point to a @code{char *} pointer. The function takes
           the next BASIC argument as string, converts it to zero terminated string
           allocating space for it. These variables SHOULD be released by the caller
           using the macro @code{besFREE}.
@item @code{s} the next argument should point to a @code{unsigned char *} pointer. The function takes
           the next BASIC argument as string, converting it in case conversion is needed, and
           sets the @code{unsigned char *} pointer to point to the string. This format character
           should be used together with the character @code{l}
@item @code{l} the next argument should point to a @code{long} and the value of the variable
           will be the length of the last string atgument (either @code{z} or @code{s}).
           If there was no previous string argument the value returned will be zero.
@item @code{p} the next argument should point to a @code{void *} pointer. The BASIC argument value
           should be a string of @code{sizeof(void *)} characters that will be copied into the
           pointer argument. If the argument is not string or has not the proper size the function
           returns @code{COMMAND_ERROR_ARGUMENT_RANGE}.
@item @code{[} The arguments following this character are optional. Optional arguments may be
           unspecified. This is the case when the BASIC function call has less number of
           arguments or when the actual argument value is @code{undef}. In case of optional
           arguments the @code{undef} values are converted to zero value of the appropriate
           type. This means 0 in case of long, 0.0 in case of double, NULL in case of pointer
           and zero length string in case of strings.
@item @code{]} Arguments following this character are mandatory (are not optional). When the
           function starts to process the arguments they are mandatory by default. Using this
           notation you can enclode the optional arguments between @code{[} and @code{]}. For example
           the format string @code{"ii[z]"} means two long arguments and an optional zero terminated
           string argument.
@item @code{*} The argument is skipped. This may be used during development of a function.
@@end itemize

The return value of the function is zero in case there is no error or the error code.
 



@node Preprocessors
@chapter Preprocessors

ScriptBasic is capable handling two kind of preprocessors. One is external preprocessors, the other one is internal preprocessor. The names @emph{external} and the @emph{internal} distinguish between the execution type of these preprocessors. External preprocessors are executed in a separate process. Internal preprocessors run in the interpreter thread.

Because of this external preprocessors are standalone command line tools, which may be written for any application and not specifically for ScriptBasic. You can edit the ScriptBasic configuration file so that you can use the C preprocessor, @code{m4} or @code{jamal} as a preprocessor. It is fairly easy to write an external preprocessor compared to internal preprocessors. External preprocessor reads a file and creates an output file. It need not know anything about the internal structures of ScriptBasic. Then only thing a ScriptBasic external preprocessor writer has to know is what it wants to do and how to read and write files.

Internal preprocessors are implemented in dynamic link libraries, work closely together with ScriptBasic and can not be started standalone. Internal preprocessors are written specifically for ScriptBasic and can and should access many of ScriptBasic internal structures.

From this you can see that external preprocessors are much easier to write, while internal preprocessors have much more possibilities. An internal preprocessor can never started as external and vice versa.

Before starting to write a preprocessor you have to carefully check what you want to gain and decide if you want to write an external preprocessor or an internal.

Because external preprocessors are just standalone programs and there is even a sample preprocessor HEB written in BASIC this chapter talks about the internal preprocessor capabilities. @xref{External Preprocessor}


@section Loading Preprocessor

Loading a preprocessor depends on the embedding application. To load an internal preprocessor the function @code{ipreproc_LoadInternalPreprocessor} is called (implemented in the file @file{ipreproc.c}).

This function gets the name of an external preprocessor to load. The function searches the configuration information for the named preprocessor, loads the DLL/SO and invokes the initiation function of the preprocessor.

@example
int ipreproc_LoadInternalPreprocessor(pPreprocObject pPre,
                                      char *pszPreprocessorName);
@end example

The first argument is the pointer to the ScriptBasic preprocessor object to access the configuration information and the list of loaded preprocessors to put the actual one on the list.

The second argument is the name of the preprocessor as named in the configuration file, for example

@example
preproc (
  internal (
    sample "C:\\ScriptBasic\\bin\\samplepreprocessor.dll"
    )
@end example

The return value is zero or the error code.

(Note that this documentation may not be up-to date about the precise functioning of this function. For most up-to date information see the source documentation that is extracted from the source comment using the tool @file{esd2html.pl}.)


In the code base of ScriptBasic this function is called by the reader @file{reader.c} in the function @code{reader_LoadPreprocessors}. This is called automatically when the source is read and include files were also included. This function (@code{reader_LoadPreprocessors}) goes through all the lines and searches for lines that start with the word @code{preprocess} and name a preprocessor. The function loads the preprocessor and deletes the source line.

The function @code{ ipreproc_LoadInternalPreprocessor} is also called from the function @code{scriba_LoadInternalPreprocessor} in source file @file{scriba.c}

This function can and should be used by the embedding programs to load all internal preprocessors that are to be loaded based on some external conditions. For example the VARIATION STANDARD of ScriptBasic (aka. the command line embedding variation) loads all internal preprocessors that were named after the command line option @option{-i}.

Other embedding application may get the information of desired preprocessors from different sources, like environment variables, configuration files and so on.

Note that internal preprocessors are not used whenever an already compiled version of the program is executing. If there is a @code{preprocess} line in the source code and the program has generated a cache or any other binary format BASIC program and that file is used to execute the program the preprocessor will no effect. The interpreter will not load the preprocessor and thus it will act as it did not exist.

There are two kind of preprocessors:


@itemize
@item Altering preprocessors

The "altering" preprocessors act as conventional preprocessor altering the source code and/or altering the compilation environment during compilation that results finally a binary BASIC file. These preprocessors ask the ScriptBasic interpreter to unload the preprocessor before the actual execution of the program starts as they have nothing to do with the actual, executed program.

@item Debugger preprocessors

Debugger preprocessor collects symbolic information during the compilation phase and alters the hook functions @code{HOOK_ExecBefore}, @code{HOOK_ExecAfter}, @code{HOOK_ExecCall}, @code{HOOK_ExecReturn}.

During execution these "preprocessors" remain in the process and execute the functions that the altered hook pointers point to performing debugging, profiling or some other development support features.

The sample preprocessor @code{dbg} does this implementing a command line debugger.

@item Mixed preprocessors

It is possible, though I see no reason to write a preprocessor that belongs to both categories above.

@end itemize

Altering preprocessors are BASIC program specific and are usually invoked because the program contains a line @code{preprocess}.

Debugger type preprocessors are loaded the way of the execution of the program requests it. For example the user uses the option @option{-i}. In this case the command line version of ScriptBasic does not use cache file to ensure that the program really does using the preprocessor and starts the debugger, for example.

@section Skeleton of a Preprocessor

An internal preprocessor implemented as a @code{.dll} or @code{.so} file has to export a single function named @code{preproc}. The declaration of this function should look like this:

@example
int DLL_EXPORT preproc(pPrepext pEXT,
                       long *pCmd,
                       void *p);
@end example

The first argument of the function is the preprocessor pointer. This pointer points to a structure. For each preprocessor loaded there is a separate structure of this type. This structure hold information on the preprocessor and there is some storage pointer in the structure that the preprocessor can access.

The definition of the structure is:

@example
typedef struct _Prepext {
  long lVersion;
  void *pPointer;
  void *pMemorySegment;
  struct _SupportTable *pST;
  } Prepext, *pPrepext;
@end example

The field @code{lVersion} is the version of the interface that ScriptBasic wants to use when communicating with the preprocessor. If this version is not the same as the interface version that the preprocessor was compiled for then the preprocessor has to ask ScriptBasic not to use it and may return an error code or zero indicating that no error has happened. This may be useful in some cases when the preprocessor is optional and in case the preprocessor can not be loaded the program still may function. Read on how the preprocessor has to do this.

The field @code{pPointer} is initialized to @code{NULL} and is never changed by ScriptBasic. This is a pointer that can be used by the preprocessor to access its own thread local variables.

The field @code{pMemorySegment} is initialized to point to a memory segment that can be used via the memory allocation routines of ScriptBasic. These routines, however need not be linked to the DLL, because they are already in the process loaded as part of the executable and can be reached via the function support table.

This support table is pointed by the field @code{pST} and is the same type of @code{struct} as the support table available for the extension modules. Although this support table is the same type of @code{struct} it is not the same @code{struct}. The fields pointing to the different functions are eventually pointing to the same function, but when the program starts to execute a new support table is allocated and initialized. Thus there is no reason for the preprocessor to alter this table, because altering the table will have no effect on the execution of the program. Also the preprocessor if decides to stay in memory while the program is executed (for example a debugger), may rely on this support table even if a module altering the run-time support table is used.

In case there are more than one internal preprocessors used they will share the same support table. This way a preprocessor altering the preprocessor support table may alter the behavior of another internal preprocessor. However doing that need deep and detailed information of both ScriptBasic code and the other preprocessor and may result code that closely depends on the different versions of the different programs that work together.

The next argument to the function @code{pCmd} is an input and output variable. When the function is called by ScriptBasic it contains the command that the preprocessor is expected to perform. In other words this value defines the reason why the preprocessor was loaded. There are numerous points when ScriptBasic calls the preprocessor and at each point it sets this variable differently.

When the function returns it is supposed to set the variable @code{*pCmd} to one of the following values:

@itemize

@item
  @code{PreprocessorContinue}

Returning this value means that the preprocessor has done what it was supposed to do and the program should go on.

@item
  @code{PreprocessorDone}

Returning this value means that the preprocessor has done what it was supposed to do and ScriptBasic should not, and indeed will not call any other preprocessors loaded for the actual "command".

@item
  @code{PreprocessorUnload}

Returning this value means that the preprocessor has done all tasks it had to do and ScriptBasic should close the preprocessor, release all memory that the preprocessor has allocated using the call-back function @code{alloc_Alloc} and should unload the dynamic load library.

@end itemize

The preprocessors function @code{preproc} may at any call return an @code{int} value. This value will be used by the interpreter as error code. This code is zero in case there was no error. This value has to be returned to ensure that the interpreter goes on. The error code @code{1} is used at any code in ScriptBasic to signal memory allocation problems. The symbolic constant @code{COMMAND_ERROR_PREPROCESSOR_ABORT} can be used to tell the interpreter to stop. For example the sample debugger preprocessor uses this error code when the user gives the command @code{q} to quit debugging.

@section Preprocessor Entry Points


Lets recall the prototype of the preprocessor function, which has to be implemented in each preprocessor:

@example
int DLL_EXPORT preproc(pPrepext pEXT,
                       long *pCmd,
                       void *p);
@end example

This function has to be implemented in each internal preprocessor and is called when the preprocessor is loaded or when some the processing of the source program has reached a certain point. To inform the function about this point the argument @code{pCmd} is used. This argument points to a @code{long} that holds the a constant identifying the reason why the preprocessor function was called. The following subsections list these identifiers.

@subsection PreprocessorLoad

This entry point is used when the preprocessor is loaded. The pointer @code{p} is @code{NULL}.

When the preprocessor function is called with this argument it can be sure that this is the very first call to the function within the actual interpreter thread. It also can depend on the support function table and on the preprocessor memory segment pointer being initialized and ready to allocate memory.

It has to check that the version the preprocessor was designed and compiled for is appropriate and works together with the ScriptBasic interpreter that invoked the preprocessor. This can easily be done checking the version information in the preprocessor structure. Sample code:

@example
      if( pEXT->lVersion != IP_INTERFACE_VERSION ){
        *pCmd = PreprocessorUnload;
        return 0;
        }
@end example

This code is the appropriate place to allocate space for the preprocessor structure that hold the thread local variables. For example:

@example
      pDO = pEXT->pST->Alloc(sizeof(DebuggerObject),pEXT->pMemorySegment);
      *pCmd = PreprocessorUnload;
      if( pDO == NULL )return 1;
@end example

Note that this example is a simplified version of the one that you can find in the sample debugger preprocessor. This example uses the @code{Alloc} support function that is usually points to the function @code{alloc_Alloc} implemented in the file @file{myalloc.c}. When coding an external preprocessor you can rely on ScriptBasic that as soon as the preprocessor is unloaded the memory allocated using this function with the memory segment initiated for the preprocessor (like above) will be released.

The preprocessor has to return the error code or zero and may alter the value of the parameter @code{*pCmd} to @code{PreprocessorContinue} or @code{PreprocessorUnload}.

Although the calling code ignores the value returned in @code{*pCmd} unless it is @code{PreprocessorUnload} it is required by principle to set a value in this variable. The value @code{PreprocessorDone} can not be used when returning from this entry.

@subsection PreprocessorReadStart

This entry point is used before the source file reading starts. The pointer @code{p} points to the @code{ReadObject} used to read the source files. There is few uses of this entry point. You may alter the file handling function pointers or the memory allocation function pointers in the @code{ReadObject}.

This entry point is invoked only when the preprocessor load was initiated by external conditions, like command line option @option{-i} and never if the source code contained the preprocessor loading directive. This is because when the reader realizes that the preprocessor has to be loaded it is far over this point.



The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorReadDone0

This entry point is used when the reader has done the reading of the source file, but did not do any processing further. The parameter @code{p} points to the @code{ReadObject}. The preprocessor at this point can access the lines of the core BASIC program file without the included files and the very first line of the program that may be a Windows NT or UNIX special line (like @code{#!/usr/bin/scriba}) is still in the input lines.

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorReadDone1

This entry point is used when the reader has done the reading the source file and unhooked the optional first Windows NT or UNIX start line (like @code{#!/usr/bin/scriba}), but did not process the included files. The preprocessor at this point can access the lines of the core BASIC program file without the included files. The parameter @code{p} points to the @code{ReadObject}.

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorReadDone2

This entry point is used when the reader has done the reading the source file and unhooked the optional first Windows NT or UNIX start line (like @code{#!/usr/bin/scriba}), and has processed the included files. The preprocessor at this point can access the lines of the full BASIC program file with the included files. The parameter @code{p} points to the @code{ReadObject}.

This is the last point before the source code directive loaded preprocessors are invoked.

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorReadDone3

This point is used when the reader has done all reading tasks, processed and linked the include files, has removed the first Windows NT or UNIX specific line, and loaded the preprocessors that were to be loaded by program directive. The parameter @code{p} points to the @code{ReadObject}.

At this point the preprocessor may check the source code and alter it according to its need. All processing should be done here that needs the characters of the source file. Careful decision has to be made whether using this point of entry to alter the source file or the entry point @code{PreprocessorLexDone} when the source file is already tokenized.

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorLexInit

This entry point is used when the lexer object was allocated and initialized. The pointer @code{p} points to the @code{LexObject}.

The preprocessor at this point may alter the @code{LexObject} parameters. Here is a copy of the function @code{lex_InitStructure} from ScriptBasic v1.0build26. (other versions may slightly differ).

@example
void lex_InitStructure(pLexObject pLex
  ){
/*noverbatim
CUT*/
  pLex->pfGetCharacter = NULL;
  pLex->pfFileName = _MyFileName;
  pLex->pfLineNumber = _MyLineNumber;
  pLex->SSC = "QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm_:$";
  pLex->SCC = "QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm_1234567890:$";
  pLex->SFC = "QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm_1234567890$";
  pLex->SStC = "\"";
  pLex->ESCS = "\\n\nt\tr\r\"\"\'\'";
  pLex->fFlag = LEX_PROCESS_STRING_NUMBER       |
                LEX_PROCESS_STRING_OCTAL_NUMBER |
                LEX_PROCESS_STRING_HEX_NUMBER   |
                0;
  pLex->SKIP = " \t\r"; /* spaces to skip 
                           \r is included to ease compilation of DOS edited 
                           binary transfered files to run on UNIX */
  pLex->pNASymbols = NULL;
  pLex->pASymbols  = NULL;
  pLex->pCSymbols  = NULL;
  pLex->cbNASymbolLength = 0; /* it is to be calculated */

  pLex->buffer = lexALLOC(BUFFERINCREASE*sizeof(char));

  if( pLex->buffer )
    pLex->cbBuffer = BUFFERINCREASE;
  else
    pLex->cbBuffer = 0;

  CALL_PREPROCESSOR(PreprocessorLexInit,pLex);
  }
@end example

(Note @code{CALL_PREPROCESSOR} is a macro that call the preprocessor with appropriate arguments.)

The preprocessor may decide for example to alter the string @code{SSC} that contains all characters that may start a symbol, or @code{SCC} that contains all characters that can part a symbol or @code{SFC} that contains all characters that can be the final character of a symbol. This way for example a preprocessor may set these strings that allows Hungarian programmers to use ISO-Latin-2 accented letters in their variables. (However those characters are going to be case sensitive.)

The preprocessor may also set the pointers that point to the tables that contains the alphanumeric symbols (@code{pASymbols}), non-alpha symbols (@code{pNASymbols}) and the table used for some ScriptBasic internal debugging purpose (@code{pCSymbols}).

The preprocessor may also release and reallocate a smaller or larger @code{buffer} if wishes. (I personally see no reason.)

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorLexDone

This entry point is used when the lexer has finished the lexical analysis and the list of tokens is already in the memory. The pointer @code{p} points to the @code{LexObject}.

At this point the preprocessor may alter the tokenized form of the BASIC program. The list of tokens still contains the comment lines (also tokenized although it may make no sense), and the continuation lines are still being split containing the @code{_} character and the new-line token.

The preprocessor may gain information from comments in case the some comments provide information for the preprocessor.

If the preprocessor uses some special symbols that drive the preprocessor processing but should be removed from the token list the preprocessor at this point may unlink the token from the list or just set the @code{type} of the token to @code{LEX_T_SKIP} or @code{LEX_T_SKIP_SYMBOL}.


If you do not or do not want to understand the difference between the two possibilities described soon then the rule of thumb is to use @code{LEX_T_SKIP} and you are safe.

The type @code{LEX_T_SKIP} should be used in case the token is handled due to @code{ProcessLexSymbol} preprocessor command and @code{LEX_T_SKIP} otherwise.

When the type is set @code{LEX_T_SKIP_SYMBOL} the lexical analyzer knows to release the string holding the symbol. If the type is @code{LEX_T_SKIP} only the token record is released.

If the symbol string is not released due to erroneously setting the type to @code{LEX_T_SKIP} instead @code{LEX_T_SKIP_SYMBOL} the memory will not be released until the interpreter finishes pre execution steps. So usually if you do not know how to set the type to skip a token @code{LEX_T_SKIP} is safe.

When processing comments the preprocessor should either use only the comments starting with the keyword @code{rem} or should carefully detect the comments starting with @code{'}.

For more information how to do it you really have to look at the function @code{lex_RemoveComments} in the file @file{lexer.c}.

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorLexNASymbol

This entry point is used when the lexer has found a non alpha symbol. Non alpha symbols are predefined character strings, like @code{<>} or @code{<=} that contain more than one character but are not alpha characters.



When this entry point is called the pointer @code{p} points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.

When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type @code{Lexeme}. The lexer object field @code{pLexResult} points to the first element of this list. The lexer code uses a local variable named @code{plexLastLexeme} that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.

When the preprocessor is called using this entry point this variable passed in the argument @code{p} "by value". Through this pointer you can 

@itemize
@item alter the last token fields
@item unhook the last token and optionally hook something else on it or even
@item unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
@end itemize

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorLexASymbol

This entry point is used when the lexer has found an alpha symbol. Alpha symbols are the keywords that are predefined in ScriptBasic.
 
When this entry point is called the pointer @code{p} points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.

When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type @code{Lexeme}. The lexer object field @code{pLexResult} points to the first element of this list. The lexer code uses a local variable named @code{plexLastLexeme} that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.

When the preprocessor is called using this entry point this variable passed in the argument @code{p} "by value". Through this pointer you can 

@itemize
@item alter the last token fields
@item unhook the last token and optionally hook something else on it or even
@item unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
@end itemize

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.


@subsection PreprocessorLexSymbol

This entry point is used when the lexer finds a symbol that is alphanumeric but is not predefined by ScriptBasic. These are the variables and symbols (like the statement @code{OPEN} opening modes.)

When this entry point is called the pointer @code{p} points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.

When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type @code{Lexeme}. The lexer object field @code{pLexResult} points to the first element of this list. The lexer code uses a local variable named @code{plexLastLexeme} that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.

When the preprocessor is called using this entry point this variable passed in the argument @code{p} "by value". Through this pointer you can 

@itemize
@item alter the last token fields
@item unhook the last token and optionally hook something else on it or even
@item unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
@end itemize

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorLexString

This entry point is used when the preprocessor has processed a single-line string.

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorLexMString


This entry point is used when the preprocessor has processed a multi-line string.
 
When this entry point is called the pointer @code{p} points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.

When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type @code{Lexeme}. The lexer object field @code{pLexResult} points to the first element of this list. The lexer code uses a local variable named @code{plexLastLexeme} that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.

When the preprocessor is called using this entry point this variable passed in the argument @code{p} "by value". Through this pointer you can 

@itemize
@item alter the last token fields
@item unhook the last token and optionally hook something else on it or even
@item unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
@end itemize
 
The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorLexInteger

This entry point is called when the lexer has processed an integer.

When this entry point is called the pointer @code{p} points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.

When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type @code{Lexeme}. The lexer object field @code{pLexResult} points to the first element of this list. The lexer code uses a local variable named @code{plexLastLexeme} that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.

When the preprocessor is called using this entry point this variable passed in the argument @code{p} "by value". Through this pointer you can 

@itemize
@item alter the last token fields
@item unhook the last token and optionally hook something else on it or even
@item unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
@end itemize
 
The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorLexReal

This entry point is called when the lexer has processed an real number.

When this entry point is called the pointer @code{p} points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.

When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type @code{Lexeme}. The lexer object field @code{pLexResult} points to the first element of this list. The lexer code uses a local variable named @code{plexLastLexeme} that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.

When the preprocessor is called using this entry point this variable passed in the argument @code{p} "by value". Through this pointer you can 

@itemize
@item alter the last token fields
@item unhook the last token and optionally hook something else on it or even
@item unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
@end itemize
 
The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.


@subsection PreprocessorLexCharacter

This entry point is called when the lexer has processed a character.

When this entry point is called the pointer @code{p} points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.

When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type @code{Lexeme}. The lexer object field @code{pLexResult} points to the first element of this list. The lexer code uses a local variable named @code{plexLastLexeme} that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.

When the preprocessor is called using this entry point this variable passed in the argument @code{p} "by value". Through this pointer you can 

@itemize
@item alter the last token fields
@item unhook the last token and optionally hook something else on it or even
@item unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
@end itemize
 
The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorExStart

This entry point is used when the syntax analyzer starts. 

The argument @code{p} points to the actual @code{peXobject} syntax analysis object structure.

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorExStartLine

This entry point is used when the syntax analyzer starts to analyze a program line.
The argument @code{p} points to the actual @code{peXobject} syntax analysis object structure.
The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorExEnd

This entry point is used when the syntax analyzer has finished analyzing the basic program.
The argument @code{p} points to the actual @code{peXobject} syntax analysis object structure.
The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorExFinish

This entry point is called from the function @code{ scriba_DoSyntaxAnalysis} implemented in the file @file{scriba.c} when the syntax analyzer has finished.

The only difference between this entry point and the entry point @code{PreprocessorExEnd} is that at this point the field @code{pCommandList} in the @code{peXobject} object structure already points to the list of nodes.

The argument @code{p} points to the actual @code{peXobject} syntax analysis object structure.
The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorExStartLocal

This entry point is used when the syntax analyzer starts a new local scope. This is when a function or a sub starts.

The argument @code{p} points to the actual @code{peXobject} syntax analysis object structure.
The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorExEndLocal

This entry point is used when the syntax analyzer exists a local scope. This is when a function or a sub ends.

The argument @code{p} points to the actual @code{peXobject} syntax analysis object structure.
The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorExLineNode

This entry point is used when the syntax analyzer creates a new node for a basic program line.

The argument @code{p} points to the actual @code{peXobject} syntax analysis object structure.
The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorExeStart

This entry point is used from the function @code{scriba_Run} implemented in the file @file{scriba.c} before the execution of the basic program starts.

The argument @code{p} points to the execution context of the basic program.



By this time most of the preprocessors should have asked the basic interpreter to unload. Only preprocessors implementing debugger, profiler or other development support functions may remain in memory and active.


At this very point debugger or other development support preprocessors may and should access the execution hook functions, like the sample debugger preprocessor does:

@example
  case PreprocessorExeStart:

    { pExecuteObject pEo = p;
      pDebuggerObject pDO = pEXT->pPointer;
      pEo->pHookers->hook_pointer = pEXT;
      pDO->CallStackDepth = 0;
      pDO->DbgStack = NULL;
      pDO->StackTop = NULL;
      pEo->pHookers->HOOK_ExecBefore = MyExecBefore;
      pEo->pHookers->HOOK_ExecAfter = MyExecAfter;
      pEo->pHookers->HOOK_ExecCall = MyExecCall;
      pEo->pHookers->HOOK_ExecReturn = MyExecReturn;
      *pCmd = PreprocessorContinue;
      return 0;
      }
@end example

(Note that this is an example only and not the actual code. The actual code performs other tasks as well.)

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorExeFinish

This entry point is used from the function @code{scriba_Run} implemented in the file @file{scriba.c} after the execution of the basic program finished.

The argument @code{p} points to the execution context of the basic program.

By this time most of the preprocessors should have asked the basic interpreter to unload. Only preprocessors implementing debugger, profiler or other development support functions may remain in memory and active.

The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@subsection PreprocessorExeNoRun

This entry point is used from the function @code{scriba_NoRun} implemented in the file @file{scriba.c} before the execution of the basic program is not started. (Note that @code{scriba_NoRun} performs initialization for the execution but does not start the execution.)

By this time most of the preprocessors should have asked the basic interpreter to unload. Only preprocessors implementing debugger, profiler or other development support functions may remain in memory and active.
 
The function has to return zero or the error code and should set the parameter @code{*pCmd} to @code{PreprocessorContinue}, @code{PreprocessorDone}, or @code{PreprocessorUnload}.

@chapter Compilation

ScriptBasic is written in C and thus there is a need for some C compiler to successfully install it from source. However some of the code is not maintained in C but rather in some higher level language (what an exaggeration!), which is compiled to C. To compile all the code from source you also need a functional Perl interpreter executing the version 5 of the language Perl.

Compilation is automated as much as it is possible and was highly tested on Windows NT and under Linux (Debian). Under other operating systems resembling to UNIX the compilation should be quite straight forward though may not be so seamless as it is for the ones I tested.

@section Compilation under UNIX

Compilation starts from the clean source package. You unzip it or gunzip untar it into the source directory. To be safe you can run

@example
sh convert.sh
@end example

that converts all text files from Windows line feed convention to UNIX convention. If you have a tarball rather than a ZIP file then you may already have the correct line ending, but running the conversion does not hurt. Well, if you feel better by that you can run it many times. On the other hand if you uploaded the Windows source package you will not get along compiling the package without this conversion.

To compile the code you have to issue the command

@example
./setup
@end example

This will run all the commands that are needed before compilation to generate the C source files from the real source files and also compiles the make files from their macro source. Finally it runs the compilation processes.

The program @file{setup.pl} started by the shell script @file{setup} is a huge Perl script that automates the compilation under UNIX and under Windows NT as well.

To install the compiled code the script @file{setup.pl} has to be started again, this time using the argument:

@example
./setup -install
@end example

Although its use may imply it does not install ScriptBasic. It only creates the file @file{install.sh} that you can run later any time

@example
$ su
Password: **********
# ./install.sh
@end example

from the root account. It is recommended that you examine and understand the content of the script before executing it. It actually installs ScriptBasic, compiles the configuration information, stops the Eszter SB Application Engine and many other things.

I said >>only creates the file ...<< in double quotes, because it does many things before actually creating the file. It interactively asks you about the destination directories, installs an experimental installation of ScriptBasic locally to run some test programs, examines which modules were compiled fine and so on. It even tests the possible maximal value for the configuration key @code{maxlevel} that limits the maximal recursive function call level inside ScriptBasic. To do so it creates a configuration that does not limit the depth and runs a test program until it crashes. The test program in each level of depth opens a file and appends a single byte to the file. Finally the length of the file gives the maximal possible recursive function depth on your installation.



@bye


