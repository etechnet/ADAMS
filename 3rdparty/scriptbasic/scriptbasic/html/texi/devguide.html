<HEAD>
<TITLE>ScriptBasic Developers Manual</TITLE>

<META NAME="description" CONTENT="ScriptBasic Developers Manual: Table of Contents">
<META NAME="keywords" CONTENT="ScriptBasic Developers Manual: Table of Contents">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="t2h.pl">

</HEAD>

<BODY LANG="" BGCOLOR="#C7C1A7" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<FONT FACE="Verdana" Size="2">

<H1>ScriptBasic Developers Manual</H1>
<H3>by Peter Verhas</H3>
<A NAME="contents"><H2>Table of Contents</H2></A>
<UL>
<A HREF="#1.">1.   Introduction</A><BR>
<UL>
<A HREF="#1.1.">1.1.   Chapters</A><BR>
</UL>
<A HREF="#2.">2.   Interpreter Architecture</A><BR>
<UL>
<A HREF="#2.1.">2.1.   External Preprocessor</A><BR>
<UL>
<A HREF="#2.1.1.">2.1.1.   External preprocessor handling</A><BR>
<A HREF="#2.1.2.">2.1.2.   Execute external preprocessors</A><BR>
</UL>
<A HREF="#2.2.">2.2.   Reader</A><BR>
<UL>
<A HREF="#2.2.1.">2.2.1.   reader_IncreaseBuffer()</A><BR>
<A HREF="#2.2.2.">2.2.2.   reader_gets()</A><BR>
<A HREF="#2.2.3.">2.2.3.   reader_ReadLines()</A><BR>
<A HREF="#2.2.4.">2.2.4.   reader_ReadLines_r()</A><BR>
<A HREF="#2.2.5.">2.2.5.   reader_ProcessIncludeFiles()</A><BR>
<A HREF="#2.2.6.">2.2.6.   reader_LoadPreprocessors()</A><BR>
<A HREF="#2.2.7.">2.2.7.   reader_StartIteration()</A><BR>
<A HREF="#2.2.8.">2.2.8.   reader_NextLine()</A><BR>
<A HREF="#2.2.9.">2.2.9.   reader_NextCharacter()</A><BR>
<A HREF="#2.2.10.">2.2.10.   reader_FileName()</A><BR>
<A HREF="#2.2.11.">2.2.11.   reader_LineNumber()</A><BR>
<A HREF="#2.2.12.">2.2.12.   reader_InitStructure()</A><BR>
<A HREF="#2.2.13.">2.2.13.   reader_RelateFile()</A><BR>
<A HREF="#2.2.14.">2.2.14.   reader_DumpLines()</A><BR>
</UL>
<A HREF="#2.3.">2.3.   Lexer</A><BR>
<UL>
<A HREF="#2.3.1.">2.3.1.   Functions implemented in this module</A><BR>
<UL>
<A HREF="#2.3.1.1.">2.3.1.1.   lex_SymbolicName()</A><BR>
<A HREF="#2.3.1.2.">2.3.1.2.   lex_HandleContinuationLines()</A><BR>
<A HREF="#2.3.1.3.">2.3.1.3.   lex_RemoveSkipSymbols()</A><BR>
<A HREF="#2.3.1.4.">2.3.1.4.   lex_RemoveComments()</A><BR>
<A HREF="#2.3.1.5.">2.3.1.5.   lex_NextLexeme()</A><BR>
<A HREF="#2.3.1.6.">2.3.1.6.   lex_SavePosition()</A><BR>
<A HREF="#2.3.1.7.">2.3.1.7.   lex_RestorePosition()</A><BR>
<A HREF="#2.3.1.8.">2.3.1.8.   lex_StartIteration()</A><BR>
<A HREF="#2.3.1.9.">2.3.1.9.   lex_EOF()</A><BR>
<A HREF="#2.3.1.10.">2.3.1.10.   lex_Type()</A><BR>
<A HREF="#2.3.1.11.">2.3.1.11.   lex_Double()</A><BR>
<A HREF="#2.3.1.12.">2.3.1.12.   lex_String()</A><BR>
<A HREF="#2.3.1.13.">2.3.1.13.   lex_StrLen()</A><BR>
<A HREF="#2.3.1.14.">2.3.1.14.   lex_Long()</A><BR>
<A HREF="#2.3.1.15.">2.3.1.15.   lex_LineNumber()</A><BR>
<A HREF="#2.3.1.16.">2.3.1.16.   lex_FileName()</A><BR>
<A HREF="#2.3.1.17.">2.3.1.17.   lex_XXX()</A><BR>
<A HREF="#2.3.1.18.">2.3.1.18.   lex_Finish()</A><BR>
<A HREF="#2.3.1.19.">2.3.1.19.   lex_DumpLexemes()</A><BR>
<A HREF="#2.3.1.20.">2.3.1.20.   lex_ReadInput()</A><BR>
<A HREF="#2.3.1.21.">2.3.1.21.   lex_InitStructure()</A><BR>
</UL>
</UL>
<A HREF="#2.4.">2.4.   Syntax Analyzer</A><BR>
<UL>
<A HREF="#2.4.1.">2.4.1.   Name Space</A><BR>
<A HREF="#2.4.2.">2.4.2.   Expression</A><BR>
<A HREF="#2.4.3.">2.4.3.   Functions implemented in this module</A><BR>
<UL>
<A HREF="#2.4.3.1.">2.4.3.1.   What is an expression in ScriptBasic</A><BR>
<A HREF="#2.4.3.2.">2.4.3.2.   ex_DumpVariables()</A><BR>
<A HREF="#2.4.3.3.">2.4.3.3.   expression_PushNameSpace()</A><BR>
<A HREF="#2.4.3.4.">2.4.3.4.   ex_CheckUndefinedLabels()</A><BR>
<A HREF="#2.4.3.5.">2.4.3.5.   ex_CleanNameSpaceStack()</A><BR>
<A HREF="#2.4.3.6.">2.4.3.6.   expression_PopNameSpace()</A><BR>
<A HREF="#2.4.3.7.">2.4.3.7.   ex_PushWaitingLabel()</A><BR>
<A HREF="#2.4.3.8.">2.4.3.8.   ex_PopWaitingLabel()</A><BR>
<A HREF="#2.4.3.9.">2.4.3.9.   _ex_PushLabel()</A><BR>
<A HREF="#2.4.3.10.">2.4.3.10.   _ex_PopLabel()</A><BR>
<A HREF="#2.4.3.11.">2.4.3.11.   _ex_CleanLabelStack()</A><BR>
<A HREF="#2.4.3.12.">2.4.3.12.   Some NOTE on SymbolXXX functions</A><BR>
<A HREF="#2.4.3.13.">2.4.3.13.   _new_SymbolLABEL()</A><BR>
<A HREF="#2.4.3.14.">2.4.3.14.   _new_SymbolVAR()</A><BR>
<A HREF="#2.4.3.15.">2.4.3.15.   _new_SymbolUF()</A><BR>
<A HREF="#2.4.3.16.">2.4.3.16.   _new_eNODE()</A><BR>
<A HREF="#2.4.3.17.">2.4.3.17.   _new_eNODE_l()</A><BR>
<A HREF="#2.4.3.18.">2.4.3.18.   ex_free()</A><BR>
<A HREF="#2.4.3.19.">2.4.3.19.   ex_init()</A><BR>
<A HREF="#2.4.3.20.">2.4.3.20.   ex_CleanNamePath()</A><BR>
<A HREF="#2.4.3.21.">2.4.3.21.   ex_ConvertName()</A><BR>
<A HREF="#2.4.3.22.">2.4.3.22.   ex_IsBFun()</A><BR>
<A HREF="#2.4.3.23.">2.4.3.23.   ex_IsUnop()</A><BR>
<A HREF="#2.4.3.24.">2.4.3.24.   ex_IsBinop()</A><BR>
<A HREF="#2.4.3.25.">2.4.3.25.   ex_LeftValueList()</A><BR>
<A HREF="#2.4.3.26.">2.4.3.26.   ex_ExpressionList()</A><BR>
<A HREF="#2.4.3.27.">2.4.3.27.   ex_Local()</A><BR>
<A HREF="#2.4.3.28.">2.4.3.28.   ex_LocalList()</A><BR>
<A HREF="#2.4.3.29.">2.4.3.29.   ex_Global()</A><BR>
<A HREF="#2.4.3.30.">2.4.3.30.   ex_GlobalList()</A><BR>
<A HREF="#2.4.3.31.">2.4.3.31.   ex_LookupUserFunction()</A><BR>
<A HREF="#2.4.3.32.">2.4.3.32.   ex_LookupGlobalVariable</A><BR>
<A HREF="#2.4.3.33.">2.4.3.33.   ex_LookupLocallyDeclaredGlobalVariable</A><BR>
<A HREF="#2.4.3.34.">2.4.3.34.   ex_LookupLocalVariable</A><BR>
<A HREF="#2.4.3.35.">2.4.3.35.   ex_Tag</A><BR>
<A HREF="#2.4.3.36.">2.4.3.36.   ex_Expression_i</A><BR>
<A HREF="#2.4.3.37.">2.4.3.37.   ex_Expression_r</A><BR>
<A HREF="#2.4.3.38.">2.4.3.38.   ex_IsSymbolValidLval(pEx)</A><BR>
<A HREF="#2.4.3.39.">2.4.3.39.   ex_LeftValue</A><BR>
<A HREF="#2.4.3.40.">2.4.3.40.   ex_PredeclareGlobalLongConst()</A><BR>
<A HREF="#2.4.3.41.">2.4.3.41.   ex_IsCommandThis</A><BR>
<A HREF="#2.4.3.42.">2.4.3.42.   ex_Command_r()</A><BR>
<A HREF="#2.4.3.43.">2.4.3.43.   ex_Command_l()</A><BR>
<A HREF="#2.4.3.44.">2.4.3.44.   ex_Pragma</A><BR>
<A HREF="#2.4.3.45.">2.4.3.45.   ex_IsCommandCALL()</A><BR>
<A HREF="#2.4.3.46.">2.4.3.46.   ex_IsCommandOPEN()</A><BR>
<A HREF="#2.4.3.47.">2.4.3.47.   ex_IsCommandSLIF()</A><BR>
<A HREF="#2.4.3.48.">2.4.3.48.   ex_IsCommandIF()</A><BR>
<A HREF="#2.4.3.49.">2.4.3.49.   ex_IsCommandLET()</A><BR>
</UL>
</UL>
<A HREF="#2.5.">2.5.   Builder</A><BR>
<UL>
<A HREF="#2.5.1.">2.5.1.   Node Structure</A><BR>
<A HREF="#2.5.2.">2.5.2.   Binary File Format</A><BR>
<A HREF="#2.5.3.">2.5.3.   Functions implemented in this module</A><BR>
<UL>
<A HREF="#2.5.3.1.">2.5.3.1.   The structure of the string table</A><BR>
<A HREF="#2.5.3.2.">2.5.3.2.   build_AllocateStringTable()</A><BR>
<A HREF="#2.5.3.3.">2.5.3.3.   build_StringIndex()</A><BR>
<A HREF="#2.5.3.4.">2.5.3.4.   build_Build_l()</A><BR>
<A HREF="#2.5.3.5.">2.5.3.5.   build_Build_r()</A><BR>
<A HREF="#2.5.3.6.">2.5.3.6.   build_Build()</A><BR>
<A HREF="#2.5.3.7.">2.5.3.7.   build_MagicCode()</A><BR>
<A HREF="#2.5.3.8.">2.5.3.8.   build_SaveCCode()</A><BR>
<A HREF="#2.5.3.9.">2.5.3.9.   build_SaveCorePart()</A><BR>
<A HREF="#2.5.3.10.">2.5.3.10.   build_SaveCore()</A><BR>
<A HREF="#2.5.3.11.">2.5.3.11.   build_SaveCode()</A><BR>
<A HREF="#2.5.3.12.">2.5.3.12.   build_SaveECode()</A><BR>
<A HREF="#2.5.3.13.">2.5.3.13.   build_GetExeCodeOffset()</A><BR>
<A HREF="#2.5.3.14.">2.5.3.14.   build_LoadCore()</A><BR>
<A HREF="#2.5.3.15.">2.5.3.15.   build_LoadCodeWithOffset()</A><BR>
<A HREF="#2.5.3.16.">2.5.3.16.   build_LoadCode()</A><BR>
<A HREF="#2.5.3.17.">2.5.3.17.   build_IsFileBinaryFormat()</A><BR>
<A HREF="#2.5.3.18.">2.5.3.18.   build_pprint()</A><BR>
<A HREF="#2.5.3.19.">2.5.3.19.   build_CreateFTable()</A><BR>
<A HREF="#2.5.3.20.">2.5.3.20.   build_CreateVTable()</A><BR>
<A HREF="#2.5.3.21.">2.5.3.21.   build_LookupFunctionByName()</A><BR>
<A HREF="#2.5.3.22.">2.5.3.22.   build_LookupVariableByName()</A><BR>
</UL>
</UL>
<A HREF="#2.6.">2.6.   Executor</A><BR>
<UL>
<A HREF="#2.6.1.">2.6.1.   Command parameters</A><BR>
<A HREF="#2.6.2.">2.6.2.   Instrunction parameters</A><BR>
<A HREF="#2.6.3.">2.6.3.   Finalizer function</A><BR>
<A HREF="#2.6.4.">2.6.4.   Functions implemented in this module</A><BR>
<UL>
<A HREF="#2.6.4.1.">2.6.4.1.   execute_GetCommandByName()</A><BR>
<A HREF="#2.6.4.2.">2.6.4.2.   execute_CopyCommandTable()</A><BR>
<A HREF="#2.6.4.3.">2.6.4.3.   execute_InitStructure()</A><BR>
<A HREF="#2.6.4.4.">2.6.4.4.   execute_ReInitStructure()</A><BR>
<A HREF="#2.6.4.5.">2.6.4.5.   execute_Execute_r()</A><BR>
<A HREF="#2.6.4.6.">2.6.4.6.   execute_InitExecute()</A><BR>
<A HREF="#2.6.4.7.">2.6.4.7.   execute_FinishExecute()</A><BR>
<A HREF="#2.6.4.8.">2.6.4.8.   execute_Execute()</A><BR>
<A HREF="#2.6.4.9.">2.6.4.9.   execute_ExecuteFunction()</A><BR>
<A HREF="#2.6.4.10.">2.6.4.10.   execute_Evaluate()</A><BR>
<A HREF="#2.6.4.11.">2.6.4.11.   execute_LeftValue()</A><BR>
<A HREF="#2.6.4.12.">2.6.4.12.   execute_EvaluateArray()</A><BR>
<A HREF="#2.6.4.13.">2.6.4.13.   execute_EvaluateSarray()</A><BR>
<A HREF="#2.6.4.14.">2.6.4.14.   execute_LeftValueArray()</A><BR>
<A HREF="#2.6.4.15.">2.6.4.15.   execute_LeftValueSarray()</A><BR>
<A HREF="#2.6.4.16.">2.6.4.16.   execute_Convert2String()</A><BR>
<A HREF="#2.6.4.17.">2.6.4.17.   execute_Convert2Long()</A><BR>
<A HREF="#2.6.4.18.">2.6.4.18.   execute_Convert2LongS()</A><BR>
<A HREF="#2.6.4.19.">2.6.4.19.   execute_Convert2Double()</A><BR>
<A HREF="#2.6.4.20.">2.6.4.20.   execute_Convert2DoubleS()</A><BR>
<A HREF="#2.6.4.21.">2.6.4.21.   execute_Convert2Numeric()</A><BR>
<A HREF="#2.6.4.22.">2.6.4.22.   execute_Dereference()</A><BR>
<A HREF="#2.6.4.23.">2.6.4.23.   execute_DereferenceS()</A><BR>
<A HREF="#2.6.4.24.">2.6.4.24.   execute_GetDoubleValue()</A><BR>
<A HREF="#2.6.4.25.">2.6.4.25.   execute_GetLongValue()</A><BR>
<A HREF="#2.6.4.26.">2.6.4.26.   execute_IsStringInteger()</A><BR>
<A HREF="#2.6.4.27.">2.6.4.27.   execute_IsInteger()</A><BR>
</UL>
</UL>
<A HREF="#2.7.">2.7.   Configuration File Handling</A><BR>
<UL>
<A HREF="#2.7.1.">2.7.1.   Functions implemented in this module</A><BR>
<UL>
<A HREF="#2.7.1.1.">2.7.1.1.   cft_init()</A><BR>
<A HREF="#2.7.1.2.">2.7.1.2.   cft_GetConfigFileName()</A><BR>
<A HREF="#2.7.1.3.">2.7.1.3.   cft_start()</A><BR>
<A HREF="#2.7.1.4.">2.7.1.4.   strmyeq()</A><BR>
<A HREF="#2.7.1.5.">2.7.1.5.   cft_FindNode()</A><BR>
<A HREF="#2.7.1.6.">2.7.1.6.   cft_GetEx()</A><BR>
<A HREF="#2.7.1.7.">2.7.1.7.   cft_GetString()</A><BR>
<A HREF="#2.7.1.8.">2.7.1.8.   cft_EnumFirst()</A><BR>
<A HREF="#2.7.1.9.">2.7.1.9.   cft_EnumNext()</A><BR>
<A HREF="#2.7.1.10.">2.7.1.10.   cft_GetKey()</A><BR>
<A HREF="#2.7.1.11.">2.7.1.11.   cft_ReadConfig()</A><BR>
<A HREF="#2.7.1.12.">2.7.1.12.   cft_WriteConfig()</A><BR>
<A HREF="#2.7.1.13.">2.7.1.13.   cft_DropConfig()</A><BR>
</UL>
</UL>
<A HREF="#2.8.">2.8.   Memory Allocation</A><BR>
<UL>
<A HREF="#2.8.1.">2.8.1.   Functions implemented in this module</A><BR>
<UL>
<A HREF="#2.8.1.1.">2.8.1.1.   Multi-thread use of this module</A><BR>
<A HREF="#2.8.1.2.">2.8.1.2.   alloc_InitSegment()</A><BR>
<A HREF="#2.8.1.3.">2.8.1.3.   alloc_GlobalUseGlobalMutex()</A><BR>
<A HREF="#2.8.1.4.">2.8.1.4.   alloc_SegmentLimit()</A><BR>
<A HREF="#2.8.1.5.">2.8.1.5.   alloc_FreeSegment()</A><BR>
<A HREF="#2.8.1.6.">2.8.1.6.   alloc_FinishSegment()</A><BR>
<A HREF="#2.8.1.7.">2.8.1.7.   alloc_Alloc()</A><BR>
<A HREF="#2.8.1.8.">2.8.1.8.   alloc_Free()</A><BR>
<A HREF="#2.8.1.9.">2.8.1.9.   alloc_Merge()</A><BR>
<A HREF="#2.8.1.10.">2.8.1.10.   alloc_MergeAndFinish()</A><BR>
<A HREF="#2.8.1.11.">2.8.1.11.   alloc_InitStat()</A><BR>
<A HREF="#2.8.1.12.">2.8.1.12.   alloc_GlobalGetStat()</A><BR>
<A HREF="#2.8.1.13.">2.8.1.13.   alloc_GetStat()</A><BR>
</UL>
</UL>
<A HREF="#2.9.">2.9.   Variable Allocation</A><BR>
<UL>
<A HREF="#2.9.1.">2.9.1.   Functions implemented in this module</A><BR>
<UL>
<A HREF="#2.9.1.1.">2.9.1.1.   memory_InitStructure()</A><BR>
<A HREF="#2.9.1.2.">2.9.1.2.   memory_RegisterType()</A><BR>
<A HREF="#2.9.1.3.">2.9.1.3.   memory_RegisterTypes()</A><BR>
<A HREF="#2.9.1.4.">2.9.1.4.   memory_DebugDump()</A><BR>
<A HREF="#2.9.1.5.">2.9.1.5.   memory_NewVariable()</A><BR>
<A HREF="#2.9.1.6.">2.9.1.6.   memory_ReleaseVariable()</A><BR>
<A HREF="#2.9.1.7.">2.9.1.7.   memory_NewString()</A><BR>
<A HREF="#2.9.1.8.">2.9.1.8.   memory_NewCString()</A><BR>
<A HREF="#2.9.1.9.">2.9.1.9.   memory_SetRef()</A><BR>
<A HREF="#2.9.1.10.">2.9.1.10.   memory_NewRef()</A><BR>
<A HREF="#2.9.1.11.">2.9.1.11.   memory_IsUndef()</A><BR>
<A HREF="#2.9.1.12.">2.9.1.12.   memory_Type()</A><BR>
<A HREF="#2.9.1.13.">2.9.1.13.   memory_SelfOrRealUndef()</A><BR>
<A HREF="#2.9.1.14.">2.9.1.14.   memory_NewUndef()</A><BR>
<A HREF="#2.9.1.15.">2.9.1.15.   memory_ReplaceVariable()</A><BR>
<A HREF="#2.9.1.16.">2.9.1.16.   memory_NewLong()</A><BR>
<A HREF="#2.9.1.17.">2.9.1.17.   memory_NewDouble()</A><BR>
<A HREF="#2.9.1.18.">2.9.1.18.   memory_CopyArray</A><BR>
<A HREF="#2.9.1.19.">2.9.1.19.   memory_NewArray()</A><BR>
<A HREF="#2.9.1.20.">2.9.1.20.   memory_ReDimArray()</A><BR>
<A HREF="#2.9.1.21.">2.9.1.21.   memory_CheckArrayIndex()</A><BR>
<A HREF="#2.9.1.22.">2.9.1.22.   memory_Mortalize()</A><BR>
<A HREF="#2.9.1.23.">2.9.1.23.   memory_Immortalize()</A><BR>
<A HREF="#2.9.1.24.">2.9.1.24.   memory_NewMortal()</A><BR>
<A HREF="#2.9.1.25.">2.9.1.25.   memory_DupImmortal()</A><BR>
<A HREF="#2.9.1.26.">2.9.1.26.   memory_DupVar()</A><BR>
<A HREF="#2.9.1.27.">2.9.1.27.   memory_DupMortalize()</A><BR>
<A HREF="#2.9.1.28.">2.9.1.28.   memory_ReleaseMortals()</A><BR>
<A HREF="#2.9.1.29.">2.9.1.29.   memory_DebugDumpVariable()</A><BR>
<A HREF="#2.9.1.30.">2.9.1.30.   memory_DebugDumpMortals()</A><BR>
<A HREF="#2.9.1.31.">2.9.1.31.   memory_NewMortalString()</A><BR>
<A HREF="#2.9.1.32.">2.9.1.32.   memory_NewMortalCString()</A><BR>
<A HREF="#2.9.1.33.">2.9.1.33.   memory_NewMortalLong()</A><BR>
<A HREF="#2.9.1.34.">2.9.1.34.   memory_NewMortalRef()</A><BR>
<A HREF="#2.9.1.35.">2.9.1.35.   memory_NewMortalDouble()</A><BR>
<A HREF="#2.9.1.36.">2.9.1.36.   memory_NewMortalArray()</A><BR>
</UL>
</UL>
<A HREF="#2.10.">2.10.   Error Reporting</A><BR>
<UL>
<A HREF="#2.10.1.">2.10.1.   Functions implemented in this module</A><BR>
<UL>
<A HREF="#2.10.1.1.">2.10.1.1.   report_report()</A><BR>
</UL>
</UL>
<A HREF="#2.11.">2.11.   The Logger Module</A><BR>
<UL>
<A HREF="#2.11.1.">2.11.1.   log_state()</A><BR>
<A HREF="#2.11.2.">2.11.2.   log_init()</A><BR>
<A HREF="#2.11.3.">2.11.3.   log_printf()</A><BR>
<A HREF="#2.11.4.">2.11.4.   log_shutdown()</A><BR>
</UL>
<A HREF="#2.12.">2.12.   Hook Functions</A><BR>
<UL>
<A HREF="#2.12.1.">2.12.1.   hook_Init</A><BR>
<A HREF="#2.12.2.">2.12.2.   hook_file_access</A><BR>
<A HREF="#2.12.3.">2.12.3.   hook_fopen</A><BR>
<A HREF="#2.12.4.">2.12.4.   hook_fclose</A><BR>
<A HREF="#2.12.5.">2.12.5.   hook_size</A><BR>
<A HREF="#2.12.6.">2.12.6.   hook_time_accessed</A><BR>
<A HREF="#2.12.7.">2.12.7.   hook_time_modified</A><BR>
<A HREF="#2.12.8.">2.12.8.   hook_time_created</A><BR>
<A HREF="#2.12.9.">2.12.9.   hook_isdir</A><BR>
<A HREF="#2.12.10.">2.12.10.   hook_isreg</A><BR>
<A HREF="#2.12.11.">2.12.11.   hook_fileexists</A><BR>
<A HREF="#2.12.12.">2.12.12.   hook_truncate</A><BR>
<A HREF="#2.12.13.">2.12.13.   hook_fgetc</A><BR>
<A HREF="#2.12.14.">2.12.14.   hook_ferror</A><BR>
<A HREF="#2.12.15.">2.12.15.   hook_fread</A><BR>
<A HREF="#2.12.16.">2.12.16.   hook_setmode</A><BR>
<A HREF="#2.12.17.">2.12.17.   hook_binmode</A><BR>
<A HREF="#2.12.18.">2.12.18.   hook_textmode</A><BR>
<A HREF="#2.12.19.">2.12.19.   hook_fwrite</A><BR>
<A HREF="#2.12.20.">2.12.20.   hook_fputc</A><BR>
<A HREF="#2.12.21.">2.12.21.   hook_flock</A><BR>
<A HREF="#2.12.22.">2.12.22.   hook_lock</A><BR>
<A HREF="#2.12.23.">2.12.23.   hook_feof</A><BR>
<A HREF="#2.12.24.">2.12.24.   hook_mkdir</A><BR>
<A HREF="#2.12.25.">2.12.25.   hook_rmdir</A><BR>
<A HREF="#2.12.26.">2.12.26.   hook_remove</A><BR>
<A HREF="#2.12.27.">2.12.27.   hook_deltree</A><BR>
<A HREF="#2.12.28.">2.12.28.   hook_MakeDirectory</A><BR>
<A HREF="#2.12.29.">2.12.29.   hook_opendir</A><BR>
<A HREF="#2.12.30.">2.12.30.   hook_readdir</A><BR>
<A HREF="#2.12.31.">2.12.31.   hook_closedir</A><BR>
<A HREF="#2.12.32.">2.12.32.   hook_sleep</A><BR>
<A HREF="#2.12.33.">2.12.33.   hook_curdir</A><BR>
<A HREF="#2.12.34.">2.12.34.   hook_chdir</A><BR>
<A HREF="#2.12.35.">2.12.35.   hook_chown</A><BR>
<A HREF="#2.12.36.">2.12.36.   hook_SetCreateTime</A><BR>
<A HREF="#2.12.37.">2.12.37.   hook_SetModifyTime</A><BR>
<A HREF="#2.12.38.">2.12.38.   hook_SetAccessTime</A><BR>
<A HREF="#2.12.39.">2.12.39.   hook_gethostname</A><BR>
<A HREF="#2.12.40.">2.12.40.   hook_gethost</A><BR>
<A HREF="#2.12.41.">2.12.41.   hook_tcpconnect</A><BR>
<A HREF="#2.12.42.">2.12.42.   hook_tcpsend</A><BR>
<A HREF="#2.12.43.">2.12.43.   hook_tcprecv</A><BR>
<A HREF="#2.12.44.">2.12.44.   hook_tcpclose</A><BR>
<A HREF="#2.12.45.">2.12.45.   hook_killproc</A><BR>
<A HREF="#2.12.46.">2.12.46.   hook_getowner</A><BR>
<A HREF="#2.12.47.">2.12.47.   hook_fcrypt</A><BR>
<A HREF="#2.12.48.">2.12.48.   hook_CreateProcess</A><BR>
<A HREF="#2.12.49.">2.12.49.   hook_CreateProcessEx</A><BR>
<A HREF="#2.12.50.">2.12.50.   hook_waitpid</A><BR>
<A HREF="#2.12.51.">2.12.51.   hook_CallScribaFunction</A><BR>
</UL>
<A HREF="#2.13.">2.13.   Handle Pointers in External Modules Support Functions</A><BR>
<UL>
<A HREF="#2.13.1.">2.13.1.   handle_GetHandle</A><BR>
<A HREF="#2.13.2.">2.13.2.   handle_GetPointer</A><BR>
<A HREF="#2.13.3.">2.13.3.   handle_FreeHandle</A><BR>
<A HREF="#2.13.4.">2.13.4.   handle_DestroyHandleArray</A><BR>
</UL>
<A HREF="#2.14.">2.14.   Thread Support Functions</A><BR>
<UL>
<A HREF="#2.14.1.">2.14.1.   thread_CreateThread</A><BR>
<A HREF="#2.14.2.">2.14.2.   thread_ExitThread</A><BR>
<A HREF="#2.14.3.">2.14.3.   thread_InitMutex</A><BR>
<A HREF="#2.14.4.">2.14.4.   thread_FinishMutex</A><BR>
<A HREF="#2.14.5.">2.14.5.   thread_LockMutex</A><BR>
<A HREF="#2.14.6.">2.14.6.   thread_UnlockMutex</A><BR>
<A HREF="#2.14.7.">2.14.7.   thread_shlckstry</A><BR>
<A HREF="#2.14.8.">2.14.8.   thread_InitLock</A><BR>
<A HREF="#2.14.9.">2.14.9.   thread_FinishLock</A><BR>
<A HREF="#2.14.10.">2.14.10.   thread_LockRead</A><BR>
<A HREF="#2.14.11.">2.14.11.   thread_LockWrite</A><BR>
<A HREF="#2.14.12.">2.14.12.   thread_UnlockRead</A><BR>
<A HREF="#2.14.13.">2.14.13.   thread_UnlockWrite</A><BR>
</UL>
<A HREF="#2.15.">2.15.   Dynamic Library Handling Support Functions</A><BR>
<UL>
<A HREF="#2.15.1.">2.15.1.   dynlolib_LoadLibrary</A><BR>
<A HREF="#2.15.2.">2.15.2.   dynlolib_FreeLibrary</A><BR>
<A HREF="#2.15.3.">2.15.3.   dynlolib_GetFunctionByName</A><BR>
</UL>
<A HREF="#2.16.">2.16.   Other System Dependant Functions</A><BR>
<UL>
<A HREF="#2.16.1.">2.16.1.   file_fopen</A><BR>
<A HREF="#2.16.2.">2.16.2.   file_fclose</A><BR>
<A HREF="#2.16.3.">2.16.3.   file_size</A><BR>
<A HREF="#2.16.4.">2.16.4.   file_time_accessed</A><BR>
<A HREF="#2.16.5.">2.16.5.   file_time_modified</A><BR>
<A HREF="#2.16.6.">2.16.6.   file_time_created</A><BR>
<A HREF="#2.16.7.">2.16.7.   file_isdir</A><BR>
<A HREF="#2.16.8.">2.16.8.   file_isreg</A><BR>
<A HREF="#2.16.9.">2.16.9.   file_exists</A><BR>
<A HREF="#2.16.10.">2.16.10.   file_truncate</A><BR>
<A HREF="#2.16.11.">2.16.11.   file_fgetc</A><BR>
<A HREF="#2.16.12.">2.16.12.   file_ferror</A><BR>
<A HREF="#2.16.13.">2.16.13.   file_fread</A><BR>
<A HREF="#2.16.14.">2.16.14.   file_fwrite</A><BR>
<A HREF="#2.16.15.">2.16.15.   file_fputc</A><BR>
<A HREF="#2.16.16.">2.16.16.   file_setmode</A><BR>
<A HREF="#2.16.17.">2.16.17.   file_binmode</A><BR>
<A HREF="#2.16.18.">2.16.18.   file_textmode</A><BR>
<A HREF="#2.16.19.">2.16.19.   file_flock</A><BR>
<A HREF="#2.16.20.">2.16.20.   file_lock</A><BR>
<A HREF="#2.16.21.">2.16.21.   file_feof</A><BR>
<A HREF="#2.16.22.">2.16.22.   file_mkdir</A><BR>
<A HREF="#2.16.23.">2.16.23.   file_rmdir</A><BR>
<A HREF="#2.16.24.">2.16.24.   file_remove</A><BR>
<A HREF="#2.16.25.">2.16.25.   file_deltree</A><BR>
<A HREF="#2.16.26.">2.16.26.   file_MakeDirectory</A><BR>
<A HREF="#2.16.27.">2.16.27.   file_opendir</A><BR>
<A HREF="#2.16.28.">2.16.28.   file_readdir</A><BR>
<A HREF="#2.16.29.">2.16.29.   file_closedir</A><BR>
<A HREF="#2.16.30.">2.16.30.   file_sleep</A><BR>
<A HREF="#2.16.31.">2.16.31.   file_curdir</A><BR>
<A HREF="#2.16.32.">2.16.32.   file_chdir</A><BR>
<A HREF="#2.16.33.">2.16.33.   file_chown</A><BR>
<A HREF="#2.16.34.">2.16.34.   file_getowner</A><BR>
<A HREF="#2.16.35.">2.16.35.   file_SetCreateTime</A><BR>
<A HREF="#2.16.36.">2.16.36.   file_SetModifyTime</A><BR>
<A HREF="#2.16.37.">2.16.37.   file_SetAccessTime</A><BR>
<A HREF="#2.16.38.">2.16.38.   file_gethostname</A><BR>
<A HREF="#2.16.39.">2.16.39.   file_gethost</A><BR>
<A HREF="#2.16.40.">2.16.40.   file_tcpconnect</A><BR>
<A HREF="#2.16.41.">2.16.41.   file_tcpsend</A><BR>
<A HREF="#2.16.42.">2.16.42.   file_tcprecv</A><BR>
<A HREF="#2.16.43.">2.16.43.   file_tcpclose</A><BR>
<A HREF="#2.16.44.">2.16.44.   file_killproc</A><BR>
<A HREF="#2.16.45.">2.16.45.   file_fcrypt</A><BR>
<A HREF="#2.16.46.">2.16.46.   file_CreateProcess</A><BR>
<A HREF="#2.16.47.">2.16.47.   file_CreateProcessEx</A><BR>
<A HREF="#2.16.48.">2.16.48.   file_waitpid</A><BR>
</UL>
<A HREF="#2.17.">2.17.   Module Management</A><BR>
<UL>
<A HREF="#2.17.1.">2.17.1.   modu_Init</A><BR>
<A HREF="#2.17.2.">2.17.2.   modu_Preload</A><BR>
<A HREF="#2.17.3.">2.17.3.   modu_GetModuleFunctionByName</A><BR>
<A HREF="#2.17.4.">2.17.4.   modu_GetStaticFunctionByName</A><BR>
<A HREF="#2.17.5.">2.17.5.   modu_LoadModule</A><BR>
<A HREF="#2.17.6.">2.17.6.   modu_GetFunctionByName</A><BR>
<A HREF="#2.17.7.">2.17.7.   modu_UnloadAllModules</A><BR>
<A HREF="#2.17.8.">2.17.8.   modu_UnloadModule</A><BR>
<A HREF="#2.17.9.">2.17.9.   modu_ShutdownModule</A><BR>
</UL>
<A HREF="#2.18.">2.18.   Run Time Options Handling</A><BR>
<UL>
<A HREF="#2.18.1.">2.18.1.   options_Reset</A><BR>
<A HREF="#2.18.2.">2.18.2.   options_Set</A><BR>
<A HREF="#2.18.3.">2.18.3.   options_Get</A><BR>
<A HREF="#2.18.4.">2.18.4.   options_GetR</A><BR>
</UL>
<A HREF="#2.19.">2.19.   Simple Pattern Matching</A><BR>
<UL>
<A HREF="#2.19.1.">2.19.1.   match_index</A><BR>
<A HREF="#2.19.2.">2.19.2.   InitSets</A><BR>
<A HREF="#2.19.3.">2.19.3.   ModifySet</A><BR>
<A HREF="#2.19.4.">2.19.4.   match</A><BR>
<A HREF="#2.19.5.">2.19.5.   count</A><BR>
<A HREF="#2.19.6.">2.19.6.   parameter</A><BR>
<A HREF="#2.19.7.">2.19.7.   size</A><BR>
</UL>
<A HREF="#2.20.">2.20.   Symbol Table Handling</A><BR>
<UL>
<A HREF="#2.20.1.">2.20.1.   sym_NewSymbolTable()</A><BR>
<A HREF="#2.20.2.">2.20.2.   sym_FreeSymbolTable()</A><BR>
<A HREF="#2.20.3.">2.20.3.   sym_TraverseSymbolTable()</A><BR>
<A HREF="#2.20.4.">2.20.4.   sym_LookupSymbol()</A><BR>
<A HREF="#2.20.5.">2.20.5.   sym_DeleteSymbol()</A><BR>
</UL>
</UL>
<A HREF="#3.">3.   Embedding the Interpreter</A><BR>
<UL>
<A HREF="#3.1.">3.1.   Object Oriented Model of ScriptBasic</A><BR>
<A HREF="#3.2.">3.2.   Sample Embedding</A><BR>
<UL>
<A HREF="#3.2.1.">3.2.1.   Include Header Files</A><BR>
<A HREF="#3.2.2.">3.2.2.   Function main(), Variable Declarations</A><BR>
<A HREF="#3.2.3.">3.2.3.   Command Line handling</A><BR>
<A HREF="#3.2.4.">3.2.4.   Creating Program Object</A><BR>
<A HREF="#3.2.5.">3.2.5.   Loading Configuration</A><BR>
<A HREF="#3.2.6.">3.2.6.   Loading Internal Preprocessors</A><BR>
<A HREF="#3.2.7.">3.2.7.   Setting the File Name</A><BR>
<A HREF="#3.2.8.">3.2.8.   Using the Cache</A><BR>
<A HREF="#3.2.9.">3.2.9.   Run External Preprocessors</A><BR>
<A HREF="#3.2.10.">3.2.10.   Loading the Source Program</A><BR>
<A HREF="#3.2.11.">3.2.11.   Saving Binary File</A><BR>
<A HREF="#3.2.12.">3.2.12.   Execute the BASIC Program</A><BR>
<A HREF="#3.2.13.">3.2.13.   Destroying the Program Object</A><BR>
</UL>
<A HREF="#3.3.">3.3.   ScriptBasic C API</A><BR>
<UL>
<A HREF="#3.3.1.">3.3.1.   scriba_new()</A><BR>
<A HREF="#3.3.2.">3.3.2.   scriba_destroy()</A><BR>
<A HREF="#3.3.3.">3.3.3.   scriba_NewSbData()</A><BR>
<A HREF="#3.3.4.">3.3.4.   scriba_InitSbData()</A><BR>
<A HREF="#3.3.5.">3.3.5.   scriba_UndefSbData()</A><BR>
<A HREF="#3.3.6.">3.3.6.   scriba_NewSbLong()</A><BR>
<A HREF="#3.3.7.">3.3.7.   scriba_NewSbDouble()</A><BR>
<A HREF="#3.3.8.">3.3.8.   scriba_NewSbUndef()</A><BR>
<A HREF="#3.3.9.">3.3.9.   scriba_NewSbString()</A><BR>
<A HREF="#3.3.10.">3.3.10.   scriba_NewSbBytes()</A><BR>
<A HREF="#3.3.11.">3.3.11.   scriba_DestroySbData()</A><BR>
<A HREF="#3.3.12.">3.3.12.   scriba_PurgeReaderMemory()</A><BR>
<A HREF="#3.3.13.">3.3.13.   scriba_PurgeLexerMemory()</A><BR>
<A HREF="#3.3.14.">3.3.14.   scriba_PurgeSyntaxerMemory()</A><BR>
<A HREF="#3.3.15.">3.3.15.   scriba_PurgeBuilderMemory()</A><BR>
<A HREF="#3.3.16.">3.3.16.   scriba_PurgePreprocessorMemory()</A><BR>
<A HREF="#3.3.17.">3.3.17.   scriba_PurgeExecuteMemory()</A><BR>
<A HREF="#3.3.18.">3.3.18.   scriba_SetFileName()</A><BR>
<A HREF="#3.3.19.">3.3.19.   scriba_GettingConfiguration()</A><BR>
<A HREF="#3.3.20.">3.3.20.   scriba_LoadConfiguration()</A><BR>
<A HREF="#3.3.21.">3.3.21.   scriba_GetConfigFileName()</A><BR>
<A HREF="#3.3.22.">3.3.22.   scriba_InheritConfiguration()</A><BR>
<A HREF="#3.3.23.">3.3.23.   scriba_InitModuleInterface()</A><BR>
<A HREF="#3.3.24.">3.3.24.   scriba_InheritModuleInterface()</A><BR>
<A HREF="#3.3.25.">3.3.25.   scriba_InheritExecuteObject()</A><BR>
<A HREF="#3.3.26.">3.3.26.   scriba_SetProcessSbObject()</A><BR>
<A HREF="#3.3.27.">3.3.27.   scriba_ShutdownMtModules()</A><BR>
<A HREF="#3.3.28.">3.3.28.   scriba_SetCgiFlag()</A><BR>
<A HREF="#3.3.29.">3.3.29.   scriba_SetReportFunction()</A><BR>
<A HREF="#3.3.30.">3.3.30.   scriba_SetReportPointer()</A><BR>
<A HREF="#3.3.31.">3.3.31.   scriba_SetStdin()</A><BR>
<A HREF="#3.3.32.">3.3.32.   scriba_SetStdout()</A><BR>
<A HREF="#3.3.33.">3.3.33.   scriba_SetEmbedPointer()</A><BR>
<A HREF="#3.3.34.">3.3.34.   scriba_SetEnvironment()</A><BR>
<A HREF="#3.3.35.">3.3.35.   scriba_LoadBinaryProgramWithOffset()</A><BR>
<A HREF="#3.3.36.">3.3.36.   scriba_LoadBinaryProgram()</A><BR>
<A HREF="#3.3.37.">3.3.37.   scriba_InheritBinaryProgram()</A><BR>
<A HREF="#3.3.38.">3.3.38.   scriba_LoadInternalPreprocessor()</A><BR>
<A HREF="#3.3.39.">3.3.39.   scriba_ReadSource()</A><BR>
<A HREF="#3.3.40.">3.3.40.   scriba_DoLexicalAnalysis()</A><BR>
<A HREF="#3.3.41.">3.3.41.   scriba_DoSyntaxAnalysis()</A><BR>
<A HREF="#3.3.42.">3.3.42.   scriba_BuildCode()</A><BR>
<A HREF="#3.3.43.">3.3.43.   scriba_IsFileBinaryFormat()</A><BR>
<A HREF="#3.3.44.">3.3.44.   scriba_GetCacheFileName()</A><BR>
<A HREF="#3.3.45.">3.3.45.   scriba_UseCacheFile()</A><BR>
<A HREF="#3.3.46.">3.3.46.   scriba_SaveCacheFile()</A><BR>
<A HREF="#3.3.47.">3.3.47.   scriba_RunExternalPreprocessor()</A><BR>
<A HREF="#3.3.48.">3.3.48.   scriba_SaveCode()</A><BR>
<A HREF="#3.3.49.">3.3.49.   scriba_SaveCCode()</A><BR>
<A HREF="#3.3.50.">3.3.50.   scriba_SaveECode()</A><BR>
<A HREF="#3.3.51.">3.3.51.   scriba_LoadSourceProgram()</A><BR>
<A HREF="#3.3.52.">3.3.52.   scriba_LoadProgramString()</A><BR>
<A HREF="#3.3.53.">3.3.53.   scriba_Run()</A><BR>
<A HREF="#3.3.54.">3.3.54.   scriba_NoRun()</A><BR>
<A HREF="#3.3.55.">3.3.55.   scriba_ResetVariables()</A><BR>
<A HREF="#3.3.56.">3.3.56.   scriba_Call()</A><BR>
<A HREF="#3.3.57.">3.3.57.   scriba_CallArg()</A><BR>
<A HREF="#3.3.58.">3.3.58.   scriba_DestroySbArgs()</A><BR>
<A HREF="#3.3.59.">3.3.59.   scriba_NewSbArgs()</A><BR>
<A HREF="#3.3.60.">3.3.60.   scriba_CallArgEx()</A><BR>
<A HREF="#3.3.61.">3.3.61.   scriba_LookupFunctionByName()</A><BR>
<A HREF="#3.3.62.">3.3.62.   scriba_LookupVariableByName()</A><BR>
<A HREF="#3.3.63.">3.3.63.   scriba_GetVariableType()</A><BR>
<A HREF="#3.3.64.">3.3.64.   scriba_GetVariable()</A><BR>
<A HREF="#3.3.65.">3.3.65.   scriba_SetVariable()</A><BR>
<A HREF="#3.3.66.">3.3.66.   scriba_InitStaticModules()</A><BR>
<A HREF="#3.3.67.">3.3.67.   scriba_FinishStaticModules()</A><BR>
</UL>
</UL>
<A HREF="#4.">4.   Extension Modules</A><BR>
<UL>
<A HREF="#4.1.">4.1.   How Extension Modules are Used</A><BR>
<A HREF="#4.2.">4.2.   A Simple Sample Module</A><BR>
<A HREF="#4.3.">4.3.   Compiling a Module</A><BR>
<A HREF="#4.4.">4.4.   Installing a Module</A><BR>
<A HREF="#4.5.">4.5.   Module Support Functions</A><BR>
<UL>
<A HREF="#4.5.1.">4.5.1.   Basic Extension Support functions, structures and macros</A><BR>
<A HREF="#4.5.2.">4.5.2.   besALLOC(X)</A><BR>
<A HREF="#4.5.3.">4.5.3.   besPROCALLOC(X)</A><BR>
<A HREF="#4.5.4.">4.5.4.   besFREE(X)</A><BR>
<A HREF="#4.5.5.">4.5.5.   besPROCFREE(X)</A><BR>
<A HREF="#4.5.6.">4.5.6.   besPROCMEMORYSEGMENT</A><BR>
<A HREF="#4.5.7.">4.5.7.   besNEWMORTALSTRING(X)</A><BR>
<A HREF="#4.5.8.">4.5.8.   besNEWMORTALLONG</A><BR>
<A HREF="#4.5.9.">4.5.9.   besNEWMORTALREF</A><BR>
<A HREF="#4.5.10.">4.5.10.   besNEWMORTALDOUBLE</A><BR>
<A HREF="#4.5.11.">4.5.11.   besNEWMORTALARRAY(X,Y)</A><BR>
<A HREF="#4.5.12.">4.5.12.   besNEWSTRING(X)</A><BR>
<A HREF="#4.5.13.">4.5.13.   besNEWLONG</A><BR>
<A HREF="#4.5.14.">4.5.14.   besNEWREF</A><BR>
<A HREF="#4.5.15.">4.5.15.   besNEWDOUBLE</A><BR>
<A HREF="#4.5.16.">4.5.16.   besNEWARRAY(X,Y)</A><BR>
<A HREF="#4.5.17.">4.5.17.   besRELEASE(X)</A><BR>
<A HREF="#4.5.18.">4.5.18.   besSETREF(VAR,VAL)</A><BR>
<A HREF="#4.5.19.">4.5.19.   besCONFIG(X)</A><BR>
<A HREF="#4.5.20.">4.5.20.   besCONFIGFINDNODE(X,Y,Z)</A><BR>
<A HREF="#4.5.21.">4.5.21.   besCONFIGEX(CT,CS,NS,CSS,LS,DS,IS)</A><BR>
<A HREF="#4.5.22.">4.5.22.   besCONFIGENUMFIRST(X,Y)</A><BR>
<A HREF="#4.5.23.">4.5.23.   besCONFIGENUMNEXT(X,Y)</A><BR>
<A HREF="#4.5.24.">4.5.24.   besCONFIGGETKEY(X,Y)</A><BR>
<A HREF="#4.5.25.">4.5.25.   besNEWSYMBOLTABLE</A><BR>
<A HREF="#4.5.26.">4.5.26.   besFREESYMBOLTABLE(X)</A><BR>
<A HREF="#4.5.27.">4.5.27.   besTRAVERSESYMBOLTABLE(X,Y,Z)</A><BR>
<A HREF="#4.5.28.">4.5.28.   besLOOKUPSYMBOL(X,Y,Z)</A><BR>
<A HREF="#4.5.29.">4.5.29.   besDeleteSymbol(X,Y,Z)</A><BR>
<A HREF="#4.5.30.">4.5.30.   besLOADLIBRARY(X)</A><BR>
<A HREF="#4.5.31.">4.5.31.   besFREELIBRARY(X)</A><BR>
<A HREF="#4.5.32.">4.5.32.   besGETFUNCTIONBYNAME(X)</A><BR>
<A HREF="#4.5.33.">4.5.33.   besFOPEN</A><BR>
<A HREF="#4.5.34.">4.5.34.   besFCLOSE</A><BR>
<A HREF="#4.5.35.">4.5.35.   besSIZE</A><BR>
<A HREF="#4.5.36.">4.5.36.   besTIME_ACCESSED</A><BR>
<A HREF="#4.5.37.">4.5.37.   besTIME_MODIFIED</A><BR>
<A HREF="#4.5.38.">4.5.38.   besTIME_CREATED</A><BR>
<A HREF="#4.5.39.">4.5.39.   besISDIR</A><BR>
<A HREF="#4.5.40.">4.5.40.   besISREG</A><BR>
<A HREF="#4.5.41.">4.5.41.   besEXISTS</A><BR>
<A HREF="#4.5.42.">4.5.42.   besTRUNCATE</A><BR>
<A HREF="#4.5.43.">4.5.43.   besFGETC</A><BR>
<A HREF="#4.5.44.">4.5.44.   besFREAD</A><BR>
<A HREF="#4.5.45.">4.5.45.   besFWRITE</A><BR>
<A HREF="#4.5.46.">4.5.46.   besSETMODE</A><BR>
<A HREF="#4.5.47.">4.5.47.   besBINMODE</A><BR>
<A HREF="#4.5.48.">4.5.48.   besTEXTMODE</A><BR>
<A HREF="#4.5.49.">4.5.49.   besFERROR</A><BR>
<A HREF="#4.5.50.">4.5.50.   besFPUTC</A><BR>
<A HREF="#4.5.51.">4.5.51.   besFLOCK</A><BR>
<A HREF="#4.5.52.">4.5.52.   besLOCK</A><BR>
<A HREF="#4.5.53.">4.5.53.   besFEOF</A><BR>
<A HREF="#4.5.54.">4.5.54.   besMKDIR</A><BR>
<A HREF="#4.5.55.">4.5.55.   besRMDIR</A><BR>
<A HREF="#4.5.56.">4.5.56.   besREMOVE</A><BR>
<A HREF="#4.5.57.">4.5.57.   besDELTREE</A><BR>
<A HREF="#4.5.58.">4.5.58.   besMAKEDIRECTORY</A><BR>
<A HREF="#4.5.59.">4.5.59.   besOPENDIR</A><BR>
<A HREF="#4.5.60.">4.5.60.   besREADDIR</A><BR>
<A HREF="#4.5.61.">4.5.61.   besCLOSEDIR</A><BR>
<A HREF="#4.5.62.">4.5.62.   besOPTION(X)</A><BR>
<A HREF="#4.5.63.">4.5.63.   besSETOPTION(x,y)</A><BR>
<A HREF="#4.5.64.">4.5.64.   besRESETOPTION(X)</A><BR>
<A HREF="#4.5.65.">4.5.65.   besCONVERT2STRING(x)</A><BR>
<A HREF="#4.5.66.">4.5.66.   besCONVERT2LONG(x)</A><BR>
<A HREF="#4.5.67.">4.5.67.   besGETLONGVALUE(x)</A><BR>
<A HREF="#4.5.68.">4.5.68.   besCONVERT2DOUBLE(x)</A><BR>
<A HREF="#4.5.69.">4.5.69.   besGETDOUBLEVALUE(x)</A><BR>
<A HREF="#4.5.70.">4.5.70.   besISSTRINGINTEGER(x)</A><BR>
<A HREF="#4.5.71.">4.5.71.   besCONVERT2ZCHAR(x)</A><BR>
<A HREF="#4.5.72.">4.5.72.   besREINITINTERFACE</A><BR>
<A HREF="#4.5.73.">4.5.73.   besLOADMODULE(x,y)</A><BR>
<A HREF="#4.5.74.">4.5.74.   besGETMODULEFUNCTIONBYNAME</A><BR>
<A HREF="#4.5.75.">4.5.75.   besUNLOADALLMODULES</A><BR>
<A HREF="#4.5.76.">4.5.76.   besUNLOADMODULE(x)</A><BR>
<A HREF="#4.5.77.">4.5.77.   besSLEEP(x)</A><BR>
<A HREF="#4.5.78.">4.5.78.   besCURDIR(x,y)</A><BR>
<A HREF="#4.5.79.">4.5.79.   besCHDIR(x)</A><BR>
<A HREF="#4.5.80.">4.5.80.   besCHOWN(x,y)</A><BR>
<A HREF="#4.5.81.">4.5.81.   besSETCREATETIME(x,y)</A><BR>
<A HREF="#4.5.82.">4.5.82.   besSETMODIFYTIME(x,y)</A><BR>
<A HREF="#4.5.83.">4.5.83.   besSETACCESSTIME(x,y)</A><BR>
<A HREF="#4.5.84.">4.5.84.   besGETHOSTNAME(x,y)</A><BR>
<A HREF="#4.5.85.">4.5.85.   besGETHOST(x,y)</A><BR>
<A HREF="#4.5.86.">4.5.86.   besTCPCONNECT(x,y)</A><BR>
<A HREF="#4.5.87.">4.5.87.   besTCPSEND(x,y,z)</A><BR>
<A HREF="#4.5.88.">4.5.88.   besTCPRECV(x,y,z)</A><BR>
<A HREF="#4.5.89.">4.5.89.   besTCPCLOSE(y)</A><BR>
<A HREF="#4.5.90.">4.5.90.   besKILLPROC(x)</A><BR>
<A HREF="#4.5.91.">4.5.91.   besGETOWNER(x,y,z)</A><BR>
<A HREF="#4.5.92.">4.5.92.   besCRYPT(x,y,z)</A><BR>
<A HREF="#4.5.93.">4.5.93.   besMD5INIT(C)</A><BR>
<A HREF="#4.5.94.">4.5.94.   besMD5UPDATE(C,I,L)</A><BR>
<A HREF="#4.5.95.">4.5.95.   besMD5FINAL(D,C)</A><BR>
<A HREF="#4.5.96.">4.5.96.   besCREATEPROCESS(X)</A><BR>
<A HREF="#4.5.97.">4.5.97.   besCOPYCOMMANDTABLE(X)</A><BR>
<A HREF="#4.5.98.">4.5.98.   besGETCOMMANDBYNAME(X,Y)</A><BR>
<A HREF="#4.5.99.">4.5.99.   besEVALUATEEXPRESSION(X)</A><BR>
<A HREF="#4.5.100.">4.5.100.   _besEVALUATEEXPRESSION(X)</A><BR>
<A HREF="#4.5.101.">4.5.101.   _besEVALUATEEXPRESSION_A(X)</A><BR>
<A HREF="#4.5.102.">4.5.102.   besEVALUATELEFTVALUE(X)</A><BR>
<A HREF="#4.5.103.">4.5.103.   besEVALUATELEFTVALUE_A(X)</A><BR>
<A HREF="#4.5.104.">4.5.104.   besIMMORTALIZE(x)</A><BR>
<A HREF="#4.5.105.">4.5.105.   besDEREFERENCE(X)</A><BR>
<A HREF="#4.5.106.">4.5.106.   besMatchIndex(X)</A><BR>
<A HREF="#4.5.107.">4.5.107.   besMatchIniSets(X)</A><BR>
<A HREF="#4.5.108.">4.5.108.   besMatchModifySet(X,Y,Z,W,Q)</A><BR>
<A HREF="#4.5.109.">4.5.109.   besMatchMatch(P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12)</A><BR>
<A HREF="#4.5.110.">4.5.110.   besMatchCount(X,Y)</A><BR>
<A HREF="#4.5.111.">4.5.111.   besMatchParameter(P1,P2,P3,P4,P5,P6,P7)</A><BR>
<A HREF="#4.5.112.">4.5.112.   besMatchSize(P1,P2,P3,P4,P5)</A><BR>
<A HREF="#4.5.113.">4.5.113.   besCreateThread(X,Y,Z)</A><BR>
<A HREF="#4.5.114.">4.5.114.   besExitThread</A><BR>
<A HREF="#4.5.115.">4.5.115.   besInitMutex(X)</A><BR>
<A HREF="#4.5.116.">4.5.116.   besFinishMutex(X)</A><BR>
<A HREF="#4.5.117.">4.5.117.   besLockMutex(X)</A><BR>
<A HREF="#4.5.118.">4.5.118.   besUnlockMutex(X)</A><BR>
<A HREF="#4.5.119.">4.5.119.   besInitSharedLock(X)</A><BR>
<A HREF="#4.5.120.">4.5.120.   besFinishSharedLock(X)</A><BR>
<A HREF="#4.5.121.">4.5.121.   besLockSharedRead(X)</A><BR>
<A HREF="#4.5.122.">4.5.122.   besLockSharedWrite(X)</A><BR>
<A HREF="#4.5.123.">4.5.123.   besUnlockSharedRead(X)</A><BR>
<A HREF="#4.5.124.">4.5.124.   besUnlockSharedWrite(X)</A><BR>
<A HREF="#4.5.125.">4.5.125.   besScribaNew(F0,F1)</A><BR>
<A HREF="#4.5.126.">4.5.126.   besScribaDestroy(F0)</A><BR>
<A HREF="#4.5.127.">4.5.127.   besScribaNewSbData(F0)</A><BR>
<A HREF="#4.5.128.">4.5.128.   besScribaNewSbLong(F0,F1)</A><BR>
<A HREF="#4.5.129.">4.5.129.   besScribaNewSbDouble(F0,F1)</A><BR>
<A HREF="#4.5.130.">4.5.130.   besScribaNewSbUndef(F0)</A><BR>
<A HREF="#4.5.131.">4.5.131.   besScribaNewSbString(F0,F1)</A><BR>
<A HREF="#4.5.132.">4.5.132.   besScribaNewSbBytes(F0,F1,F2)</A><BR>
<A HREF="#4.5.133.">4.5.133.   besScribaDestroySbData(F0,F1)</A><BR>
<A HREF="#4.5.134.">4.5.134.   besScribaPurgeReaderMemory(F0)</A><BR>
<A HREF="#4.5.135.">4.5.135.   besScribaPurgeLexerMemory(F0)</A><BR>
<A HREF="#4.5.136.">4.5.136.   besScribaPurgeSyntaxerMemory(F0)</A><BR>
<A HREF="#4.5.137.">4.5.137.   besScribaPurgeBuilderMemory(F0)</A><BR>
<A HREF="#4.5.138.">4.5.138.   besScribaPurgeExecuteMemory(F0)</A><BR>
<A HREF="#4.5.139.">4.5.139.   besScribaSetFileName(F0,F1)</A><BR>
<A HREF="#4.5.140.">4.5.140.   besScribaLoadConfiguration(F0,F1)</A><BR>
<A HREF="#4.5.141.">4.5.141.   besScribaInheritConfiguration(F0,F1)</A><BR>
<A HREF="#4.5.142.">4.5.142.   besScribaSetCgiFlag(F0)</A><BR>
<A HREF="#4.5.143.">4.5.143.   besScribaSetReportFunction(F0,F1)</A><BR>
<A HREF="#4.5.144.">4.5.144.   besScribaSetReportPointer(F0,F1)</A><BR>
<A HREF="#4.5.145.">4.5.145.   besScribaSetStdin(F0,F1)</A><BR>
<A HREF="#4.5.146.">4.5.146.   besScribaSetStdout(F0,F1)</A><BR>
<A HREF="#4.5.147.">4.5.147.   besScribaSetEmbedPointer(F0,F1)</A><BR>
<A HREF="#4.5.148.">4.5.148.   besScribaSetEnvironment(F0,F1)</A><BR>
<A HREF="#4.5.149.">4.5.149.   besScribaLoadBinaryProgram(F0)</A><BR>
<A HREF="#4.5.150.">4.5.150.   besScribaInheritBinaryProgram(F0,F1)</A><BR>
<A HREF="#4.5.151.">4.5.151.   besScribaReadSource(F0)</A><BR>
<A HREF="#4.5.152.">4.5.152.   besScribaDoLexicalAnalysis(F0)</A><BR>
<A HREF="#4.5.153.">4.5.153.   besScribaDoSyntaxAnalysis(F0)</A><BR>
<A HREF="#4.5.154.">4.5.154.   besScribaBuildCode(F0)</A><BR>
<A HREF="#4.5.155.">4.5.155.   besScribaIsFileBinaryFormat(F0)</A><BR>
<A HREF="#4.5.156.">4.5.156.   besScribaGetCacheFileName(F0)</A><BR>
<A HREF="#4.5.157.">4.5.157.   besScribaUseCacheFile(F0)</A><BR>
<A HREF="#4.5.158.">4.5.158.   besScribaSaveCacheFile(F0)</A><BR>
<A HREF="#4.5.159.">4.5.159.   besScribaRunExternalPreprocessor(F0,F1)</A><BR>
<A HREF="#4.5.160.">4.5.160.   besScribaSaveCode(F0,F1)</A><BR>
<A HREF="#4.5.161.">4.5.161.   besScribaSaveCCode(F0,F1)</A><BR>
<A HREF="#4.5.162.">4.5.162.   besScribaLoadSourceProgram(F0)</A><BR>
<A HREF="#4.5.163.">4.5.163.   besScribaRun(F0,F1)</A><BR>
<A HREF="#4.5.164.">4.5.164.   besScribaNoRun(F0)</A><BR>
<A HREF="#4.5.165.">4.5.165.   besScribaResetVariables(F0)</A><BR>
<A HREF="#4.5.166.">4.5.166.   besScribaCall(F0,F1)</A><BR>
<A HREF="#4.5.167.">4.5.167.   besScribaCallArg(F0,F1,F2,F3)</A><BR>
<A HREF="#4.5.168.">4.5.168.   besScribaDestroySbArgs(F0,F1,F2)</A><BR>
<A HREF="#4.5.169.">4.5.169.   besScribaNewSbArgs(F0,F1,F2)</A><BR>
<A HREF="#4.5.170.">4.5.170.   besScribaCallArgEx(F0,F1,F2,F3,F4)</A><BR>
<A HREF="#4.5.171.">4.5.171.   besScribaLookupFunctionByName(F0,F1)</A><BR>
<A HREF="#4.5.172.">4.5.172.   besScribaLookupVariableByName(F0,F1)</A><BR>
<A HREF="#4.5.173.">4.5.173.   besScribaGetVariableType(F0,F1)</A><BR>
<A HREF="#4.5.174.">4.5.174.   besScribaGetVariable(F0,F1,F2)</A><BR>
<A HREF="#4.5.175.">4.5.175.   besScribaSetVariable(F0,F1,F2,F3,F4,F5,F6)</A><BR>
<A HREF="#4.5.176.">4.5.176.   besLogState(X)</A><BR>
<A HREF="#4.5.177.">4.5.177.   besLogInit(F0,F1,F2,F3,F4,F5)</A><BR>
<A HREF="#4.5.178.">4.5.178.   besLogPrintf(pLOG,FORMAT, ...)</A><BR>
<A HREF="#4.5.179.">4.5.179.   besLogShutdown(pLOG)</A><BR>
<A HREF="#4.5.180.">4.5.180.   besHandleGetHandle(X,Y)</A><BR>
<A HREF="#4.5.181.">4.5.181.   besHandleGetPointer(X,Y)</A><BR>
<A HREF="#4.5.182.">4.5.182.   besHandleFreeHandle(X,Y)</A><BR>
<A HREF="#4.5.183.">4.5.183.   besHandleDestroyHandleArray(X)</A><BR>
<A HREF="#4.5.184.">4.5.184.   besINIT_SEGMENT(MAF,MRF)</A><BR>
<A HREF="#4.5.185.">4.5.185.   besSEGMENT_LIMIT(PMS,L)</A><BR>
<A HREF="#4.5.186.">4.5.186.   besFREE_SEGMENT(PMS)</A><BR>
<A HREF="#4.5.187.">4.5.187.   besFINISH_SEGMENT(PMS)</A><BR>
<A HREF="#4.5.188.">4.5.188.   besFUNCTION(X)</A><BR>
<A HREF="#4.5.189.">4.5.189.   besASSERT_FUNCTION</A><BR>
<A HREF="#4.5.190.">4.5.190.   besCOMMAND(X)</A><BR>
<A HREF="#4.5.191.">4.5.191.   besASSERT_COMMAND</A><BR>
<A HREF="#4.5.192.">4.5.192.   besEND_COMMAND</A><BR>
<A HREF="#4.5.193.">4.5.193.   besARGNR</A><BR>
<A HREF="#4.5.194.">4.5.194.   besARGUMENT(X)</A><BR>
<A HREF="#4.5.195.">4.5.195.   besPARAMETERLIST</A><BR>
<A HREF="#4.5.196.">4.5.196.   besLEFTVALUE(X,Y)</A><BR>
<A HREF="#4.5.197.">4.5.197.   besVERSION_NEGOTIATE</A><BR>
<A HREF="#4.5.198.">4.5.198.   besSUB_START</A><BR>
<A HREF="#4.5.199.">4.5.199.   besSUB_FINISH</A><BR>
<A HREF="#4.5.200.">4.5.200.   besSUB_ERRMSG</A><BR>
<A HREF="#4.5.201.">4.5.201.   besSUB_PROCESS_START</A><BR>
<A HREF="#4.5.202.">4.5.202.   besSUB_PROCESS_FINISH</A><BR>
<A HREF="#4.5.203.">4.5.203.   besSUB_KEEP</A><BR>
<A HREF="#4.5.204.">4.5.204.   besSUB_SHUTDOWN</A><BR>
<A HREF="#4.5.205.">4.5.205.   besSUB_AUTO</A><BR>
<A HREF="#4.5.206.">4.5.206.   besEND</A><BR>
<A HREF="#4.5.207.">4.5.207.   besRETURNVALUE</A><BR>
<A HREF="#4.5.208.">4.5.208.   besMODULEPOINTER</A><BR>
<A HREF="#4.5.209.">4.5.209.   besALLOC_RETURN_STRING(X)</A><BR>
<A HREF="#4.5.210.">4.5.210.   besALLOC_RETURN_POINTER</A><BR>
<A HREF="#4.5.211.">4.5.211.   besALLOC_RETURN_LONG</A><BR>
<A HREF="#4.5.212.">4.5.212.   besALLOC_RETURN_DOUBLE</A><BR>
<A HREF="#4.5.213.">4.5.213.   besRETURN_STRING(X)</A><BR>
<A HREF="#4.5.214.">4.5.214.   besSET_RETURN_STRING(X)</A><BR>
<A HREF="#4.5.215.">4.5.215.   besRETURN_MEM(X,Y)</A><BR>
<A HREF="#4.5.216.">4.5.216.   besRETURN_POINTER(X)</A><BR>
<A HREF="#4.5.217.">4.5.217.   besRETURN_LONG(X)</A><BR>
<A HREF="#4.5.218.">4.5.218.   besRETURN_DOUBLE</A><BR>
<A HREF="#4.5.219.">4.5.219.   besSETCOMMAND(X,Y)</A><BR>
<A HREF="#4.5.220.">4.5.220.   besGETCOMMAND(X)</A><BR>
<A HREF="#4.5.221.">4.5.221.   INTERFACE_VERSION</A><BR>
<A HREF="#4.5.222.">4.5.222.   besHOOK_FILE_ACCESS</A><BR>
<A HREF="#4.5.223.">4.5.223.   besHOOK_FOPEN</A><BR>
<A HREF="#4.5.224.">4.5.224.   besHOOK_FCLOSE</A><BR>
<A HREF="#4.5.225.">4.5.225.   besHOOK_SIZE</A><BR>
<A HREF="#4.5.226.">4.5.226.   besHOOK_TIME_ACCESSED</A><BR>
<A HREF="#4.5.227.">4.5.227.   besHOOK_TIME_MODIFIED</A><BR>
<A HREF="#4.5.228.">4.5.228.   besHOOK_TIME_CREATED</A><BR>
<A HREF="#4.5.229.">4.5.229.   besHOOK_ISDIR</A><BR>
<A HREF="#4.5.230.">4.5.230.   besHOOK_ISREG</A><BR>
<A HREF="#4.5.231.">4.5.231.   besHOOK_EXISTS</A><BR>
<A HREF="#4.5.232.">4.5.232.   besHOOK_TRUNCATE</A><BR>
<A HREF="#4.5.233.">4.5.233.   besHOOK_FGETC</A><BR>
<A HREF="#4.5.234.">4.5.234.   besHOOK_FREAD</A><BR>
<A HREF="#4.5.235.">4.5.235.   besHOOK_FWRITE</A><BR>
<A HREF="#4.5.236.">4.5.236.   besHOOK_FERROR</A><BR>
<A HREF="#4.5.237.">4.5.237.   besHOOK_PUTC</A><BR>
<A HREF="#4.5.238.">4.5.238.   besHOOK_FLOCK</A><BR>
<A HREF="#4.5.239.">4.5.239.   besHOOK_LOCK</A><BR>
<A HREF="#4.5.240.">4.5.240.   besHOOK_FEOF</A><BR>
<A HREF="#4.5.241.">4.5.241.   besHOOK_MKDIR</A><BR>
<A HREF="#4.5.242.">4.5.242.   besHOOK_RMDIR</A><BR>
<A HREF="#4.5.243.">4.5.243.   besHOOK_REMOVE</A><BR>
<A HREF="#4.5.244.">4.5.244.   besHOOK_DELTREE</A><BR>
<A HREF="#4.5.245.">4.5.245.   besHOOK_MAKEDIRECTORY</A><BR>
<A HREF="#4.5.246.">4.5.246.   besHOOK_OPENDIR</A><BR>
<A HREF="#4.5.247.">4.5.247.   besHOOK_READDIR</A><BR>
<A HREF="#4.5.248.">4.5.248.   besHOOK_CLOSEDIR</A><BR>
<A HREF="#4.5.249.">4.5.249.   besHOOK_SLEEP</A><BR>
<A HREF="#4.5.250.">4.5.250.   besHOOK_CURDIR</A><BR>
<A HREF="#4.5.251.">4.5.251.   besHOOK_CHDIR</A><BR>
<A HREF="#4.5.252.">4.5.252.   besHOOK_CHOWN</A><BR>
<A HREF="#4.5.253.">4.5.253.   besHOOK_SETCREATETIME</A><BR>
<A HREF="#4.5.254.">4.5.254.   besHOOK_SETMODIFYTIME</A><BR>
<A HREF="#4.5.255.">4.5.255.   besHOOK_SETACCESSTIME</A><BR>
<A HREF="#4.5.256.">4.5.256.   besHOOK_GETHOSTNAME</A><BR>
<A HREF="#4.5.257.">4.5.257.   besHOOK_GETHOST</A><BR>
<A HREF="#4.5.258.">4.5.258.   besHOOK_TCPCONNECT</A><BR>
<A HREF="#4.5.259.">4.5.259.   besHOOK_TCPSEND</A><BR>
<A HREF="#4.5.260.">4.5.260.   besHOOK_TCPRECV</A><BR>
<A HREF="#4.5.261.">4.5.261.   besHOOK_TCPCLOSE</A><BR>
<A HREF="#4.5.262.">4.5.262.   besHOOK_KILLPROC</A><BR>
<A HREF="#4.5.263.">4.5.263.   besHOOK_GETOWNER</A><BR>
<A HREF="#4.5.264.">4.5.264.   besHOOK_CREATEPROCESS</A><BR>
<A HREF="#4.5.265.">4.5.265.   besHOOK_CALLSCRIBAFUNCTION</A><BR>
<A HREF="#4.5.266.">4.5.266.   besSETHOOK(X,Y)</A><BR>
<A HREF="#4.5.267.">4.5.267.   besDLL_MAIN</A><BR>
<A HREF="#4.5.268.">4.5.268.   INITLOCK</A><BR>
<A HREF="#4.5.269.">4.5.269.   basext_GetArgsF()</A><BR>
</UL>
</UL>
<A HREF="#5.">5.   Preprocessors</A><BR>
<UL>
<A HREF="#5.1.">5.1.   Loading Preprocessor</A><BR>
<A HREF="#5.2.">5.2.   Skeleton of a Preprocessor</A><BR>
<A HREF="#5.3.">5.3.   Preprocessor Entry Points</A><BR>
<UL>
<A HREF="#5.3.1.">5.3.1.   PreprocessorLoad</A><BR>
<A HREF="#5.3.2.">5.3.2.   PreprocessorReadStart</A><BR>
<A HREF="#5.3.3.">5.3.3.   PreprocessorReadDone0</A><BR>
<A HREF="#5.3.4.">5.3.4.   PreprocessorReadDone1</A><BR>
<A HREF="#5.3.5.">5.3.5.   PreprocessorReadDone2</A><BR>
<A HREF="#5.3.6.">5.3.6.   PreprocessorReadDone3</A><BR>
<A HREF="#5.3.7.">5.3.7.   PreprocessorLexInit</A><BR>
<A HREF="#5.3.8.">5.3.8.   PreprocessorLexDone</A><BR>
<A HREF="#5.3.9.">5.3.9.   PreprocessorLexNASymbol</A><BR>
<A HREF="#5.3.10.">5.3.10.   PreprocessorLexASymbol</A><BR>
<A HREF="#5.3.11.">5.3.11.   PreprocessorLexSymbol</A><BR>
<A HREF="#5.3.12.">5.3.12.   PreprocessorLexString</A><BR>
<A HREF="#5.3.13.">5.3.13.   PreprocessorLexMString</A><BR>
<A HREF="#5.3.14.">5.3.14.   PreprocessorLexInteger</A><BR>
<A HREF="#5.3.15.">5.3.15.   PreprocessorLexReal</A><BR>
<A HREF="#5.3.16.">5.3.16.   PreprocessorLexCharacter</A><BR>
<A HREF="#5.3.17.">5.3.17.   PreprocessorExStart</A><BR>
<A HREF="#5.3.18.">5.3.18.   PreprocessorExStartLine</A><BR>
<A HREF="#5.3.19.">5.3.19.   PreprocessorExEnd</A><BR>
<A HREF="#5.3.20.">5.3.20.   PreprocessorExFinish</A><BR>
<A HREF="#5.3.21.">5.3.21.   PreprocessorExStartLocal</A><BR>
<A HREF="#5.3.22.">5.3.22.   PreprocessorExEndLocal</A><BR>
<A HREF="#5.3.23.">5.3.23.   PreprocessorExLineNode</A><BR>
<A HREF="#5.3.24.">5.3.24.   PreprocessorExeStart</A><BR>
<A HREF="#5.3.25.">5.3.25.   PreprocessorExeFinish</A><BR>
<A HREF="#5.3.26.">5.3.26.   PreprocessorExeNoRun</A><BR>
</UL>
</UL>
<A HREF="#6.">6.   Compilation</A><BR>
<UL>
<A HREF="#6.1.">6.1.   Compilation under UNIX</A><BR>
</UL>
</UL>
<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="1."><H1>1. Introduction</H1></A>

<P>
ScriptBasic is an open source scripting implementation of the programming language BASIC. The language and the implementation make the software a considerable choice in many cases when there is a need for some scripting tool. This software can be used where traditionally Perl, Python, TCL or some other scripting interpreter is used.
<P>
The language itself is BASIC with powerful command set and large number of extension modules. The language was designed so that this is familiar for all BASIC programmers no matter which dialect one has experience with. Thus the learning curve of the language is very steep: you can start to write your first programs just in few minutes.
<P>
The interpreter is built modular, well documented, and easy to read source code and has well defined and documented interfaces. It is easy to embed the interpreter into an application and it is also easy to write external modules extending the language. Applications embedding ScriptBasic can build virtual machines in multiple or in single process running interpreters simultaneously independent of each other, but they can also execute multi-thread applications running interpreter threads that provide features for the BASIC programs running parallel to communicate to each other.
<P>
This means that ScriptBasic can be the language of choice in situations when the application programmer wants to implement some programmability feature into the application. It will attract the users of the application because there is no need to learn a new programming language at the time when they have to learn the functions of the application anyway. The programmer on the other hand has an easy job to integrate ScriptBasic into the application because it was designed for the purpose.
<P>
To sum up these in a listing the language and the implementation has the following features:
 
<UL>
<P>
<LI>
IT IS BASIC. No question, this is the MOST important feature of ScriptBasic. 
There are a lot of people who can program BASIC and only BASIC. There are many people, who can not really program. Those who do not really know what programming is, and still: they write their five-liners in BASIC to solve their simple problems. They never write Perl, Tcl, Java or C. Therefore it is BASIC.
<P>
<LI>
SCRIPTING language. There are no data types in the language. You can store real numbers, integer numbers and strings in any variable. You can mix them and conversion is done automatically.
<P>
<LI>
PORTABLE Available in C source and can be compiled on UNIXes as well as on Windows NT.
<P>
<LI>
4E LANGUAGE, which means easy to extend, easy to embed. ScriptBasic was developed to provide clean and clear interfaces around it, and inside it. It is easy to embed the language to an application and use it as a macro language just like TCL. It is also easy to implement new built-in function and new commands. 
You can develop dynamically loaded libraries that ScriptBasic may load at run time. The language source is clean, well documented and development guides are on the way.
<P>
<LI>
COMPILED CODE ScriptBasic creates intermediate compiled code, which is interpreted afterwards. Syntax analysis is done at first and only syntactically perfect programs start to run. The compiled code is put into a continuous memory space and compiled code can be saved and loaded again to run without recompilation. This is vital for CGI scripts and is not available for most scripting programming languages. Compiled code is binary, not readable. 
Therefore you can develop and distribute programs and getting some help to protect your intellectual property. You need not give the source code. 
<P>
<LI>
MULTI THREAD aware. Although the current implementation is not multi thread, all the code was designed to be thread safe. You can embed the code into systems that run multiple interpreters in the same process. On the other hand the interpreter can run the same code in multiple threads and was designed to be capable handling call-back functions, and multithread programs in the future. 
<P>
<LI>
DEBUGGER The BASIC programs can be debugged using the external debugger.
<P>
</UL><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="1.1."><H2>1.1. Chapters</H2></A>

This documentation has four main chapters. These are
<P>
<UL>
<P>
<LI> <a href="#2.">Interpreter Architecture</A> describes the overall architecture of the interpreter, lists the different modules, and contains the reference documentation of the C functions implemented in the individual modules.
<P>
<LI> <a href="#3.">Embedding the Interpreter</A> describes how to write an application that embeds The ScriptBasic interpreter. This chapter also contains the reference documentation of the full C API.
<P>
<LI> <a href="#4.">Extension Modules</A> describes what extension modules are, how to use them and how to write extension modules that may provide access to special programs, operating system features, and are not implemented in the interpreter core.
<P>
<LI> <a href="#5.">Preprocessors</A> detail how to write preprocessor extensions to ScriptBasic. These extensions provide development functionalities like debugging, profiling and processing of the source code in addition to the processing of the interpreter.
<P>
<LI> <a href="#6.">Compilation</A> details how to compile ScriptBasic under Windows NT.
</UL>
<P>
I advise you to read the architecture chapter first to get the overall picture. After that you can read one of the three middle chapters based on your plans. If you plan to embed the interpreter, read the second chapter. If you want to write an extension module, read the third chapter. If you intend to write a preprocessor, read the fourth chapter. You may want to do more than one even.
<P>
By now you may not need what the differences are. This will change after reading the architecture chapter.
<P>
The last chapter is to be read just before you start to experiment with ScriptBasic. This will give you guide lines how to compile the program from source. This may not be needed for extension module and preprocessor developers, but it does not do any harm either. It may help.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2."><H1>2. Interpreter Architecture</H1></A>

This chapter tells you the architecture of the interpreter. It is not a must to read this chapter, and you may find that some topic is irrelevant or not needed to learn to embed or to extend ScriptBasic. However understanding the internal working order of ScriptBasic should help you understand why some of the extending or embedding interfaces work the way they actually do. So I recommend that you read on and do not skip this chapter.
<P>
To read this chapter and to understand the internal working of the interpreter is vital when you decide to write an internal preprocessor. Internal preprocessors interact with not only the execution system but also the reader, lexer, syntaxer and builder modules along the way one after the other as they do their unique job processing a BASIC program, thus internal preprocessor writers have to understand how these modules work.
<P>
ScriptBasic is not a real scripting language. This is a mix of a scripting language and compiled languages. The language is scripting in the sense that it is very easy to write small programs, there is no need for long variable and function declarations. On the other hand the language is compiled into an internal code that is executed afterwards. This is the same or similar technique, which is used in the implementations of the language Java, Perl, Python and many other languages.
<P>
ScriptBasic as a language is a BASIC dialect that implements most BASIC features that BASIC implementations usually do. However ScriptBasic variables are not typed, and dynamic storage, like arrays are automatically allocated and released. A ScriptBasic variable can store a string, an integer, a real value or an array. Naturally a variable can not store more than one of any of these types of values. But you need not declare a variable to be INTEGER or REAL, or STRING. A variable may store a string at a time and the next assignment command may release the original value and store a different value in the variable.
<P>
When a program is executed it goes through several steps. The individual steps are implemented in different modules each being coded in a separate C language source file. These modules were developed so that they provide clear interface and thus could be replaced. The lexical analyzer uses the functions provided by the reader, the syntax analyzer uses the functions provided by the lexical analyzer and so on. The modules never dig into each others private area.
<P>
The modules are listed here with some explanation.
<P>
<UL>
<P>
<LI>
EXTERNAL PREPROCESSOR
<P>
This module executes external preprocessors. These preprocessors are standalone executable programs that read the source program and create another file that is read and processed by the ScriptBasic interpreter. If an external preprocessor is used the source file is usually not BASIC but rather some other language, usually a BASIC like language, which is extended some way and the preprocessor creates the pure ScriptBasic conformant BASIC program. The sample preprocessor supplied with ScriptBasic is the HEB (HTML Embedded BASIC) preprocessor that reads HTML embedded BASIC code and creates BASIC program. This HEB source file is a kind of HTML with embedded program fragments, which you may be familiar with in case you program PHP or Microsoft BASIC ASP pages. The HEB preprocessor itself is written in BASIC and is executed by ScriptBasic. Thus when a HEB "language" is executed by ScriptBasic it starts a separate instance of the interpreter and executes the HEB preprocessor on the source file. Of course the HEB preprocessor could be implemented in any language that can be compiled or some way executed on the target machine. Actually the very first version of the HEB preprocessor was written in Perl so when it was first tested the ScriptBasic interpreter started a Perl interpreter before reading the generated BASIC code.
<P>
Note that the HEB preprocessor provided in the ScriptBasic package is an example implementation and lacks many features. It can, for example, be fooled by putting a <font size="3"><tt>%&gt;</tt></font> characters into a BASIC string constant.
<P>
<LI>
READER
<P>
This module reads the source file into the computer memory. Usually source programs are not too big compared to computer memory and thus can be read into the operational memory (RAM). ScriptBasic source code is approximately 1MB and I develop it on a station that has 386MB memory. This means that even a fairly large program can fit into the memory seamlessly. BASIC programs executed by the ScriptBasic interpreter are likely to be much smaller than that.
<P>
The source code is stored in memory pieces that form a linked list. Each element of the list contains one line of the source code and the information of the line for debugging and error reporting purposes. This information includes the file name that the line was read and the line number. Later when the lexer (detailed later) performs lexical analysis it will inherit this information and when there is a lexical or syntactical error the line number is reported correct.
<P>
The reader module also handles the <font size="3"><tt>include</tt></font> and <font size="3"><tt>import</tt></font> directives that are used to include files into the source file. (Note that <font size="3"><tt>import</tt></font> inserts the content of the file only if it was not loaded yet.)
<P>
The module also processes the lines that look 
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
use preprocessor
</PRE></FONT>
<P>
and loads the internal preprocessor named on the line. <a href="#5.">Preprocessors</A>
<P>
When the module is ready the latter modules have the full source file in memory ready to be processed. The module also provides <font size="3"><tt>getc</tt></font> and <font size="3"><tt>ungetc</tt></font> like functions to get the read characters one by one. These are is used by the lexer.
<P>
<LI>
LEXER
<P>
The lexer module uses the line stream (or the character stream if we view it from a different point of view) provided by the reader. It reads the characters and builds up a linked list. Each element of the list contains a token, like BASIC keyword, a real or integer number, symbol, string, multi-line string, or character. The list of tokens is stored in a form of linked list in the order the tokens appear in the input. Each element also contains extra information about the token that identifies the name of the file and the line number inside the file where the token originally was.
<P>
When the lexer is finished the list of lines is not really needed any more and the reader is ready to release the memory occupied by the source lines read into memory.
<P>
The lexer also provides functions that are used by the syntax analyzer to read the tokens in sequence one after the other as needed by the syntax analysis.
<P>
<LI>
SYNTAXER
<P>
The syntaxer reads the list of tokens provided by the lexical analysis module and creates an internal structure that is already very similar to the executable internal code of ScriptBasic. The syntax analyzer finds any programming error that is not syntactically correct and when it is ready the result is a huge, cross-linked memory structure that contains the almost-executable code.
<P>
The syntax analyzer is responsible building up the evaluation trees of the expressions, the execution nodes, variable numbering and so on.
<P>
When the code refers to a variable named for example <font size="3"><tt>variable</tt></font> the syntax analyzer is responsible to allocate a slot for the variable and to convert the name to a serial number that identifies the variable whenever it is used. Beyond the syntax analyzer there are no named variables anymore (except in case of debuggers). There are global variables listed from <font size="3"><tt>1</tt></font> to <font size="3"><tt>n</tt></font> and local variables also listed by numbers. There are also no names for the functions. Each function is identified by a C pointer to the node where the function starts.
<P>
To ease the life of those who want to embed ScriptBasic the symbol table that list the global variables and the functions and subroutines is appended to the byte-code and there are functions in the <font size="3"><tt>scriba_*</tt></font> embedding interface that handles these symbol tables. However ScriptBasic itself does not use variable or functions/subroutine names beyond the syntax analyzer.
<P>
<LI>
BUILDER
<P>
The builder is the module that creates the code, which is used by the execution system. Why do we have a separate builder? Isn't it the role of the syntax analyzer to build the code?
<P>
Yes, and no. The code that was created by the syntax analyzer could be used to execute the BASIC program, but ScriptBasic still inserts an extra transformation before executing the program. The reason for this extra step is to create a byte code that can be stored in a continuous memory area and thus can easily be saved to or loaded from disk.
<P>
When the syntax analyzer creates the nodes it does not know the actual number of nodes of the byte-code, nor the number of different strings, or size of the string table. While the code is created the syntax analyzer allocates memory for each new block it creates one by one. The nodes are linked together using C pointers. This means that the final memory structure is neither continuous in memory nor can be saved or loaded back to disk.
<P>
When the builder starts the number of the nodes just as well as the total string constant size is known. The builder allocates the memory needed for the whole code and fills in the actual code. The node size is a bit smaller than that of the syntax analyzer and they refer to each other using node serial numbers instead of pointers. This is almost as efficient as using pointers and the actual value does not depend on the location of the node in memory and this way the code can be saved to disk and loaded again for execution.
<P>
<LI>
EXECUTOR
<P>
The executor kills the code. Oh no! I am just kidding.
<P>
It actually executes the code. It gets the code that was generated by the module builder and executes the nodes one by one and finally exits.
<P>
</UL>
<P>
The following sections detail these modules and also some other modules that help these modules to perform their actual tasks.
<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.1."><H2>2.1. External Preprocessor</H2></A>

The module that implements the external preprocessor handling is coded in the C source file `<font size="3"><tt>epreproc.c</tt></font>' (Note that there is a file `<font size="3"><tt>ipreproc.c</tt></font>' that handles internal preprocessors.) The sole function in this file is named <font size="3"><tt>epreproc</tt></font>. This is quite a complex function that gets a lot of arguments listing all the preprocessors that have to be executed one after the other on the source file or on the file created by the previous preprocessor in case there are more than one preprocessors to be applied in chains. The function gets a series of preprocessors to be executed in the command line but in case there is no preprocessor defined in the arguments it executes the preprocessors that have to be executed according to the BASIC program file name extension and the configuration file.
<P>
Only the preprocessors that are configured can be executed. Each preprocessor has a symbolic name, which is used to name it in the configuration file or on the command line using the option `<font size="3"><tt>-p</tt></font>'.
<P>
An external preprocessor is a program that reads a text file and produces a text file. ScriptBasic executes the external preprocessor in a separate process and supplies it with the input and the output file name on the command line. For example the `<font size="3"><tt>scriba.conf.lsp</tt></font>' configuration file may contain the following lines
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
preproc (
  extensions (
     heb "heb"
     )
  external (
    heb (
      executable "/usr/bin/scriba /usr/share/scriba/source/heber.bas"
      directory "/var/cache/scriba/hebtemp/"
      )    
    )
  )
</PRE></FONT>
<P>
The key <font size="3"><tt>executable</tt></font> defines the executable image of the preprocessor. In this case this is an executable image and an argument because the HEB (HTML Embedded Basic) preprocessor is written in BASIC. The other arguments, namely the input file name and the output file name are appended after this string separated by space. When the preprocessor is executed the actual command line is
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
/usr/bin/scriba /usr/share/scriba/source/heber.bas myprog.heb /var/cache/scriba/hebtemp/ADBKPLNBDELMMNKGNBBLHAHGBKKJFIMN
</PRE></FONT>
<P>
(The above sample command line may be split into two lines by the printing/displaying system, but this is essentially a single command line with the executable name and the two arguments.)
<P>
The final argument is a file name automatically generated by ScriptBasic using MD5 calculation of the input file name full path (may and presumably should not be correct in this example above as I just typed some random 32 characters). The preprocessor should read the file <font size="3"><tt>myprog.heb</tt></font> and should generate <font size="3"><tt>/var/ca@dots{</tt></font>MN} (forgive me for not typing that long file name again).
<P>
If there are more preprocessor to be executed on the generated result then the next is executed on the generated file as input file and another output file is generated.
<P>
The preprocessor program should gracefully exit the process it runs in and exit with the code <font size="3"><tt>0</tt></font>. Any other process exit code is treated as error and the further processing of the BASIC program is aborted.
<P>
The sample code for the HEB preprocessor can be found in the ScriptBasic source distribution. Note that this preprocessor implementation is a sample and is not meant to be a professional, commercial grade preprocessor.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.1.1."><H3>2.1.1. External preprocessor handling</H3></A>
=abstract
This module starts the external preprocessors.
=end
<P>
=toc<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.1.2."><H3>2.1.2. Execute external preprocessors</H3></A>

This function executes the external preprocessors that are
needed to be executed either by the command line options or
driven by the extensions.
<P>
The command line option preprocessors are executed as listed
in the character array <font size="3"><tt>ppszArgPreprocessor</tt></font>. These preprocessors
are checked to be run first.
<P>
If there is no preprocessors defined on the command line then the
preprocessors defined in the config file for the extensions are
executed. The input file name is also modified by the code.
The input file name is modified so that it will contain the source
code file name after the preprocessing.
<P>
The return value of the function is the error code. This is <font size="3"><tt>PREPROC_ERROR_SUCCESS</tt></font>
if the preprocessing was successful. This value is zero. If the return
value is positive this is one of the error codes defined in the file <font size="3"><tt>errcodes.def</tt></font>
prefixed by <font size="3"><tt>PREPROC_</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int epreproc(ptConfigTree pCONF,
             char *pszInputFileName,
             char **pszOutputFileName,
             char **ppszArgPreprocessor,
             void *(*thismalloc)(unsigned int),
             void (*thisfree)(void *)
  )@{
</PRE></FONT>
<P>
The first argument <font size="3"><tt>pCONF</tt></font> is the configuration data pointer which is passed to the
configuration handling routines.
<P>
The second argument <font size="3"><tt>pszInputFileName</tt></font> is the pointer to the pointer to the input file name.
<P>
The third argument is an output variable. This will point to the output file name upon success
or to NULL. If this variable is NULL then an error has occured or the file needed no preprocessing.
The two cases can be separated based on the return value of the function. If the file needed
preprocessing and the preprocessing was successfully executed then this variable will point
to a ZCHAR string allocated via the function <font size="3"><tt>thismalloc</tt></font>. This is the responsibility of the
caller to deallocate this memory space after use calling the function pointed by <font size="3"><tt>thisfree</tt></font>.
<P>
The fourth argument <font size="3"><tt>ppszArgPreprocessor</tt></font> is an array of preprocessors to be used
on the input file. This array contains pointers that point to ZCHAR strings.
The ZCHAR strings contain the symbolic names of the external preprocessors that
are defined in the configuration file. The configuration file defines
the actual executable for the preprocessor and the temporary directory where the
preprocessed file is stored. The final element of this pointer array should be <font size="3"><tt>NULL</tt></font>.
If the pointer <font size="3"><tt>ppszArgPreprocessor</tt></font> is <font size="3"><tt>NULL</tt></font> or the pointer array pointed by this
contains only the terminating <font size="3"><tt>NULL</tt></font> pointer then the extensions of the file name are
used to determine what preprocessors are to be applied. Preprocessors are applied from
left to right order of the file extensions.
<P>
The arguments <font size="3"><tt>thismalloc</tt></font> and <font size="3"><tt>thisfree</tt></font> should point to <font size="3"><tt>malloc</tt></font> and <font size="3"><tt>free</tt></font> or to
a similar functioning function pair. These functions will be used via the <font size="3"><tt>myalloc.c</tt></font> module
and also to allocate the new <font size="3"><tt>pszOutputFileName</tt></font> string in case of success. This means that the
caller should use the function pointed by <font size="3"><tt>thisfree</tt></font> to release the string pointed by
<font size="3"><tt>pszOutputFileName</tt></font> after the function has returned.
<P>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2."><H2>2.2. Reader</H2></A>

The module reader is implemented in the C source file `<font size="3"><tt>reader.c</tt></font>' This is a very simple module it just reads the lines from the source code files and stores the actual text in memory using linked lists. There is not too much possibility to configure this module except that the memory handling functions and the file opening, closing and reading functions are used via function pointers that can be altered by the caller.
<P>
Like any other module in ScriptBasic the reader module uses a module object. This is like a class definition except that the interpreter is coded in C and thus there is nothing like VTABLE or inheritance. Otherwise the code is object oriented. Here we list the actual definition of the reader object. Note however that this is actually a copy of the actual definition from the file `<font size="3"><tt>reader.c</tt></font>' and it may have been changed since I wrote this manual. So the reader object by the time I wrote this manual was:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
#define BUFFER_INITIAL_SIZE 1024
#define BUFFER_INCREMENT 1024
 typedef struct _ReadObject {
  void * (*fpOpenFile)(char *, void *);
  int (*fpGetCharacter)(void *, void *);
  void (*fpCloseFile)(void *, void *);
  void *pFileHandleClass;
<P>
  void *(*memory_allocating_function)(size_t, void *);
  void (*memory_releasing_function)(void *, void *);
  void *pMemorySegment;
<P>
  ptConfigTree pConfig;
<P>
  char *Buffer;
  long dwBuffer;
  long cBuffer;
<P>
  pSourceLine Result;
  pSourceLine CurrentLine;
  long NextCharacterPosition;
  char fForceFinalNL;
<P>
  pReportFunction report;
  void *reportptr;
  int iErrorCounter;
  unsigned long fErrorFlags;
<P>
  pImportedFileList pImportList;
<P>
  char *FirstUNIXline;
  struct _PreprocObject *pPREP;
  } ReadObject, *pReadObject ;
</PRE></FONT>
<P>
The pointers <font size="3"><tt>fpOpenFile</tt></font>, <font size="3"><tt>fpGetCharacter</tt></font> and <font size="3"><tt>fpCloseFile</tt></font> point to functions that are used to open the input file. The pointer <font size="3"><tt>pFileHandleClass</tt></font> set by the higher code using the module reader is passed to these functions without caring its meaning. This is not used by the standard file input/output functions that are used by the command line version of the program, but can be useful for program environment when the source file is stored in some other forms and not in a file. An example of such use can be seen in the function <font size="3"><tt>scriba_LoadProgramString</tt></font> implemented in the file `<font size="3"><tt>scriba.c</tt></font>'.
<P>
The linked list of source lines is stored in the structure named <font size="3"><tt>SourceLine</tt></font> The definition of this structure is
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
typedef struct _SourceLine {
  char *line;
  long lLineNumber;
  long LineLength;
  char *szFileName;
  struct _SourceLine *next;
  } SourceLine, *pSourceLine;
</PRE></FONT>
<P>
You can see that each source line is pointed by the field <font size="3"><tt>line</tt></font> and the length of the line is also stored. The reason for this extra field is that the line itself may contain zero character although this is rare for a program source file to contain zero character inside.
<P>
Before the file is read the function <font size="3"><tt>reader_InitStructure</tt></font> should be called. This is usual for the ScriptBasic modules. This function initializes the reader object to the usual values that actually ScriptBasic needs.
<P>
The reader provides function <font size="3"><tt>reader_ReadLines</tt></font> that actually reads the lines and also processes all lines that contain an <font size="3"><tt>include</tt></font> or <font size="3"><tt>import</tt></font> directive to include a line.
<P>
The reader has some extra functions that are specific to ScriptBasic or generally saying are specific to program source reading.
<P>
Source programs under UNIX usually start with a line
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
#! /usr/bin/scriba
</PRE></FONT>
<P>
that tells the operating system how to start the code. 
<P>
((((Some very old and totally outdated version of some UNIX systems check the first four characters to look for <font size="3"><tt>#! /</tt></font>. There is a space between the <font size="3"><tt>!</tt></font> and the <font size="3"><tt>/</tt></font>. So if you want to be look a real code geek put this extra space before the executable path. To be honest I have never encountered this issue since 1987 when I met my first UNIX at TU Delft, Hollandia. OK that's for the story, get back to the reader!))) Always close the parentheses you open!)
<P>
The reader recognizes this line if this is the very first line of the program and unlinks it from the list. Instead you can reach this line via the reader object variable <font size="3"><tt>FirstUNIXline</tt></font>. This is specific to program source reading and not general file reading. But the reader module is a program source reader or more specific: a BASIC, even ScriptBasic program source reader, though it was coded to be as general as possible.
<P>
Another specific issue is the new line at the end of the last line. Lines are usually terminated by new-line. This line terminating character is included in the string at the end of each element of the linked list the reader creates. However when the last line is terminated by the pure EOF some syntax analyzers may fail (ScriptBasic syntax analyzer is also an example, but the reader is kind to care about this). For the reason if the variable <font size="3"><tt>fForceFinalNL</tt></font> is set to be TRUE this line gets the extra new-line when read.
<P>

<P>

This module contains the functions that read a source file.
<P>
Script basic has several passes
until it can start to execute the code. The very first pass is to read the source lines from
the files. The routines in this module perform this task and build up a linked list that contains
the ascii values of the lines.
<P>
The input functions are parametrized, and the caller should support. If you have different
system dependent file reading functions, or if you have the input file in some format in memory or
in any other data holding space you can support these routines with character fetch functions.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.1."><H3>2.2.1. reader_IncreaseBuffer()</H3></A>

When the reader encounters a line which is longer than the currently allocated
input buffer it calls this function to increase the size of the input buffer. The
input buffer is linearly increased by <font size="3"><tt>BUFFER_INCREMENT</tt></font> size (defined in the header
section of <font size="3"><tt>reader.c</tt></font>
<P>
When a new buffer is allocated the bytes from the old buffer are copied to the new and
the old buffer is released. It is vital that the buffer is always referenced via the
pRo-&gt;buffer pointer because resizing buffer does change the location of the buffer.
<P>
If the memory allocation fails the function return <font size="3"><tt>READER_ERROR_MEMORY_LOW</tt></font> error.
Otherwise it returns zero.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int reader_IncreaseBuffer(pReadObject pRo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.2."><H3>2.2.2. reader_gets()</H3></A>

This function reads a newline terminated line from the file. The file is
identified by function pRo-&gt;fpGetCharacter and the pointer <font size="3"><tt>fp</tt></font>.
<P>
When the input buffer is too small it automatically increases the buffer. The
terminating new line is included in the buffer. If the last line of the file is
not terminated by newline an extra newline character is added to this last line.
<P>
The addition of this extra newline character can be switched off setting pRo-&gt;fForceFinalNL
to false. Even if this variable is false the normal newline characters which are present
in the file are included in the buffer.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int reader_gets(pReadObject pRo,
                 void *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.3."><H3>2.2.3. reader_ReadLines()</H3></A>

This function calls <a href="#2.2.4.">reader_ReadLines_r()</A> to read the lines of the file
given by the file name <font size="3"><tt>szFileName</tt></font> into pRo-&gt;Result. For further
information see <a href="#2.2.4.">reader_ReadLines_r()</A>.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int reader_ReadLines(pReadObject pRo,
                     char *szFileName
  )@{
</PRE></FONT>
The function returns zero or the error code.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.4."><H3>2.2.4. reader_ReadLines_r()</H3></A>

This function reads the lines of a file and creates a linked list
of the read lines.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int reader_ReadLines_r(pReadObject pRo,
                       char *szFileName,
                       pSourceLine *pLine
  )@{
</PRE></FONT>
The file is identified by its name given in the string variable <font size="3"><tt>szFileName</tt></font>. The
file is opened by the function pointed by pRo-&gt;fpOpenFile This function should return
a void pointer and this void pointer is passed to <a href="#2.2.2.">reader_gets()</A> (<font size="3"><tt>reader_gets</tt></font>) to get a
single character.
<P>
The argument <font size="3"><tt>pLine</tt></font> is a pointer to a <font size="3"><tt>SourceLine</tt></font> pointer. The linked list lines read
will be chained into this pointer. The last read line will be followed by the line pointed by
<font size="3"><tt>*pLine</tt></font> and <font size="3"><tt>*pLine</tt></font> will point to the first line.
<P>
This design makes it easy to use and elegant to perform file inclusions. The caller has to
pass the address of the pointer field <font size="3"><tt>next</tt></font> of the source line after which the file is to
be inserted.
<P>
See also <font size="3"><tt>ReadLines</tt></font> that calls this function.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.5."><H3>2.2.5. reader_ProcessIncludeFiles()</H3></A>

This function is called from <a href="#2.2.3.">reader_ReadLines()</A> after calling <a href="#2.2.4.">reader_ReadLines_r()</A>.
<P>
This function goes through all the lines and checks if there is any line
containing an include directive.
<P>
An include directive is a line starting with a word INCLUDE (case insensitive) and
is followed by the file name. The file name can be enclodes between double quotes.
<P>
Note that the processing of the include directives are done on the characters on the
line, because they are processed before any tokenization of the lexer module. This
can cause some problem only when there is an include like line inside a multiline string.
For example:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
a = """Hey this is a multiline string
include "subfile.txt"
"""
</PRE></FONT>
<P>
This <B>will</B> include the file <font size="3"><tt>subfile.txt</tt></font> and its content will become part of the string.
This becomes more complicated when the file <font size="3"><tt>subfile.txt</tt></font> contains strings.
<P>
The file name may not be enclosed between double quotes. In this case the file is tried to be
found in predefined system directories.
<P>
If the programmer uses the command IMPORT instead of INCLUDE the file will only be included if
it was not included yet into the current program.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void reader_ProcessIncludeFiles(pReadObject pRo,
                                pSourceLine *pLine
  )@{
</PRE></FONT>
<P>
The file read is inserted into the plce where the include statement was.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.6."><H3>2.2.6. reader_LoadPreprocessors()</H3></A>

Preprocessors are not part of ScriptBasic. They can be implemented as external DLLs and
should be configured in the configuration file.
<P>
When a line contains
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
USE preprocessorname
</PRE></FONT>
<P>
this reader module loads the preprocessor DLL or SO (dll under unix) file.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void reader_LoadPreprocessors(pReadObject pRo,
                                 pSourceLine *pLine
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.7."><H3>2.2.7. reader_StartIteration()</H3></A>

The package supports functions that help upper layer modules to iterate
through the lines read. This function should be called to start the iteration
and to set the internal iteration pointer to the first line.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void reader_StartIteration(pReadObject pRo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.8."><H3>2.2.8. reader_NextLine()</H3></A>

This function returns a string which is the next line during iteration.
This function does NOT read anything from any file, only returns a pointer to
a string that was already read.
<P>
This function can be used together with <a href="#2.2.9.">reader_NextCharacter()</A>. When a line was partially
passed to an upper layer that uses <font size="3"><tt>reader_NextCharacter</tt></font> this function
will only return the rest of the line.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
char *reader_NextLine(pReadObject pRo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.9."><H3>2.2.9. reader_NextCharacter()</H3></A>

This function gets the next character from the actual line, or gets the
first character of the next line.
<P>
This function does NOT read anything from any file, only returns a character from a string that
was already read.
<P>
When the last character of the last line was passed it return <font size="3"><tt>EOF</tt></font>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int reader_NextCharacter(void *p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.10."><H3>2.2.10. reader_FileName()</H3></A>

This function returns the file name of the actual line. This is the string that
was used to name the file when it was opened. This can be different for different
lines when the reader is called several times to resolve the "include" statements.
<FONT SIZE="3" COLOR="BLUE"><PRE>
char *reader_FileName(void *p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.11."><H3>2.2.11. reader_LineNumber()</H3></A>

This function returns the line number of the current line durig iteration.
This number identifies the line in the file where it was read from.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long reader_LineNumber(void *p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.12."><H3>2.2.12. reader_InitStructure()</H3></A>

This function should be called to initialize the reader structure. It sets the
file handling routines to the standard <font size="3"><tt>fopen</tt></font>, <font size="3"><tt>fclose</tt></font> and <font size="3"><tt>getc</tt></font> functions,
and also sets the function pointers so that the module uses <font size="3"><tt>malloc</tt></font> and <font size="3"><tt>free</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void reader_InitStructure(pReadObject pRo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.13."><H3>2.2.13. reader_RelateFile()</H3></A>

This function gets a file name, which is either absolute or relative
to the current working directory and another file name which is absolute or
relative to the first one.
<P>
The return value of the function is a file name which is either absolute or
relative to the current woring directory.
<P>
The return value is dynamically allocated and is to be release by the caller.
The allocation function is taken from the class function and the segment is
<font size="3"><tt>pMemorySegment</tt></font>.
<FONT SIZE="3" COLOR="BLUE"><PRE>
char *reader_RelateFile(pReadObject pRo,
                       char *pszBaseFile,
                       char *pszRelativeFile
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.2.14."><H3>2.2.14. reader_DumpLines()</H3></A>

This is a debug function that prints the lines into a debug file.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void reader_DumpLines(pReadObject pRo,
                      FILE *fp
  )@{
</PRE></FONT>
<P>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3."><H2>2.3. Lexer</H2></A>

The module lexer is implemented in the C source file `<font size="3"><tt>lexer.c</tt></font>' This is a module that converts the read characters to a list of tokens. The lexer recognizes the basic lexical elements, like numbers, strings or keywords. It starts to read the characters provided by the reader and group it p into lexical elements. For example whenever the lexical analyzer sees a <font size="3"><tt>"</tt></font> character it starts to process a string until it finds the closing <font size="3"><tt>"</tt></font>. When it does the module creates a new token, links it to the end of the list and goes on.
<P>
To do this the lexical analyzer has to know what is a keyword, string or number.
<P>
Because general purpose, table driven lexical analyzers are usually rather slow ScriptBasic uses a proprietary lexical analyzer that is partially table driven, but not so general purpose as one created using the program LEX.
<P>
There are some rules that are coded into the C code of the lexical analyzer, while other are defined in tables. Even the rules coded into the C program are usually parameterized in the module object.
<P>
Lets see the module object definition from the file `<font size="3"><tt>lexer.c</tt></font>' (Note that the C <font size="3"><tt>.h</tt></font> header files are extracted from the <font size="3"><tt>.c</tt></font> files thus there is no need to double maintain function prototypes.)
<P>
Note however that this is actually a copy of the actual definition from the file `<font size="3"><tt>lexer.c</tt></font>' and it may have been changed since I wrote this manual. So the lexer object by the time I wrote this manual was:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
typedef struct _LexObject {
  int (*pfGetCharacter)(void *);
  char * (*pfFileName)(void *);
  long (*pfLineNumber)(void *);
  void *pvInput;
  void *(*memory_allocating_function)(size_t, void *);
  void (*memory_releasing_function)(void *, void *);
  void *pMemorySegment;
<P>
  char *SSC;
  char *SCC;
<P>
  char *SFC;
  char *SStC;
  char *SKIP;
<P>
  char *ESCS;
  long fFlag;
<P>
  pReportFunction report;
  void *reportptr;
  int iErrorCounter;
  unsigned long fErrorFlags;
<P>
  char *buffer;
  long cbBuffer;
<P>
  pLexNASymbol pNASymbols;
  int cbNASymbolLength;
<P>
  pLexNASymbol pASymbols;
<P>
  pLexNASymbol pCSymbols; 
  pLexeme pLexResult;
  pLexeme pLexCurrentLexeme;
  struct _PreprocObject *pPREP;
  }LexObject, *pLexObject;
</PRE></FONT>
<P>
This <font size="3"><tt>struct</tt></font> contains the global variables of the lexer module. In the first "section" of the structure you can see the variables that may already sound familiar from the module reader. These parameterize the memory allocation and the input source for the module. The input functions are usually set so that the characters come from the module reader, but there is no principal objection to use other character source for the purpose.
<P>
The variable <font size="3"><tt>pvInput</tt></font> is not altered by the module. It is only passed to the input functions. The function pointer name <font size="3"><tt>pfGetCharacter</tt></font> speaks for itself. It is like <font size="3"><tt>getc</tt></font> returns the next character. However when this function pointer is set to point to the function <font size="3"><tt>reader_NextCharacter</tt></font> the input is already preprocessed a bit. Namely the <font size="3"><tt>include</tt></font> and <font size="3"><tt>import</tt></font> directives were processed.
<P>
This imposes some interesting feature that you may recognize now if you read the reader module and this module definition carefully. <font size="3"><tt>include</tt></font> and <font size="3"><tt>import</tt></font> works inside multi-line strings. (OK I did not talk about multi-line strings so far so do not feel ashamed if you did not realize this.)
<P>
The function pointers <font size="3"><tt>pfFileName</tt></font> and <font size="3"><tt>pfLineNumber</tt></font> should point to functions that return the file name and the line number of the last read character. This is something that a <font size="3"><tt>getc</tt></font> will not provide, but the reader functions do. This will allow the lexical analyzer to store the file name and the line number for each token.
<P>
The next group of variables seems to be frightening and unreadable at first, but here is this book to explain them. These variables define what is a string, a symbol, what has to be treated as unimportant space and so on. Usually symbols start with alpha character and are continued with alphanumeric characters in most programming languages. But what is an alpha character? Is <font size="3"><tt>_</tt></font> one or is <font size="3"><tt>$</tt></font> a valid alphanumeric character. Well, for the lexer module if any of these characters appear in the variable <font size="3"><tt>SSC</tt></font> then the answer is yes. The name stands for <I>Symbol Start Characters</I>. But lets go through all these variables one by one.
<P>
<UL>
<P>
<LI> <font size="3"><tt>char *SSC;</tt></font>
<P>
This <I>Symbol Start Character</I> variable contains all the characters that may be used to start a symbol. This symbol can be a variable or a symbol that appears for itself in the code like in the command <font size="3"><tt>SET FILE</tt></font>. (See the users guide.)
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm_:$
</PRE></FONT>
<P>
<LI> <font size="3"><tt>char *SCC;</tt></font>
<P>
This <I>Symbol Continuation Character</I> variable contains all the characters that may be used inside a symbol after the opening first character. The default value for this variable is
<P>

<FONT SIZE="3" COLOR="BLUE"><PRE>
QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm_1234567890:$
</PRE></FONT>
<P>
<LI> <font size="3"><tt>char *SFC;</tt></font>
<P>
This <I>Symbol Finishing Character</I> variable contains all the characters that may be used as the last character inside a symbol. The default value for this variable is
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm_1234567890$
</PRE></FONT>
<P>
which works fine for ScriptBasic. Note that this prohibits ScriptBasic variables to finish with colon.
<P>
<LI> <font size="3"><tt>char *SStC;</tt></font>
<P>
This <I>Start String Character</I> variable contains the characters that may start a string. The ScriptBasic value contains only the <font size="3"><tt>"</tt></font> character thus ScriptBasic strings can only start and end with the <font size="3"><tt>"</tt></font> character. However some other languages may use different string starting and finishing characters.
<P>
If there are more than one characters in this string then a string opened using a character should be closed using the same character. This is hard coded into the C program of the lexer.
<P>
The lexer also recognizes single-line strings and multi-line strings. A single-line string starts with a single <font size="3"><tt>"</tt></font> (or whatever characters are allowed in the <font size="3"><tt>SStC</tt></font> field) and finish with a single <font size="3"><tt>"</tt></font>. There can not be new-line character in a single-line string and any <font size="3"><tt>"</tt></font> character in the string should be quoted using the <font size="3"><tt>\</tt></font> character. The <font size="3"><tt>\</tt></font> character is not hard-coded it is configured in the field <font size="3"><tt>ESCS</tt></font>, as you will see later.
<P>
A multi-line string starts with <font size="3"><tt>"""</tt></font> characters that is three <font size="3"><tt>"</tt></font> characters and finishes the same way. Multi-line string may span several lines. This notation of multi-line string was inherited from the language Python. (At least I did not see it anywhere else.)
<P>
<LI> <font size="3"><tt>char *SKIP;</tt></font>
<P>
This <I>Skip</I> variable contains all characters that are to be skipped. This is the space, tab and the carriage-return character in case of ScriptBasic.
<P>
Skipping these characters does not mean that these characters are not taken into account. They serve a very important role: they stop tokens, thus no space can appear inside the name of a variable for example. However there is no token generated from these characters.
<P>
Note that the carriage-return character included in this string allows ScriptBasic to compile any DOS edited and binary transferred files under UNIX. However the operating system may have problem with the terminating carriage-return on the very first line.
<P>
<LI> <font size="3"><tt>char *ESCS;</tt></font>
<P>
This <I>Escape String</I> variable list all those characters that can be escaped in a string. The line that initializes this variable in <font size="3"><tt>lex_InitStructure</tt></font>:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pLex-&gt;ESCS = "\\n\nt\tr\r\"\"\'\'";
</PRE></FONT>
<P>
The first character of the <font size="3"><tt>ESCS</tt></font> string is the character used to escape other characters. This is the <font size="3"><tt>\</tt></font> character for ScriptBasic. The latter characters list the original character on the odd positions and the replacement characters on the following even position. For example the second character of this string is <font size="3"><tt>n</tt></font> and the replacement character is a new-line character, thus <font size="3"><tt>\n</tt></font> will be new-line in any sinle- or multi-line string in a BASIC program.
<P>
<LI> <font size="3"><tt>long fFlag;</tt></font>
<P>
This variable is a bit field that controls how numbers are treated in strings. The lines that initialize this variable are
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
  pLex-&gt;fFlag = LEX_PROCESS_STRING_NUMBER       |
                LEX_PROCESS_STRING_OCTAL_NUMBER |
                LEX_PROCESS_STRING_HEX_NUMBER   |
                0;
</PRE></FONT>
<P>
The constants defined also in `<font size="3"><tt>lexer.c</tt></font>' tell the lexical analyzer that an escape character in a string followed by numeric characters should be converted to characters of the code. This the string <font size="3"><tt>"a\10a"</tt></font> will contains two <font size="3"><tt>a</tt></font> character separated by a new line. When the first character following the escape character is <font size="3"><tt>0</tt></font> the numbers are treated as octal numbers. If this character is <font size="3"><tt>x</tt></font> (lower case only and not <font size="3"><tt>X</tt></font>) the number is treated as hexadecimal. The escaped number is as long as there are numbers following each other without space. If the number is hexadecimal the letters <font size="3"><tt>a-f</tt></font> and <font size="3"><tt>A-F</tt></font> are also treated as digits.
<P>
</UL>
<P>
The default values for these variables are set in the function <font size="3"><tt>lex_InitStructure</tt></font>. Interestingly these default values are perfectly ok for ScriptBasic.
<P>
The field <font size="3"><tt>pNASymbols</tt></font> points to an array that contains the non-alpha symbols list. Each element of this array contains a string that is the textual representation of the symbol and a code, which is the token code of the symbol. For example the table <font size="3"><tt>NASYMBOLS</tt></font> in file `<font size="3"><tt>syntax.c</tt></font>' is:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
<P>
LexNASymbol NASYMBOLS[] = {
{ "@\\" , CMD_EXTOPQN } ,
{ "@`" , CMD_EXTOPQO } ,
{ "@'" , CMD_EXTOPQP } ,
{ "@" , CMD_EXTOPQQ } ,
<P>
...
<P>
{ "@" , CMD_EXTOPQ } ,
{ "^" , CMD_POWER } ,
{ "*" , CMD_MULT } ,
{ NULL, 0 }
  };
</PRE></FONT>
<P>
When the lexical analyzer finds something that is not a string, number or alphanumeric symbol it tries to read forward and recognize any of the non-alpha tokens listed in this table. It is extremely important that the symbols are ordered in this table so that the longer symbols come first thus a symbol <font size="3"><tt>abc</tt></font> is not presented before <font size="3"><tt>abcd</tt></font>. Otherwise <font size="3"><tt>abcd</tt></font> will never be found!
<P>
The variable <font size="3"><tt>cbNASymbolLength</tt></font> is nothing to care about. This is used internally and is calculated automatically by the lexical analyzer.
<P>
The variable <font size="3"><tt>pASymbols</tt></font> is similar to the variable <font size="3"><tt>pNASymbols</tt></font> pointing to a same kind of table. This variable however should point to an array that contains the alphanumeric symbols. You can find the array <font size="3"><tt>ASYMBOLS</tt></font> in file `<font size="3"><tt>syntax.c</tt></font>' that is pointed by this variable for ScriptBasic.
<P>
The order of the words in this array is not important except that more frequent words being listed earlier result faster compilation.
<P>
The field <font size="3"><tt>pCSymbols</tt></font> points to an array that is used only for debugging purposes. I mean debugging ScriptBasic code itself and not debugging BASIC programs.
<P>
The rest of the variables are used by the functions that iterate through the list of tokens when the syntax analyzer reads the token list or to report errors during lexical analysis. Error reporting is detailed in a separate section.
<P>
The tables that list the lexical elements are not maintained "by hand". The source for ScriptBasic syntax is maintained in the file `<font size="3"><tt>syntax.def</tt></font>' and the program `<font size="3"><tt>syntaxer.pl</tt></font>' creates the C syntax file `<font size="3"><tt>syntax.c</tt></font>' from the syntax definition.
<P>
The program `<font size="3"><tt>syntaxer.pl</tt></font>' is so complex that after two years I wrote it I had hard time to understand it and I rather treat it as a holly code: blessed and untouchable. (Ok: see: that code is quite compound, but if there was any bug found in that I could understand what I did in a few hours. Anyway, the brain created that code once belonged to me.)<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1."><H3>2.3.1. Functions implemented in this module</H3></A>

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.
<P>

<P>

<P>
This module contains the functions and structures that are used by ScriptBasic to perform
lexical analysis of the source code. The module was originally developed for ScriptBasic
but was developed to be general enough to be used in other projects.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.1."><H4>2.3.1.1. lex_SymbolicName()</H4></A>

This function usually is for debug purposes. This searches the
table of the predefined symbols and returns the string which is
the predefined symbols for which the code was passsed.
<FONT SIZE="3" COLOR="BLUE"><PRE>
char *lex_SymbolicName(pLexObject pLex,
                       long OpCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.2."><H4>2.3.1.2. lex_HandleContinuationLines()</H4></A>

This function is called from the main function before syntax analysis is started. 
This function handles the usual basic continuation lines. If the last character on a 
line is a _ character, which is either recognised during lexical analysis as a 
character or as a symbol then this lexical element and the following new-line character
token is removed from the list of tokens.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void lex_HandleContinuationLines(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.3."><H4>2.3.1.3. lex_RemoveSkipSymbols()</H4></A>

This function is called from <a href="#">lex_DoLexicalAnalysis()</A> to remove the lexical elements
from the list of tokens that were denoted by the preprocessors to be deleted.
<P>
Some lexical elements are used to give information to some of the preprocessors. These
tokens should be deleted, because later processing can not deal with them and confuses syntax
analysis.
<P>
In those cases the preprocessor should set the type of the token to be L<font size="3"><tt>LEX_T_SKIP</tt></font> or
<font size="3"><tt>LEX_T_SKIP_SYMBOL</tt></font>. The type <font size="3"><tt>LEX_T_SKIP</tt></font> should be used in case the token is handled due to
<font size="3"><tt>ProcessLexSymbol</tt></font> preprocessor command and <font size="3"><tt>LEX_T_SKIP</tt></font> otherwise.
<P>
When the type is set <font size="3"><tt>LEX_T_SKIP_SYMBOL</tt></font> the lexical analyzer knows to release the string holding
the symbol. If the type is <font size="3"><tt>LEX_T_SKIP</tt></font> only the token record is released.
<P>
If the symbol string is not released due to erroneously setting the type to <font size="3"><tt>LEX_T_SKIP</tt></font> instead
<font size="3"><tt>LEX_T_SKIP_SYMBOL</tt></font> the memory will not be released until the interpreter finishes pre execution
steps. So usually if you do not know how to set the type to skip a token <font size="3"><tt>LEX_T_SKIP</tt></font> is safe.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void lex_RemoveSkipSymbols(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.4."><H4>2.3.1.4. lex_RemoveComments()</H4></A>

This function called from the function <a href="#">lex_DoLexicalAnalysis()</A> function to remove the comments before the 
syntax analysis starts.
<P>
It should be called before calling the continuation line handling because usually REM
lines are not continuable
<FONT SIZE="3" COLOR="BLUE"><PRE>
void lex_RemoveComments(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.5."><H4>2.3.1.5. lex_NextLexeme()</H4></A>

Use this function during iteration to get the next lexeme from the list of lexemes.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void lex_NextLexeme(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.6."><H4>2.3.1.6. lex_SavePosition()</H4></A>

Use this function to save the current position of the iteration. This is neccessary during
syntactical analysis to return to a certain position when syntactical analysis fails and
the program has to go back and try a different command syntax.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void lex_SavePosition(pLexObject pLex,
                      pLexeme *ppPosition
  )@{
</PRE></FONT>
<P>
The second argument is a <font size="3"><tt>pLexeme *</tt></font> type variable that holds the position and should be passed
as argument to the function <a href="#2.3.1.7.">lex_RestorePosition()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.7."><H4>2.3.1.7. lex_RestorePosition()</H4></A>

Use this function to restore the lexeme position that was saved calling the function <a href="#2.3.1.6.">lex_SavePosition()</A>
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void lex_RestorePosition(pLexObject pLex,
                         pLexeme *ppPosition
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.8."><H4>2.3.1.8. lex_StartIteration()</H4></A>

You should call this function when the list of lexemes was built up before starting the iteration
of the syntax analyzer. This function sets the iteration pointer to the first lexeme.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void lex_StartIteration(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.9."><H4>2.3.1.9. lex_EOF()</H4></A>

Call this function to check if the iteration has reached the last lexeme.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int lex_EOF(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.10."><H4>2.3.1.10. lex_Type()</H4></A>

During lexeme iteration this function can be used to retrieve the typeof the current lexeme. The
type of a lexeme can be:
<P>
<UL>
<LI> <font size="3"><tt>LEX_T_DOUBLE</tt></font> a double value. A number which is not integer.
<LI> <font size="3"><tt>LEX_T_LONG</tt></font> an long value. A number which is integer.
<LI> <font size="3"><tt>LEX_T_STRING</tt></font> a string.
<LI> <font size="3"><tt>LEX_T_ASYMBOL</tt></font> an alpha symbol, like a variable. This symbol is not predefined. The value
of the lexeme is the string of the symbol.
<LI> <font size="3"><tt>LEX_T_NSYMBOL</tt></font> a predefined symbol. The actual value of the lexeme is the token value
of the symbol. If you wan to get the actual string of the symbol you have to call the function
<a href="#2.3.1.1.">lex_SymbolicName()</A>.
<LI> <font size="3"><tt>LEX_T_CHARACTER</tt></font> A character that is not a predefined symbol and does not fit into any string.
@end itemize
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int lex_Type(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.11."><H4>2.3.1.11. lex_Double()</H4></A>

When the type of the current lexeme is <font size="3"><tt>LEX_T_DOUBLE</tt></font> during the lexeme iteration
this function should be used to retrieve the actual value of the current lexeme.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
double lex_Double(pLexObject pLex
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.12."><H4>2.3.1.12. lex_String()</H4></A>

When the type of the current lexeme is <font size="3"><tt>LEX_T_STRING</tt></font> during the lexeme iteration
this function should be used to retrieve the actual value of the current lexeme.
<FONT SIZE="3" COLOR="BLUE"><PRE>
char *lex_String(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.13."><H4>2.3.1.13. lex_StrLen()</H4></A>

When the type of the current lexeme is <font size="3"><tt>LEX_T_STRING</tt></font> during the lexeme iteration
this function should be used to retrieve the length of the current lexeme. This is
more accurate than calling <font size="3"><tt>strlen</tt></font> on the actual string because the string itself may
contain zero characters.
<FONT SIZE="3" COLOR="BLUE"><PRE>
long lex_StrLen(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.14."><H4>2.3.1.14. lex_Long()</H4></A>

When the type of the current lexeme is <font size="3"><tt>LEX_T_LONG</tt></font> during the lexeme iteration
this function should be used to retrieve the actual value of the current lexeme.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long lex_Long(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.15."><H4>2.3.1.15. lex_LineNumber()</H4></A>

This function returns the line number that the actual lexeme is in the source file.
This function is needed to print out syntax and lexical error messages.
<P>
See also <a href="#2.3.1.16.">lex_FileName()</A>.
<FONT SIZE="3" COLOR="BLUE"><PRE>
long lex_LineNumber(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.16."><H4>2.3.1.16. lex_FileName()</H4></A>

This function returns a pointer to a constant string which is the file name
that the lexeme was read from. Use this function to print out error messages when
syntax or lexical error occures.
<P>
See also <a href="#2.3.1.15.">lex_LineNumber()</A>.
<FONT SIZE="3" COLOR="BLUE"><PRE>
char *lex_FileName(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.17."><H4>2.3.1.17. lex_XXX()</H4></A>

These access functions are implemented as macros and are put into &lt;lexer.h&gt; by the program <font size="3"><tt>headerer.pl</tt></font>
<P>
The macros access <font size="3"><tt>Int</tt></font>, <font size="3"><tt>Symbol</tt></font>, <font size="3"><tt>Float</tt></font> etc values of the current lexeme. However these are strored
in a location which is named a bit different. For example the string of a symbol is stored in the string
field of the lexeme. To be readable and to be compatible with future versions use these macros to access
lexeme values when lexeme has any of these types.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
/*
TO_HEADER:
#define lex_Int(x) lex_Long(x)
#define lex_Symbol(x) lex_String(x)
#define lex_Float(x) lex_Double(x)
#define lex_Char(x) lex_Long(x)
#define lex_Token(x) lex_Long(x)
#define lex_Code(x) lex_Long(x)
*/
/*
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.18."><H4>2.3.1.18. lex_Finish()</H4></A>

Call this functionto release all memory allocated by the lexical analyzer.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void lex_Finish(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.19."><H4>2.3.1.19. lex_DumpLexemes()</H4></A>

Us this function for debugging. This function dumps the list of lexemes to the file <font size="3"><tt>psDump</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void lex_DumpLexemes(pLexObject pLex,
                     FILE *psDump
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.20."><H4>2.3.1.20. lex_ReadInput()</H4></A>

Call this function after proper initialization to read the input file. This function performs the laxical analysis and
builds up an internal linked list that contains the lexemes.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int lex_ReadInput(pLexObject pLex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.3.1.21."><H4>2.3.1.21. lex_InitStructure()</H4></A>

You may but need not call this function to initialize a <font size="3"><tt>LexObject</tt></font>. You may
also call this function to use the settings of the function and set some
variables to different values after the function returns.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void lex_InitStructure(pLexObject pLex
  )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4."><H2>2.4. Syntax Analyzer</H2></A>

The syntax analyzer is a module that reads the token stream delivered by the lexer module and builds a memory data structure containing the syntactically analyzed and built program. The syntax analyzer is contained in the source file `<font size="3"><tt>expression.c</tt></font>' The name of this module come from the fact that the most important and most complex task of syntax analysis is the analysis of the expressions.
<P>
For the syntax analyzer the program is a series of commands. A command is a series of symbols. There is nothing like command blocks, or one command embedding another command. Therefore the syntax definition is quite simple and yet still powerful enough to define a BASIC like language.
<P>
Because syntax analysis is quite a complex task and the syntax analyzer built for ScriptBasic is quite a complex one I recommend that you first read the tutorial from the ScriptBasic web site that talks about the syntax analysis. This is a series of slides together with real audio voice explaining the structure of the syntax analyzer of ScriptBasic.
<P>
The syntax analyzer should be configured using a structure containing the configuration parameters and the global variables for the syntactical analyzer. This structure contains the pointer to the array containing the syntax definition. Each element of the array defines command syntax. Command syntax is the list of the symbols that construct the command. When the syntactical analyzer tries to analyze a line it tries the array elements until it finds one matching the line. When checking a line against a syntax definition the syntactical analyzer takes the lexical elements on the line and checks that they match the next symbol in the syntax definition. A symbol can be as simple as a reserved word, like <font size="3"><tt>if</tt></font> <font size="3"><tt>else</tt></font>, <font size="3"><tt>endif</tt></font>. Such a syntax element is matched by the specific keyword. On the other hand a symbol on the syntax definition can be as complex as an expression, which is matched by a whole expression.
<P>
The syntax analyzer has some built in assumption about the language, but the actual syntax is defined in tables. This way it is possible to analyze different languages using different tables in the same program even in the same process in separate threads.
<P>
When the syntax analyzer reads the syntax definition of a line and matches the tokens from the lexer against the syntax element it may do several things:
<P>
<UL>
<LI> recognizes that the syntax element matches the coming token and goes on
<LI> recognizes that the syntax element matches the coming token(s) and creates one or more new nodes in memory that hold the values associated with the tokens
<LI> recognizes the syntax element, does not match it against any token, and does some side effect
</UL>
<P>
The first is the case when the syntax element is a constant symbol. For example it is a command keyword. In this case there is nothing to do with the keyword except that the syntax analyzer has to recognize that this is the statement identified by the keyword. The actual code will be generated later when non-constant syntactical elements are found.
<P>
When the syntax analyzer sees that the next syntax element is some variable, non-constant syntax element it matches the coming tokens and creates the nodes that hold the actual value for the tokens. For example when the syntax element is <font size="3"><tt>string</tt></font> the syntax analyzer checks that the coming token is a string and creates a node that holds the string. The most important example is the syntax element <font size="3"><tt>expression</tt></font>. In this case the syntax analyzer checks that the coming tokens form an expression and not only "consumes" these tokens, but creates several nodes that hold the structure of the expression.
<P>
We can distinguish between constant and variable symbolic definition elements.
<P>
<UL>
<LI>
A constant symbolic element is matched by a constant symbol. A constant symbolic element is a reserved keyword, or a special character that should appear at a certain position on the line.
<LI>
A variable symbolic element on the other hand is matched by several different actual values. The simplest example of a variable symbolic element is a number. A number in the syntax definition tells the analyzer that a number should appear at the position on the line. However it does not specify the value of the number. Any number can appear and is valid at the position. When a variable symbolic element is matched the actual value, which was presented on the line and matched the symbolic definition element is stored in the memory structure that the analyzer builds.
</UL>
<P>
There are some special symbols that are always matched whenever they are checked by the syntax analyzer. They do not consume any lexical element from the line, and generate values in the memory structure that the analyzer builds.
<P>
The symbolic definition elements are:
<P>
<UL>
<LI>
<P>
<font size="3"><tt>expression</tt></font> This element matches an expression. When this syntax definition element should be matched the syntactical analyzer tries to work up an expression starting from the actual position in the lexical unit stream.
<LI>
<font size="3"><tt>expression_list</tt></font> This element matches a list of expressions separated by comma characters.
<LI>
<font size="3"><tt>string</tt></font> This element is matched by a single string. Whenever you think to use this syntax definition element consider using expression instead. This element matches only a single string and not an expression resulting string value.
<LI>
<font size="3"><tt>integer</tt></font> This element is matched by an integer number. Whenever you think to use this syntax definition element consider using expression instead. This element matches only a single string and not an expression resulting integer value.
<LI>
<font size="3"><tt>float</tt></font> This element is matched by an integer or float number. Whenever you think to use this syntax definition element consider using expression instead. This element matches only a single string and not an expression resulting integer or float value. Implementing a command that requires this symbolic element should accept integer values at the same location because this value matches any float or integer value. Any integer value passed on a float syntax location is converted to float during compile time. (Note that the C code does not use the C type float. All float numbers are stored and handled using the C type double.)
<LI>
<font size="3"><tt>symbol</tt></font> This element accepts a symbol. Before using this syntax definition element you should be familiar with the other elements that may accept a symbol for a certain role. You should use this element when wanting to deal with the actual name of the symbol during run time. Note however that there are other elements that you should consider before using this syntax definition element.
<LI>
<font size="3"><tt>absolute_symbol</tt></font> This element accepts a symbol similar to the syntax definition element symbol. The difference is that symbol accepts a relative symbol which is treated as belonging to the current name space unless explicit name space was defined. Absolute symbol is taken without any modification.
<LI>
<font size="3"><tt>name_space</tt></font> This syntax definition element is matched by an absolute symbol and sets the current name space.
<LI>
<P>

<font size="3"><tt>end_name_space</tt></font> this syntax definition element does not consume any lexical elements, but closes a name space and the surrounding name space is used afterwards.
<LI>
<font size="3"><tt>lval</tt></font> This element can be matched by a left value. That is some variable reference to which value can be assigned.
<LI>
<font size="3"><tt>lval_list</tt></font> This element can be matched by a list of left values. A list is several left values separated by commas.
<LI>
<font size="3"><tt>local_start</tt></font> This syntax definition element is always matched, and does not consume any lexical element from the list. When this syntax definition element is reached by the syntax analyzer it starts a new local scope. Such a point is usually the start of a function or procedure.
<LI>
<font size="3"><tt>local_end</tt></font> This syntax definition element is the pair of local start. This syntax definition element is always matched, and does not consume any lexical element from the list. When this syntax definition element is reached by the syntax analyzer it finishes the local scope. Such a point is usually the end of a function or procedure. Note that local scopes can not be nested.
<LI>
<font size="3"><tt>local</tt></font> This syntax definition element is matched by a symbol, which is treated as a local variable. The symbol is modified according to name space. The syntax definition element is not matched whenever it is tried to be used outside of local scope.
<LI>
<font size="3"><tt>local_list</tt></font> This symbol definition element is matched by a comma separated list of local.
<LI>
<font size="3"><tt>function</tt></font> This symbol definition element is matched by a symbol, which is treated as a function name. Note that the local scope does not automatically start when such a syntax definition element is matched.
<LI>
<font size="3"><tt>thisfn</tt></font> This symbol definition element is matched within a local scope by the name of the actual function or procedure. This is usually used to describe the assignment that assigns a return value to the function name.
<LI>
<font size="3"><tt>label</tt></font> This symbol definition matches a label, which is usually used after goto like instructions.
<LI>
<font size="3"><tt>label_def</tt></font> This symbol definition is matched by a symbol. This symbol is going to be treated as a label. All labels are global.
<LI>
<font size="3"><tt>go_back</tt></font>
<LI>
<font size="3"><tt>go_forward</tt></font>
<LI>
<font size="3"><tt>come_back</tt></font>
<LI>
<font size="3"><tt>come_forward</tt></font> These symbol definition elements should be used to define block and looping structures. Whenever an instruction like for/next or if/then/else is used it has to define where to continue execution based on the condition. The symbol definition elements go-forward and come-back place the current instruction location on a compile time stack. The symbol definition elements go-back and come-forward take the last element from the same stack. They also check that the location was placed on the stack by a matching construct, assuring that no out of order nesting structures appear, like <font size="3"><tt>if/for/endif/next</tt></font>.
</UL>
Note that you can find other syntax definition elements in the file syntax.def. However these are converted to a character value by the Perl script tool syntaxer.pl These pseudo syntax definition elements are:
<UL>
<LI>
<font size="3"><tt>nl</tt></font> end of line ('\n' character)
<LI>
<font size="3"><tt>tab</tt></font> tab character ('\t' character)
</UL><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.1."><H3>2.4.1. Name Space</H3></A>
The scriba syntax analyzer implements a simple name space handling. A variable, label or function name always belongs to a name space. The default name space is <font size="3"><tt>main</tt></font>. When the syntax analyzer processes a non-absolute symbol it converts the name to contain the name space. A variable named <font size="3"><tt>var</tt></font> in the name space <font size="3"><tt>main</tt></font> has the name <font size="3"><tt>main::var</tt></font>. The syntax analyzer automatically converts the name to contain the name space, therefore <font size="3"><tt>main::var</tt></font> and <font size="3"><tt>var</tt></font> are equivalent when used in the name space <font size="3"><tt>main</tt></font>.
<P>
When a variable contains double colon it is treated as an absolute name, and no name space is prepended to it. If you are in the name space module and use the variable name <font size="3"><tt>main::var</tt></font> it will NOT be converted to <font size="3"><tt>module::main::var</tt></font>. The reason is that it already contains the characters <font size="3"><tt>::</tt></font> and therefore scriba assumes that it already contains the name space.
<P>
If you are in the name space module and want to refer to the variable <font size="3"><tt>module::main::var</tt></font> you can use the names <font size="3"><tt>module::main::var</tt></font> or <font size="3"><tt>::main::var</tt></font>. The first format contains all nested name spaces to the variable. The second version tells the syntax analyzer that the variable is relative, altough it contains double colon. This is because it starts with double colons.
<P>
If you are in name space <font size="3"><tt>module::submodul</tt></font> and want to refer to the variable <font size="3"><tt>module::var</tt></font> you can either write <font size="3"><tt>module::var</tt></font> or<font size="3"><tt> _::var</tt></font>. The first format contains all nested name spaces to the variable. The second version tells the syntax analyzer that the variable is relative and the base module is the embedding module of the current one.
<P>
If you are familiar with the UNIX or DOS/Windows directory notation you can find similarities of file names and name space in scriba. In file names double dot means the parent directory. In scriba underscore character means the parent name space. You can use the <font size="3"><tt>_</tt></font> character not only in front of a name, but also within <font size="3"><tt>::</tt></font> characters. For example
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
Main::module::var
Main::module::submodule::_::var
Main::_::Main::module::var
</PRE></FONT>
<P>
are equivalent.
<P>
Name spaces help to separate variables and to develop scripts cooperatively, but does not prohibit one name space to access variables or symbols of other name spaces.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.2."><H3>2.4.2. Expression</H3></A>

The formal description of an expression syntax is:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
 tag ::= UNOP tag
         NUMBER
         STRING
         '(' expression ')'
         VARIABLE { '[' expression_list ']' }
         FUNC '(' expression_list ')'
         .
<P>
 expression_list ::= expression [ ',' expression_list ] .
 expression_i(1) ::= tag .
 expression_i(i) := expression_i(i-1) [ OP(i) expression_i(i) ] .
 expression ::= expression_i(MAX_PREC) .
</PRE></FONT>
<P>
where 
<UL>
<LI> <font size="3"><tt>OP(i) </tt></font>  is a binary operator having precdence I
<LI> <font size="3"><tt>UNOP</tt></font> is an unary operator
<LI> <font size="3"><tt>NUMBER</tt></font> is a number (float or integer)
<LI> <font size="3"><tt>STRING</tt></font> is a string
<LI> <font size="3"><tt>VARIABLE</tt></font> is a symbol that is to a local or global variable
<LI> <font size="3"><tt>FUNC</tt></font> is a function name, which is either a built-in function or a user defined function
<LI> <font size="3"><tt>MAX_PREC</tt></font> is the maximal precedence
</UL>
<P>
The syntax analyzer is written to match an expression whenever an expression syntax definition element is to be matched according to these rules. The list of built-in function, unary operators and binary operators are defined in the module "global" variables, <font size="3"><tt>BuiltInFunctions</tt></font>, <font size="3"><tt>Unaries</tt></font>, and <font size="3"><tt>Binaries</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3."><H3>2.4.3. Functions implemented in this module</H3></A>

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.
<P>

<P>

<P>

The functions in this file compile a ScriptBasic expression into
internal form. The functions are quite general, and do NOT depend
on the actual operators that are implemented in the actual version.
<P>
This means that you can define extra operators as well as extra
built-in functions easily adding entries into tables and need not modify
the compiling code.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.1."><H4>2.4.3.1. What is an expression in ScriptBasic</H4></A>

Altough the syntax defintion in script basic is table driven and can easily be modified
expressions are not. The syntax of an expression is somewhat fix. Here we formally define
what the program thinks to be an expression. This restriction should not cause problem
in the usage of this module because this is the usual syntax of an expression. Any altering
to this would result in an expression syntax which is unusual, and therefore difficult to
use for the common users. The operators and functions along with therir precedence values are
defined in tables anyway, so you have flexibility.
<P>
The formal description of an expression syntax:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
 tag ::= UNOP tag
         NUMBER
         STRING
         '(' expression ')'
         VARIABLE @{ '[' expression_list ']' }
         VARIABLE '@{' expression_list '}'
         FUNC '(' expression_list ')'
         .
<P>
 expression_list ::= expression [ ',' expression_list ] .
<P>
 expression_i(1) ::= tag .
<P>
 expression_i(i) := expression_i(i-1) [ OP(i) expression_i(i) ] .
<P>
 expression ::= expression_i(MAX_PREC) .
<P>
 left_value ::= variable @{ '[' expression_list ']' } 
                variable '@{' expression_list '}' .
<P>
</PRE></FONT>
<P>
<UL>
<LI> UNOP
<P>
is unary operator as defined in tables in file operators.h
<P>
<LI> NUMBER 
<P>
is a number, lexical element.
<P>
<LI> STRING 
<P>
is a string, lexical element.
<P>
<LI> VARIABLE 
<P>
is a lexical element.
<P>
<LI> FUNC 
<P>
is a function either built in, or user defined
<P>
<LI> OP(i)
<P>
is an operator of precendece i as defined in tables.
<P>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.2."><H4>2.4.3.2. ex_DumpVariables()</H4></A>

This function dumps the variables stored in the symbol table to the file pointed by
<font size="3"><tt>fp</tt></font>
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void ex_DumpVariables(SymbolTable q,
                      FILE *fp
  )@{
</PRE></FONT>
<P>
Note that this function is a debug function.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.3."><H4>2.4.3.3. expression_PushNameSpace()</H4></A>

When a <font size="3"><tt>module name</tt></font> instruction is encountered the name space is modified. However
the old name space should be reset when an <font size="3"><tt>end module</tt></font> statement is reached. As the
modules can be nested into each other the name spaces are stored in a name space stack
during syntax analysis.
<P>
This function pushes the current name space onto the stack. After calling
this function the caller can put the new string into the <font size="3"><tt>pEx-</tt></font>&gt;<font size="3"><tt>CurrentNameSpace</tt></font>
variable and later calling <a href="#">ex_PopNameSpace()</A> can be called to retrive the saved name space.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int expression_PushNameSpace(peXobject pEx
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.4."><H4>2.4.3.4. ex_CheckUndefinedLabels()</H4></A>

This function traverses the label symbol table and reports all undefined
labels as error. Undefined labels reference the node with node-number zero. Jumping
on a label like that caused the program to stop instead of compile time error
in previous versions.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void ex_CheckUndefinedLabels(peXobject pEx
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.5."><H4>2.4.3.5. ex_CleanNameSpaceStack()</H4></A>

This function cleans the name space stack. This cleaning does not need to be done during
syntax analysis. It is needed after the analysis has been done to detect unclosed modules.
<P>
Note that the <font size="3"><tt>main::</tt></font> module is implicit and can not and should not be closed
unless it was explicitly opened.
<P>
The function calls the report function if the name space is not empty when the function is called.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void ex_CleanNameSpaceStack(peXobject pEx
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.6."><H4>2.4.3.6. expression_PopNameSpace()</H4></A>

When a <font size="3"><tt>module name</tt></font> instruction is encountered the name space is modified. However
the old name space should be reset when an <font size="3"><tt>end module</tt></font> statement is reached. As the
modules can be nested into each other the name spaces are stored in a name space stack
during syntax analysis.
<P>
This function pops the name space from the name space stack and copies the value to the
<font size="3"><tt>pEx-</tt></font>&gt;<font size="3"><tt>CurrentNameSpace</tt></font> variable. This should be executed when a name space is closed
and we want to return to the embedding name space.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int expression_PopNameSpace(peXobject pEx
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.7."><H4>2.4.3.7. ex_PushWaitingLabel()</H4></A>

This function is used to define a label.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int ex_PushWaitingLabel(peXobject pEx,
                         pSymbolLABEL pLbl
  )@{
</PRE></FONT>
<P>
When a label is defined the <font size="3"><tt>eNode_l</tt></font> that the label is going to belong still does not exists, and
therefore the <font size="3"><tt>NodeId</tt></font> of that <font size="3"><tt>eNode_l</tt></font> is not known. This function together with <a href="#2.4.3.8.">ex_PopWaitingLabel()</A>
maintains a stack that can store labels which are currently defined and still need a line to be assigned
to them. These labels all point to the same line. Altough it is very rare that many labels point to
the same line, it is possible. The number of labels that can point the same line is defined by the
constant <font size="3"><tt>MAX_SAME_LABELS</tt></font> defined in <font size="3"><tt>expression.c</tt></font>
<P>
To make it clear see the following BASIC code:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
<P>
this_is_a_label:
REM this is a comment
            PRINT "hello word!!"
<P>
</PRE></FONT>
<P>
The label is defined on the first line of the example. However the label belongs to the
third line containing the statement <font size="3"><tt>PRINT</tt></font>. When the label is processed the compiler does
not know the node number of the code segment which is generated from the third line. Therefore
this function maintains a label-stack to store all labels that need a line. Whenever a line is
compiled so that a label can be assigned to that very line the stack is emptied and all labels waiting on the
stack are assigned to the line just built up. (Or the line is assigned to the labels if you
like the sentence the other way around.)
<P>
Note that not only labels given by a label defining statement are pushed on this stack, but also
labels generated by commands like 'while/wend' of 'if/else/endif'.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.8."><H4>2.4.3.8. ex_PopWaitingLabel()</H4></A>

This function is used to get a label out of the waiting-label-stack.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pSymbolLABEL ex_PopWaitingLabel(peXobject pEx
  )@{
</PRE></FONT>
<P>
To get some description of waiting labels see the description of the function <a href="#2.4.3.7.">ex_PushWaitingLabel()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.9."><H4>2.4.3.9. _ex_PushLabel()</H4></A>

This function is used to push an unnamed label on the compile time stack.
For more detailed defintion of the unnamed labels and this stack see the
documentation of the function <a href="#">ex_PopLabel()</A>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int _ex_PushLabel(peXobject pEx,
                  pSymbolLABEL pLbl,
                  long Type,
                  void *pMemorySegment
  )@{
</PRE></FONT>
<P>
The argument <font size="3"><tt>Type</tt></font> is used to define the type of the unnamed label. This is usually defined
in the table created by the program <font size="3"><tt>syntaxer.pl</tt></font>
<P>
=bold
Do NOT get confused! This stack is NOT the same as the waiting label stack. That is usually for named
labels.
=nobold
<P>
However the non-named labels are also pushed on that stack before they get value.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.10."><H4>2.4.3.10. _ex_PopLabel()</H4></A>

This function is used to pop an unnamed label off the compile stack.
<P>
When a construct, like <font size="3"><tt>IF/ELSE/ENDIF</tt></font> or <font size="3"><tt>REPEAT/UNTIL</tt></font> or <font size="3"><tt>WHILE/WEND</tt></font> is created
it is defined using compile time label stack.
<P>
For example analyzing the instruction <font size="3"><tt>WHILE</tt></font> pushes a "go forward" value on the compile time
label stack. When the instruction <font size="3"><tt>WEND</tt></font> is analyzed it pops off the value and stores
<font size="3"><tt>NodeId</tt></font> for the label. The label itself is not present in the global label symbol table,
because it is an unnamed label and is referenced during compile time by the pointer to the
label structure.
<P>
The value of the <font size="3"><tt>AcceptedType</tt></font> ensures that a <font size="3"><tt>WEND</tt></font> for example do not matches an <font size="3"><tt>IF</tt></font>.
<P>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pSymbolLABEL _ex_PopLabel(peXobject pEx,
                          long *pAcceptedType
  )@{
</PRE></FONT>
<P>
The array <font size="3"><tt>pAcceptedType</tt></font> is an array of long values that have <font size="3"><tt>MAX_GO_CONSTANTS</tt></font> values.
This is usually points to a static table element which is generated by the program <font size="3"><tt>syntaxer.pl</tt></font>.
<P>
=bold
Do NOT get confused! This stack is NOT the same as the waiting label stack. That is for named
labels.
=nobold<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.11."><H4>2.4.3.11. _ex_CleanLabelStack()</H4></A>

This function is used to clean the unnamed label stack whenever
a locality is left. This helps to detect when an instruction like
<font size="3"><tt>FOR</tt></font> or <font size="3"><tt>WHILE</tt></font> is not closed within a function.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void _ex_CleanLabelStack(peXobject pEx
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.12."><H4>2.4.3.12. Some NOTE on SymbolXXX functions</H4></A>

The functions named <font size="3"><tt>SymbolXXX</tt></font> like <font size="3"><tt>SymbolLABEL</tt></font>, or <font size="3"><tt>SymbolUF</tt></font> do NOT store 
the names of the symbols. They are named <font size="3"><tt>SymbolXXX</tt></font> because they are natural
extensions of the symbol table system. In other compilers the functionality to
retrieve the arguments of a symbol is part of the symbol table handling routines.
<P>
In script basic the symbol table handling routines were developed to be general purpose.
Therefore all the arguments the symbol table functions bind toa symbol is a <font size="3"><tt>void *</tt></font>
pointer. This pointer points to a struct that holds the arguments of the symbols,
and the functions <font size="3"><tt>SymbolXXX</tt></font> allocate the storage for the arguments.
<P>
This way it is possible to allocate arguments for non-existing symbols, as it is done
for labels. Script basic uses non-named labels to arrange the "jump" instructions for
<font size="3"><tt>IF/ELSE/ENDIF</tt></font> constructs. (And for some other constructs as well.) The label and
jump constructs look like:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
<P>
       IF expression Then
<P>
       ELSE
label1:
<P>

       END IF
label2:
<P>
</PRE></FONT>
<P>
The labels <font size="3"><tt>label1</tt></font> and <font size="3"><tt>label2</tt></font> do not have names in the system, not even autogenerated names.
They are referenced via pointers and their value (the <font size="3"><tt>NodeId</tt></font> of the instruction) get into the
<font size="3"><tt>SymbolLABEL</tt></font> structure and later int o the <font size="3"><tt>cNODE</tt></font> during build.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.13."><H4>2.4.3.13. _new_SymbolLABEL()</H4></A>

This function should be used to create a new label. The label can be named or unnamed. Note that
this structure does NOT contain the name of the label.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pSymbolLABEL _new_SymbolLABEL(peXobject pEx
  )@{
</PRE></FONT>
<P>
Also note that all labels are global in a basic program and are subject to name space decoration.
However the same named label can not be used in two different functions in the same name space.
<P>
A label has a serial value, which is not actually used and a number of the node that it points to.
<P>
See the comments on <a href="#">ex_symbols()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.14."><H4>2.4.3.14. _new_SymbolVAR()</H4></A>

This function should be used to create a new variable during compile time. A
variable is nothing else than a serial number. This serial number starts
from 1.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pSymbolVAR _new_SymbolVAR(peXobject pEx,
                          int iLocal
  )@{
</PRE></FONT>
<P>
The second argument should be true for local variables. The counting of local
variables are reset whenever the program enters a new locality. Localities can
not be nested.
<P>
Also note that local variables are allocated in a different segment because they
are deallocated whenever the syntax analyzer leaves a locality.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.15."><H4>2.4.3.15. _new_SymbolUF()</H4></A>

This function should be used to create a new user defined function symbol.
<FONT SIZE="3" COLOR="BLUE"><PRE>
pSymbolUF _new_SymbolUF(peXobject pEx
  )@{
</PRE></FONT>
<P>
A user function is defined by its serial number (serial number is actually not used in the
current sytsem) and by the node number where the function actually starts.
<P>
The number of arguments and the number of local variables are defined in the generated
command and not in the symbol table. This way these numbers are available as they should be
during run time.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.16."><H4>2.4.3.16. _new_eNODE()</H4></A>

This function should be used to create a new <font size="3"><tt>eNODE</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE _new_eNODE(peXobject pEx
  )@{
</PRE></FONT>
<P>
Each <font size="3"><tt>eNODE</tt></font> and <font size="3"><tt>eNODE_l</tt></font> structure has a serial number. The <font size="3"><tt>eNODE</tt></font>s
are referencing each other using pointers. However after build these pointers
become integer numbers that refer to the ordinal number of the node. Nodes are
stored in a single memory block after they are packed during build.
<P>
An <font size="3"><tt>eNODE</tt></font> is a structure that stores a unit of compiled code. For example
an addition in an expression is stored in an <font size="3"><tt>eNODE</tt></font> containing the code for the
addition operator and containing pointers to the operands.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.17."><H4>2.4.3.17. _new_eNODE_l()</H4></A>

This function should be used to create a new <font size="3"><tt>eNODE</tt></font> list. This is nothing else
than a simple structure having two pointers. One pointer points to an <font size="3"><tt>eNODE</tt></font>
while the other points to the next <font size="3"><tt>eNODE_l</tt></font> struct or to NULL if the current
<font size="3"><tt>eNODE_l</tt></font> is the last of a list.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE_l _new_eNODE_l(peXobject pEx,
                      char *pszFileName,
                      long lLineNumber
  )@{
</PRE></FONT>
<P>
Note that <font size="3"><tt>eNODE</tt></font> and <font size="3"><tt>eNODE_l</tt></font> are converted to the same type of 
structure during build after the syntactical analysis is done.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.18."><H4>2.4.3.18. ex_free()</H4></A>

This function releases all memory that was allocated during syntax analysis.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void ex_free(peXobject pEx
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.19."><H4>2.4.3.19. ex_init()</H4></A>

This function should be called before starting syntactical analysis. This
function 
<UL>
<LI> positions the lexeme pointer to the first lexeme,
<LI> initializes the memory segments needed for structured memory allocation, 
<LI> created the symbol tables
<LI> initializes 'class' variables
<LI> initializes the name space to be <font size="3"><tt>main::</tt></font>
@end itemize
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int ex_init(peXobject pEx
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.20."><H4>2.4.3.20. ex_CleanNamePath()</H4></A>

This function created a normalized name space name from a non normalized. This is a simple
string operation.
<P>
Think of name space as directories and variables as files. A simple variable name is in the
current name space. If there is a 'path' before the variable or function name the path has to be
used. This path can either be relative or absolute.
<P>
File system:
<P>
<font size="3"><tt> ../ </tt></font> is used to denote the parent directory in file systems.
<P>
Name space:
<P>
<font size="3"><tt> _::</tt></font> is used to denote the parent name space.
<P>
File system:
<P>
<font size="3"><tt> mydir/../yourdir</tt></font> is the same as <font size="3"><tt>yourdir</tt></font>
<P>
Name space:
<P>
<font size="3"><tt> myns::_::yourns</tt></font> is the same as <font size="3"><tt>yourns</tt></font>
<P>
This function removes the unneccesary downs and ups from the name space and creates the
result in the same buffer as the original. This can always be done as the result is always 
shorter. (Well, not longer.)
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void ex_CleanNamePath(char *s
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.21."><H4>2.4.3.21. ex_ConvertName()</H4></A>

Use this function to convert a relative name to absolute containing name space.
<P>
This function checks if the variable or function name is relative or absolute. If the
name is relative it creates the absolute name using the current name space as a base.
<P>
The result is always put into the <font size="3"><tt>Buffer</tt></font>.
<P>
A name is relative if it does NOT contain <font size="3"><tt>::</tt></font> at all (implicit relative),
if it starts with <font size="3"><tt>::</tt></font> or is it starts with <font size="3"><tt>_::</tt></font> (explicit relative).
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int ex_ConvertName(char *s,          /* name to convert            */
                   char *Buffer,     /* buffer to store the result */
                   size_t cbBuffer,  /* size of the buffer         */
                   peXobject pEx     /* current expression object  */
  )@{
</PRE></FONT>
<P>
The error value is <font size="3"><tt>EX_ERROR_SUCCESS</tt></font> (zero) menaing succesful conversion or
<font size="3"><tt>EX_ERROR_TOO_LONG_VARIABLE</tt></font> meaning that the variable is too long for the
buffer.
<P>
Note that the buffer is allocated in <a href="#2.4.3.19.">ex_init()</A> according to the size value given in
the class variable <font size="3"><tt>cbBuffer</tt></font>, which should be set by the main function calling
syntax analysis.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.22."><H4>2.4.3.22. ex_IsBFun()</H4></A>

This function checks if the current lexeme is a built-in function and
returns pointer to the function in the table <font size="3"><tt>BuiltInFunctions</tt></font> or
returns NULL if the symbol is not a built-in function.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pBFun ex_IsBFun(peXobject pEx
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.23."><H4>2.4.3.23. ex_IsUnop()</H4></A>

This function checks if the current lexeme is an unary operator and
returns the op code or zero if the lexem is not an unary operator.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
unsigned long ex_IsUnop(peXobject pEx
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.24."><H4>2.4.3.24. ex_IsBinop()</H4></A>

This function checks if the current lexeme is a binary operator of the given precedence
and returns the op code or zero.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
unsigned long ex_IsBinop(peXobject pEx,
               unsigned long precedence
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.25."><H4>2.4.3.25. ex_LeftValueList()</H4></A>

This function works up a <font size="3"><tt>leftvalue_list</tt></font> pseudo terminal and creates the nodes for it.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE_l ex_LeftValueList(peXobject pEx
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.26."><H4>2.4.3.26. ex_ExpressionList()</H4></A>

This function works up an <font size="3"><tt>expression_list</tt></font> pseudo terminal and creates
the nodes for it.
<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE_l ex_ExpressionList(peXobject pEx
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.27."><H4>2.4.3.27. ex_Local()</H4></A>

This function work up a <font size="3"><tt>local</tt></font> pseudo terminal. This does not create any node.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int ex_Local(peXobject pEx
  )@{
</PRE></FONT>
The return value is <font size="3"><tt>0</tt></font> if no error happens.
<P>
<font size="3"><tt>1</tt></font> means sytax error (the coming token is not a symbol)
<P>
<font size="3"><tt>2</tt></font> means that there is no local environment (aka. the <font size="3"><tt>local var</tt></font> is not inside a function)<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.28."><H4>2.4.3.28. ex_LocalList()</H4></A>

This function work up a <font size="3"><tt>local_list</tt></font> pseudo terminal. This does not generate any node.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int ex_LocalList(peXobject pEx
  )@{
</PRE></FONT>
The return value is <font size="3"><tt>0</tt></font> if no error happens.
<P>
<font size="3"><tt>1</tt></font> means sytax error (the coming token is not a symbol)
<P>
<font size="3"><tt>2</tt></font> means that there is no local environment (aka. the <font size="3"><tt>local var</tt></font> is not inside a function)<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.29."><H4>2.4.3.29. ex_Global()</H4></A>

This function work up a <font size="3"><tt>global</tt></font> pseudo terminal. This does not create any node.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int ex_Global(peXobject pEx
  )@{
</PRE></FONT>
The return value is <font size="3"><tt>0</tt></font> if no error happens or the error is semantic and was
reported (global variable redefinition).
<P>
<font size="3"><tt>1</tt></font> means syntax error (the coming token is not a symbol)<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.30."><H4>2.4.3.30. ex_GlobalList()</H4></A>

This function work up a <font size="3"><tt>global_list</tt></font> pseudo terminal. This does not generate any node.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int ex_GlobalList(peXobject pEx
  )@{
</PRE></FONT>
The return value is <font size="3"><tt>0</tt></font> if no error happens.
<P>
<font size="3"><tt>1</tt></font> means sytax error (the coming token is not a symbol)
<P>
<font size="3"><tt>2</tt></font> means the variable was already defined<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.31."><H4>2.4.3.31. ex_LookupUserFunction()</H4></A>

This function searches a user defined function and returns a pointer to the symbol table entry.
If the second argument <font size="3"><tt>iInsert</tt></font> is true the symbol is inserted into the table and an
undefined function is created. This is the case when a function is used before declared. If the
argument <font size="3"><tt>iInsert</tt></font> is fales <font size="3"><tt>NULL</tt></font> is returned if the function is not yet defined.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void **ex_LookupUserFunction(peXobject pEx,
                             int iInsert
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.32."><H4>2.4.3.32. ex_LookupGlobalVariable</H4></A>

This function searches the global variable symbol table to find the global variable
with the name stored in @code@{pEx-&gt;Buffer}. If the variable was not declared then this function
inserts the variable into the symbol table if the argument <font size="3"><tt>iInsert</tt></font> is true,
but nothing more: the symbol table entry remains <font size="3"><tt>NULL</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void **ex_LookupGlobalVariable(peXobject pEx,
                               int iInsert
  )@{
</PRE></FONT>
The function returns pointer to the pointer stored in the symbol table associated with the global
variable.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.33."><H4>2.4.3.33. ex_LookupLocallyDeclaredGlobalVariable</H4></A>

This function searches the global variable symbol table to find the global variable
with the name stored in @code@{pEx-&gt;Buffer}. If the variable was not declared then this function
return <font size="3"><tt>NULL</tt></font>. Othervise it returns a pointer to a <font size="3"><tt>void *</tt></font> pointer, which is 
<font size="3"><tt>NULL</tt></font>.
<P>
Note that this table is allocated when the program starts a <font size="3"><tt>sub</tt></font> or <font size="3"><tt>function</tt></font> (aka. when
we go local) and is used to register, which variables did the program declare
as global variables inside the subroutine. There is no any value associated with the symbols
in this table, as the symbols are also inserted into the global symbol table which serves
the purpose.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void **ex_LookupLocallyDeclaredGlobalVariable(peXobject pEx
  )@{
</PRE></FONT>
The function returns pointer to the pointer stored in the symbol table associated with the global
variable or <font size="3"><tt>NULL</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.34."><H4>2.4.3.34. ex_LookupLocalVariable</H4></A>

This function searches the local variable symbol table to find the local variable
with the name stored in @code@{pEx-&gt;Buffer}. If the variable was not declared and the argument <font size="3"><tt>iInsert</tt></font>
is true then then this function inserts the variable into the symbol table, 
but nothing more: the symbol table entry remains
<font size="3"><tt>NULL</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void **ex_LookupLocalVariable(peXobject pEx,
                              int iInsert
  )@{
</PRE></FONT>
The function returns pointer to the pointer stored in the symbol table associated with the global
variable.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.35."><H4>2.4.3.35. ex_Tag</H4></A>

This function implements the syntax analysis for the lowest syntax elements of an expression.
This function is called when syntax analysis believes that a TAG has to be worked up
in an expression. A tag is defined formally as
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
 tag ::= UNOP tag
         BUN '(' expression_list ')'
         NUMBER
         STRING
         '(' expression ')'
         VARIABLE @{ '[' expression_list ']' }
         VARIABLE '@{' expression_list '}'
         FUNC '(' expression_list ')'
        .
</PRE></FONT>
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE ex_Tag(peXobject pEx
  )@{
</PRE></FONT>
The function returns pointer to the new node.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.36."><H4>2.4.3.36. ex_Expression_i</H4></A>

This function is called to analyze a sub-expression that has no lower precedence operators
than <font size="3"><tt>i</tt></font> (unless enclosed in parentheses inside the sub expression).
<P>
If the argument variable <font size="3"><tt>i</tt></font> is <font size="3"><tt>1</tt></font> then this function simply calls <a href="#2.4.3.35.">ex_Tag</A>. Otherwise it
calls itself recursively twice with optionally compiling the operator between the 
two subexpressions.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE ex_Expression_i(peXobject pEx,
                       int i
  )@{
</PRE></FONT>
The function returns pointer to the new node.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.37."><H4>2.4.3.37. ex_Expression_r</H4></A>

This function implements the syntax analysis for an expression. This is quite simple. It only
calls <a href="#2.4.3.36.">ex_Expression_i</A> to handle the lower precendece expression. 
<FONT SIZE="3" COLOR="BLUE"><PRE>
void ex_Expression_r(peXobject pEx,
                     peNODE *Result
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.38."><H4>2.4.3.38. ex_IsSymbolValidLval(pEx)</H4></A>

This function checks whether the actual symbol used in as a start symbol of a left value
is defined as a CONST in the BASIC program or not. If this is a const then the syntax analizer
has to report an error (since v1.0b31).
<P>
This function is called from the function <a href="#2.4.3.39.">ex_LeftValue</A> after the symbol was name space corrected.
<P>
Note that a symbol can be a global, name space independant constant, a name space local constant and
a function local constant. All these differ only in name decoration inside the interpreter.
<P>
If a symbol is a local variable but is also a module or global symbol, but is NOT a function local symbol
then that variable can indeed stand on the left side of a LET command. Therefore we check if the symbol
is in the local variables table and in case this is in some of the global or module contant table,
we just do not care.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int ex_IsSymbolValidLval(peXobject pEx
  )@{
</PRE></FONT>
The function returns 1 if the symbol is a constant or zero if not.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.39."><H4>2.4.3.39. ex_LeftValue</H4></A>

This function implements the syntax analisys for a left value.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE ex_LeftValue(peXobject pEx
  )@{
</PRE></FONT>
The function returns pointer to the new node.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.40."><H4>2.4.3.40. ex_PredeclareGlobalLongConst()</H4></A>

This function is used to declare the global constants that are given
in the syntax defintinon, and should be defined before the program
is started to be analized.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int ex_PredeclareGlobalLongConst(peXobject pEx,
                                 char *pszConstName,
                                 long lConstValue
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.41."><H4>2.4.3.41. ex_IsCommandThis</H4></A>

This is the most general syntax analysis function that tries to match the syntax
of the actual line syntax provided in argument <font size="3"><tt>p</tt></font> against the token list at the actual
position.
<P>
The function has several side effects altering optionally the global and local variable table,
define user defined functions and so on.
<P>
The function signals the success of its operation via the argument <font size="3"><tt>piFailure</tt></font> setting the <font size="3"><tt>int</tt></font>
pointed by it to be zero or the error code.
<P>
If the syntax does not match the token list then the function cleans up all its actions if possible
to allow the caller to iterate over to the next syntax defintion. In such a situation
<font size="3"><tt>*piFailure</tt></font> is set <font size="3"><tt>EX_ERROR_SYNTAX</tt></font>
<P>
If the syntax does not match the token list but the analysis went too far and had side effects that
cannot be reversed then no cleanup is made. In such a situation <font size="3"><tt>*piFailure</tt></font> is set
<font size="3"><tt>EX_ERROR_SYNTAX_FATAL</tt></font>.
<P>
<font size="3"><tt>*piFailure</tt></font> is also set to this value if the syntax definition reaches a "star" point. If the syntax
analysis matches a line up to a "star" point then the line should match that syntax definition or is
known erroneous. For example a command starting with the two keywords <font size="3"><tt>'declare' 'command'</tt></font> after these
two keywords reach a "star" point because no other line syntax but extrenal command declaration starts
with these two keywords. In such a situation signalling fatal syntax error saves the compiler time
to check other syntax definition.
<P>
A "star" point is named this way, because the file <font size="3"><tt>syntax.def</tt></font> uses the character <font size="3"><tt>*</tt></font> to denote
this point in the syntax definitions.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE ex_IsCommandThis(peXobject pEx,
                        pLineSyntax p,
                        int *piFailure
  )@{
</PRE></FONT>
If the syntax analysis fully matches the syntax definition provided in the argument
then the function returns the node that was generated. If more then one nodes were generated
during the syntax analysis of the line then the root node of the generated nodes is returned.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.42."><H4>2.4.3.42. ex_Command_r()</H4></A>

This function finds the matching sytax line for the actual line in a loop. It
starts with the first syntax definition and goes on until there are no more
syntax defintions, a fatal error has happened or the actual line is matched.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void ex_Command_r(peXobject pEx,
                  peNODE *Result,
                  int *piFailure
  )@{
</PRE></FONT>
<font size="3"><tt>pEx</tt></font> is the execution object.
<P>
<font size="3"><tt>Result</tt></font> is the resulting node.
<P>
<font size="3"><tt>piFailure</tt></font> is the error code.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.43."><H4>2.4.3.43. ex_Command_l()</H4></A>

This function goes over the source lines and performs the syntax analysis. This 
function calls the function <a href="#2.4.3.42.">ex_Command_r()</A>. When that function returns it
allocated the list nodes that chain up the individual lines. It also defines
the labels that are waiting to be defined.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int ex_Command_l(peXobject pEx,
                  peNODE_l *Result
  )@{
</PRE></FONT>
When all the lines are done this function cleans the name space stack,
check for undefined labels that remained undefined still the end 
of the source file.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.44."><H4>2.4.3.44. ex_Pragma</H4></A>

This function implements the compiler directive "declare option".
<P>
When the compiler finds a "declare option" directive it calls this function.
The first argument is the compiler class pointer. The second argument points
to a constant string containing the option.
<P>
The function implements the internal settings of the compiler options reflecting
the programmer needs expressed by the option. For example DeclareVars will
require all variables declared to be either global or local.
<P>
If the programmer specified an option, which is not implemented the error reporting
function is called.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int ex_Pragma(peXobject pEx,
              char *pszPragma
  )@{
</PRE></FONT>
<P>
The function returns <font size="3"><tt>0</tt></font> when the option was processed, and <font size="3"><tt>1</tt></font> when not implemented
option was supplied as argument.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.45."><H4>2.4.3.45. ex_IsCommandCALL()</H4></A>

Because the syntax of a call statement is very special here is a special
function to analyze the CALL statement.
<P>
A call statement is a keyword CALL followed by a function call.
<P>
If the function or sub is already defined then the keyword CALL can be missing.
<P>
When the function or sub is called this way and not inseide an expression the
enclosing parentheses can be missing.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE ex_IsCommandCALL(peXobject pEx,
                        pLineSyntax p,
                        int *piFailure
  )@{
</PRE></FONT>
<P>
To get some description of waiting labels see the description of the function <a href="#2.4.3.7.">ex_PushWaitingLabel()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.46."><H4>2.4.3.46. ex_IsCommandOPEN()</H4></A>

The open statement is a simple one. The only problem is that the last parameter
defining the length of a record is optional. This can only be handled using a separate
function
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE ex_IsCommandOPEN(peXobject pEx,
                        pLineSyntax p,
                        int *piFailure
  )@{
</PRE></FONT>
<P>
'open' expression 'for' absolute_symbol 'as' expression 'len' '=' expression nl<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.47."><H4>2.4.3.47. ex_IsCommandSLIF()</H4></A>

If syntax analysis gets to calling this function the command is surely
not single line if, because the command SLIF is recognised by <font size="3"><tt>IsCommandIF</tt></font>.
<P>
The syntax of the command IF is presented in the syntax table before
SLIF and therefore if the syntax analyser gets here it can not be
SLIF.
<P>
The original function <font size="3"><tt>IsCommandThis</tt></font> could also do failing automatically,
but it is simpler just to fail after the function call, so this function
is just a bit of speedup.
<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE ex_IsCommandSLIF(peXobject pEx,
                        pLineSyntax p,
                        int *piFailure
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.48."><H4>2.4.3.48. ex_IsCommandIF()</H4></A>

The statement IF is quite simple. However there is another
command that has almost the same syntax as the IF statement.
This is the SLIF, single line IF.
<P>
The difference between the command IF and SLIF is that SLIF does
not have the new line character after the keyword <font size="3"><tt>THEN</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE ex_IsCommandIF(peXobject pEx,
                        pLineSyntax p,
                        int *piFailure
  )@{
</PRE></FONT>
<P>
IF/IF:    'if' * expression 'then' go_forward(IF) nl
SLIF/SLIF:  'slif' * expression 'then'<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.4.3.49."><H4>2.4.3.49. ex_IsCommandLET()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
peNODE ex_IsCommandLET(peXobject pEx,
                       pLineSyntax p,
                       int *piFailure
  )@{
</PRE></FONT>
<P>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5."><H2>2.5. Builder</H2></A>

The module is implemented in the file `<font size="3"><tt>builder.c</tt></font>'.
<P>
The rule of the builder is to compile the code created by the syntax analyzer into a continuous memory area. This compilation phase has two advantages. First of all it results a compact code which can easily saved into external file and can also be loaded making recompilation unnecessary before each execution. The second advantage is that the resulting code is smaller and saves memory.
<P>
When the syntax analyzer starts its work the final size of the code is not known. Therefore the syntax analyzer starts to build up a memory structure using pointers, linked lists allocating memory step by step as the code grows. Each command, expression element is stored in an internal structure, which is called a node. For example a node containing the operation "plus" contains the node type, which says it is an operator "plus" and contains two pointers to the two operands. The operands are also nodes. If the operand is a number the node contains the value of the number and the node type telling that it is a <font size="3"><tt>long</tt></font> or <font size="3"><tt>double</tt></font> number. If the operand is a variable the node type tells that the node is a variable and the node contains the serial number of the variable. If the operand needs further evaluation then the node is probably an operation having arguments pointed by pointers.
<P>

The structure that the builder creates is same as that of the syntax analyzer but it is allocated in a single memory chunk and instead of pointers it uses indices to refer a node from another. These indices are numbered from 1 and not from zero. This is because the index zero is used for <font size="3"><tt>NULL</tt></font> pointer if you know what I mean.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.1."><H3>2.5.1. Node Structure</H3></A>

Have a look at the C definition of a node:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
typedef struct _cNODE {
  long OpCode; // the code of operation
  union {
    struct {// when the node is a command
      unsigned long next;
      union {
        unsigned long pNode;// node id of the node
        long lLongValue;
        double dDoubleValue;
        unsigned long szStringValue;
        }Argument;
      }CommandArgument;
    struct {//when the node is an operation
      unsigned long Argument;//node id of the node list head
      }Arguments;
    union {// when the node is a constant
<P>
      double dValue;        
      long   lValue;        
      unsigned long sValue; // serial value of the string from the string table       
      }Constant;
    struct {// when the node is a variable
      unsigned long Serial;// the serial number of the variable
      }Variable;
    struct {// when node is a user functions
      unsigned long NodeId; // the entry point of the function
      unsigned long Argument; // node id of the node list head
      }UserFunction;
    struct {// when the node is a node list head
      unsigned long actualm; //car
      unsigned long rest;    //cdr
      }NodeList;
    }Parameter;
  } cNODE,*pcNODE;
</PRE></FONT>
<P>
The field <font size="3"><tt>OpCode</tt></font> is the same as the code used in the lexer or the syntax analyzer. In case of an <font size="3"><tt>IF</tt></font> statement it is <font size="3"><tt>CMD_IF</tt></font>. This field can, should and is used to identify which part of the union <font size="3"><tt>Parameter</tt></font> is to be used.
<P>
The individual lines of the BASIC program that create code are chained into a list. Each line has a head node. The <font size="3"><tt>OpCode</tt></font> of the head nodes is <font size="3"><tt>eNTYPE_LST</tt></font>. This type of node contains <font size="3"><tt>NodeList</tt></font> structure. The field <font size="3"><tt>NodeList.actualm</tt></font> contains the index of the first node of the actual line and the field <font size="3"><tt>NodeList.rest</tt></font> contains the index of the next header node.
<P>
This type of node is used to gather expression lists into a linked list.
<P>
Note that usually not the first node in the byte-code is the first head node, where the code is to be started. The nodes generated from a line are created before the head node is allocated in the syntax analyzer and the head node thus gets a larger serial number. The builder uses the serial numbers counted by the syntax analyzer and does not rearrange the nodes.
<P>
The command node that the field <font size="3"><tt>NodeList.actualm</tt></font> "points" contains the opcode of the command. For example if the actual command is <font size="3"><tt>IF</tt></font> then the <font size="3"><tt>OpCode</tt></font> is <font size="3"><tt>CMD_IF</tt></font>.
<P>
In case of command nodes the <font size="3"><tt>Parameter</tt></font> is <font size="3"><tt>CommandArgument</tt></font>. If the command has only a single argument the field <font size="3"><tt>next</tt></font> is zero. Otherwise this field contains the node index of the node holding the next argument.
<P>
The <font size="3"><tt>Parameter.CommandArgument.Argument</tt></font> union contains the actual argument of the command. There is no indication in the data structure what type the argument is. The command has to know what kind of arguments it gets, and should not interpret the union different.
<P>
The field <font size="3"><tt>pNode</tt></font> is the node index of the parameter. This is the case for example when the parameter is an expression or a label to jump to.
<P>
The fields <font size="3"><tt>lLongValue</tt></font>, <font size="3"><tt>dDoubleValue</tt></font> and <font size="3"><tt>szStringValue</tt></font> contain the constant values in case the argument is a constant. However this is actually not the string that is stored in the field <font size="3"><tt>szStringValue</tt></font> but the index to the string table where the string is started. (Yes, here is some inconsistency in naming.)
<P>
Strings are stored in a string table where each string is stored one after the other. Each string is terminated with a zero character and each string is preceded by a <font size="3"><tt>long</tt></font> value that indicates the length of the string. The zero character termination eases the use of the string constants when they have to be passed to the operating system avoiding the need to copy the strings in some cases.
<P>

The field <font size="3"><tt>Parameter.CommandArgument.next</tt></font> is zero in case there are no more arguments of the command, or the index of the node containing the next argument. The <font size="3"><tt>OpCode</tt></font> field of the following arguments is <font size="3"><tt>eNTYPE_CRG</tt></font>.
<P>
When the node is part of an expression and represents an operation or the call of a built-in function then the <font size="3"><tt>Arguments</tt></font> structure of the <font size="3"><tt>Parameter</tt></font> union is to be used. This simply contains <font size="3"><tt>Argument</tt></font> that "points" to a list of "list" nodes that list the arguments in a list. In this case the <font size="3"><tt>OpCode</tt></font> is the code of the built-in function or operation.
<P>
When the node represents a string or a numeric constant the <font size="3"><tt>Constant</tt></font> union field of the union <font size="3"><tt>Parameter</tt></font> should be used. This stores the constant value similar as the field <font size="3"><tt>CommandArgument</tt></font> except that it can only be <font size="3"><tt>long</tt></font>, <font size="3"><tt>double</tt></font> or a string. In case of constant node the <font size="3"><tt>OpCode</tt></font> is  <font size="3"><tt>eNTYPE_DBL</tt></font> for a <font size="3"><tt>double</tt></font>, <font size="3"><tt>eNTYPE_LNG</tt></font> for a <font size="3"><tt>long</tt></font> and <font size="3"><tt>eNTYPE_STR</tt></font> for a string.
<P>
When the node represents a variable the field <font size="3"><tt>Variable</tt></font> has to be used. In this case the field <font size="3"><tt>Serial</tt></font> contains the serial number of the variable. To distinguish between local and global variables the <font size="3"><tt>OpCode</tt></font> is either <font size="3"><tt>eNTYPE_LVR</tt></font> for local variables or <font size="3"><tt>eNTYPE_GVR</tt></font> for global variables.
<P>
When the node is a user defined function call the field <font size="3"><tt>UserFunction</tt></font> is used. Note that this is not the node that is generated from the line <font size="3"><tt>sub/function myfunc</tt></font> but rather when the function or subroutine is called. The <font size="3"><tt>OpCode</tt></font> is <font size="3"><tt>eNTYPE_FUN</tt></font>.
<P>
The field <font size="3"><tt>NodeId</tt></font> is the index of the node where the function or subroutine starts. The field <font size="3"><tt>Argument</tt></font> is the index of the list node that starts the list of the argument expressions.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.2."><H3>2.5.2. Binary File Format</H3></A>

The built code is usually saved to a cache file and this file is used later to load the already compiled code into memory for subsequent execution. The format of this file can be read from the function <font size="3"><tt>build_SaveCode</tt></font> in file `<font size="3"><tt>builder.c</tt></font>'. This function is quite linear it just saves several structures and is well commented so you should not have problem to understand it. However here I also give some description on the format of the binary file.
<P>
The binary file may or may not start with a textual line. This line is the usual UNIX <font size="3"><tt>#! /usr/bin/scriba</tt></font> string telling the operating system how to execute the text file. Altough we are talking now about a binary file, from the operating system point of view this is just a file, like a ScriptBasic source file, a Perl script or a <font size="3"><tt>bash</tt></font> script. The operating system starts to read the file and if the start of the file is something like
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
#! /usr/bin/scriba\n
</PRE></FONT>
<P>
with a new-line character at the end then it can be executed from the command line if some other permission related constraints are met.
<P>
When ScriptBasic saves the binary format file it uses the same executable path that was given in the source file. If the source file starts with the line
<font size="3"><tt>#! /usr/bin/mypath/scriba</tt></font> and the basic progam `<font size="3"><tt>myprog.bas</tt></font>' was started using the command line
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
/usr/bin/scriba -o myprog.bbf myprog.bas
</PRE></FONT>
<P>
then the file `<font size="3"><tt>myprog.bbf</tt></font>' will start with the line <font size="3"><tt>#! /usr/bin/mypath/scriba</tt></font>.
<P>
The user's guide lists a small BASIC program that reads and writes the binary file and alters this line.
<P>
Having this line on the first place in the binary format BASIC file makes it possible to deliver programs in compiled format. For example you may develop a CGI application and deliver it as compiled format to protect your program from the customer. You can convert your source issuing the command line
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
/usr/bin/scriba -o outputdirectory/myprog.bas myprog.bas
</PRE></FONT>
<P>
and deliver the binary `<font size="3"><tt>myprog.bas</tt></font>' to the customer. ScriptBasic does not care the file extension and does not expect a file with the extension <font size="3"><tt>.bas</tt></font> to be source BASIC. It automatically recognizes binary format BASIC programs and thus you need no alter even the URLs that refer to CGI BASIC programs.
<P>
The next byte in the file following this optional opening line is the size of a <font size="3"><tt>long</tt></font> on the machine the code was created. The binary code is not necessarily portable from one machine to another. It depends on pointer and <font size="3"><tt>long</tt></font> size as well as byte ordering. We experienced Windows NT and Linux to create the same binary file but this is not a must, may change.
<P>
The size of a <font size="3"><tt>long</tt></font> is stored in a single character as <font size="3"><tt>sizeof(long)+0x30</tt></font> so the ASCII character is either <font size="3"><tt>'4'</tt></font> or <font size="3"><tt>'8'</tt></font> on 32 and 64 bit machines.
<P>
This byte is followed by the version information. This is a <font size="3"><tt>struct</tt></font>:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
  unsigned long MagicCode;
  unsigned long VersionHigh, VersionLow;
  unsigned long MyVersionHigh,MyVersionLow;
  unsigned long Build;
  unsigned long Date;
  unsigned char Variation[9];
</PRE></FONT>
<P>
The <font size="3"><tt>MagicCode</tt></font> is <font size="3"><tt>0x1A534142</tt></font>. On DOS based system this is the characters 'BAS' and <font size="3"><tt>^Z</tt></font> which means end of text file. Thus if you issue the command
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
C:\&gt; type mybinaryprogram.bbf
</PRE></FONT>
<P>
you will get
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
4BAS
</PRE></FONT>
<P>
without scrambling your screen. If you use UNIX system then be clever enough not to <font size="3"><tt>cat</tt></font> a binary program to the terminal.
<P>
The values <font size="3"><tt>VersionHigh</tt></font> and <font size="3"><tt>VersionLow</tt></font> are the version number of ScriptBasic core code. This is currently <font size="3"><tt>1</tt></font> and <font size="3"><tt>0</tt></font>. The fields <font size="3"><tt>MyVersionHigh</tt></font> and <font size="3"><tt>MyVersionLow</tt></font> are reserved for developers who develop a variation of ScriptBasic. The variation may alter some features and still is based on the same version of the core code. These two version fields are reserved here to distinguish between different variation versions based on the same core ScriptBasic code. To maintain these version numbers is essential for those who embed ScriptBasic into an application, especially if the different versions of the variations alter the binary file format which I doubt is really needed.
<P>
The field <font size="3"><tt>Build</tt></font> is the build of the core ScriptBasic code.
<P>
The <font size="3"><tt>Date</tt></font> is date when the file `<font size="3"><tt>builder.c</tt></font>' was compiled. The date is stored in a <font size="3"><tt>long</tt></font> in a tricky way that ensures that no two days result the same <font size="3"><tt>long</tt></font> number. In case you want to track how this is coded see the function <font size="3"><tt>build_MagicCode</tt></font> in file `<font size="3"><tt>builder.c</tt></font>'. This is really tricky.
<P>

The final field is <font size="3"><tt>Variation</tt></font> which is and should be an exactly 8 character long string and a zero character.
<P>
If you want to compile a different variation then alter the <font size="3"><tt>#define</tt></font> directives in the file `<font size="3"><tt>builder.c</tt></font>'
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
#define VERSION_HIGH 0x00000001
#define VERSION_LOW  0x00000000
#define MYVERSION_HIGH 0x00000000
#define MYVERSION_LOW  0x00000000
#define VARIATION "STANDARD"
</PRE></FONT>
<P>

<P>
To successfully load a binary format file to run in ScriptBasic the long size, the magic code, version information including the build and the variation string should match. Date may be different.
<P>
The following foru <font size="3"><tt>long</tt></font> numbers in the binary file define 
<UL>
<LI> the number of global variables, 
<LI> the number of the nodes of the compiled program
<LI> the index of the start node where the execution should be started
<LI> the length of the string table
</UL>
<P>
This is followed by the nodes themselves and the stringtable.
<P>
This is the last point that has to exist in a binary format file of a BASIC program. The following bytes are optional and may not be present in the file.
<P>
The optional part contains the size of the function table defined on a <font size="3"><tt>long</tt></font> and the function table. After this the size of the global variable table is stored in a <font size="3"><tt>long</tt></font> and the global variable table.
<P>
The global variable and function symbol table are list of elements, each containing a <font size="3"><tt>long</tt></font> followed by the zero character terminated symbolic name. The <font size="3"><tt>long</tt></font> stores the serial number of the variable or the entry point of the function (the node index where the function starts).
<P>
These two tables are not used by ScriptBasic by itself, ScriptBasic does not need any symbolic information to execute a BASIC program. Programmers embedding ScriptBasic however demanded access global variables by name and the ability to execute individual functions from a BASIC program. If this last part is missing from a binary format BASIC program you will not be able to use in an application that uses these features.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3."><H3>2.5.3. Functions implemented in this module</H3></A>

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.
<P>

<P>

<P>

<P>
This module can and should be used to create the memory image for the
executor module from the memory structure that was created by the module
<font size="3"><tt>expression</tt></font>.
<P>
The memory structure created by <font size="3"><tt>expression</tt></font> is segmented, allocated
in many separate memory chunks. When the module <font size="3"><tt>expression</tt></font> has been finished
the size of the memory is known. This builder creates a single memory 
chunk containing all the program code.
<P>
Note that the function names all start with the prefix <font size="3"><tt>build_</tt></font> in this module.
<P>
The first argument to each function is a pointer to a <font size="3"><tt>BuildObject</tt></font> structure
that contains the "global" variables for the module. This technique is used to ensure
multithread usage. There are no global variables which are really global within the
process.
<P>
The functions in this module are:
<P>
=toc<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.1."><H4>2.5.3.1. The structure of the string table</H4></A>

The string table contains all string contansts that are used in the program.
This includes the single and multi line strings as well as symbols. (note that
even the variable name after the keyword <font size="3"><tt>next</tt></font> is ignored but stored in the
string table).
<P>
The strings in the string table are stored one after the other zero character
terminated. Older version of ScriptBasic v1.0b21 and before stored string
constants zero character terminated. Because of this string constants containing
zero character were truncated (note that <font size="3"><tt>\000</tt></font> creates a zero character in a
string constant in ScriptBasic).
<P>
The version v1.0b22 changed the way string constants are stored and the way
string table contains the strings. Each string is stored with its length.
The length is stored as a <font size="3"><tt>long</tt></font> on <font size="3"><tt>sizeof(long)</tt></font> bytes. This is followed by
the string. Whenever the code refers to a string the byte offset of the first
character of the string is stored in the built code. For example the very first
string starts on the 4. byte on 32 bit machines.
<P>
Altough the string length and zero terminating characters are redundant information
both are stored to avoid higher level mistakes causing problem.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.2."><H4>2.5.3.2. build_AllocateStringTable()</H4></A>

This function allocates space for the string table. The size of the
string table is already determined during syntax analysis. The determined
size should be enough. In some cases when there are repeated string constants
the calculated sizte is bigger than the real one. In that case the larger memory
is allocated and used, but only the really used part is written to the cache file.
<P>
If the program does not use any string constants then a dummy string table of length
one byte is allocated.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void build_AllocateStringTable(pBuildObject pBuild,
                          int *piFailure
  )@{
</PRE></FONT>
<P>
The first argument is the usual pointer to the "class" structure. The second argument
is the result value. It can have two values:
<P>
<UL>
<LI> <font size="3"><tt>BU_ERROR_SUCCESS</tt></font> which is guaranteed zero, means the function was successful.
<LI> <font size="3"><tt>BU_ERROR_MEMORY_LOW</tt></font> means the memory allocation function could not allocate the
neccessary memory
@end itemize
<P>
The string table is allocated using the function <font size="3"><tt>alloc_Alloc</tt></font>. The string table
is pointed by the class variable <font size="3"><tt>StringTable</tt></font>. The size of the table is stored in
<font size="3"><tt>cStringTable</tt></font><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.3."><H4>2.5.3.3. build_StringIndex()</H4></A>

In the built code all the strings are references using the offset of the string
from the string table (See <a href="#2.5.3.2.">build_AllocateStringTable()</A>). This function calculates this value
for the string.
<P>
This function is used repetitively during the code building. Whenever a string index is
sought that is not in the string table yet the string is put into the table and the
index is returned.
<P>
If there is not enough space in the string table the function calls the system function
<font size="3"><tt>exit</tt></font> and stops the process. This is rude especially in a multithread application
but it should not ever happen. If this happens then it is a serious internal error.
<FONT SIZE="3" COLOR="BLUE"><PRE>
unsigned long build_StringIndex(pBuildObject pBuild,
                                char *s,
                                long sLen
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.4."><H4>2.5.3.4. build_Build_l()</H4></A>

This function converts an <font size="3"><tt>eNODE_l</tt></font> list to <font size="3"><tt>cNODE</tt></font> list in a loop.
This function is called from <a href="#2.5.3.6.">build_Build()</A> and from <a href="#2.5.3.5.">build_Build_r()</A>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int build_Build_l(pBuildObject pBuild,
                  peNODE_l Result
  )@{
</PRE></FONT>
The function returns the error code, or zero in case of success.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.5."><H4>2.5.3.5. build_Build_r()</H4></A>

This function builds a single node. This actually means copiing the values
from the data structure created by the module <font size="3"><tt>expression</tt></font>. The major
difference is that the pointers of the original structure are converted to
<font size="3"><tt>unsigned long</tt></font>. Whenever a pointer pointed to a <font size="3"><tt>eNODE</tt></font> the <font size="3"><tt>unsigned long</tt></font>
will contain the <font size="3"><tt>NodeId</tt></font> of the node. This ID is the same for the <font size="3"><tt>eNODE</tt></font> and
for the <font size="3"><tt>cNODE</tt></font> that is built from the <font size="3"><tt>eNODE</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int build_Build_r(pBuildObject pBuild,
                  peNODE Result
  )@{
</PRE></FONT>
<P>
The node to be converted is passed by the pointer <font size="3"><tt>Result</tt></font>. The return value is
the error code. It is zero (<font size="3"><tt>BU_ERRROR_SUCCESS</tt></font>) in case of success.
<P>
When the node pointed by <font size="3"><tt>Result</tt></font> references other nodes the function recursively
calls itself to convert the referenced nodes.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.6."><H4>2.5.3.6. build_Build()</H4></A>

This is the main entry function for this module. This function initializes the
class variable pointed by <font size="3"><tt>pBuild</tt></font> and calls <a href="#2.5.3.4.">build_Build_l()</A> to build up the 
command list.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int build_Build(pBuildObject pBuild
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.7."><H4>2.5.3.7. build_MagicCode()</H4></A>

This is a simple and magical calculation that converts any ascii date to
a single unsigned long. This is used as a magic value in the binary format
of the compiled basic code to help distinguish incompatible versions.
<P>
This function also fills in the sVersion static struct that contains the version
info.
<FONT SIZE="3" COLOR="BLUE"><PRE>
unsigned long build_MagicCode(pVersionInfo p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.8."><H4>2.5.3.8. build_SaveCCode()</H4></A>

This function saves the binary code of the program into the file
given by the name <font size="3"><tt>szFileName</tt></font> in C programming language format.
<P>
The saved file can be compiled using a C compiler on the platform it was
saved. The generated C file is not portable.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void build_SaveCCode(pBuildObject pBuild,
                    char *szFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.9."><H4>2.5.3.9. build_SaveCorePart()</H4></A>

This function saves the binary content of the compiled file into an
already opened file. This is called from both <font size="3"><tt>build_SaveCode</tt></font> and from
<font size="3"><tt>build_SaveECode</tt></font>.
<P>
Arguments:
<UL>
<LI> <font size="3"><tt>pBuild</tt></font> is the build object
<LI> <font size="3"><tt>fp</tt></font> is the <font size="3"><tt>FILE *</tt></font> file pointer to an already binary write opened (<font size="3"><tt>"wb"</tt></font>) file.
@end itemize
<P>
The file <font size="3"><tt>fp</tt></font> is not closed even if error occures while writing the file.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int build_SaveCorePart(pBuildObject pBuild,
                       FILE *fp,
                       unsigned long fFlag
  )@{
</PRE></FONT>
The function returns <font size="3"><tt>BU_ERROR_SUCCESS</tt></font> (zero) if there was no error or <font size="3"><tt>BU_ERROR_FAIL</tt></font> if the function fails
writing the file.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.10."><H4>2.5.3.10. build_SaveCore()</H4></A>

This function saves the binary content of the compiled file into an
already opened file. This is called from both <font size="3"><tt>build_SaveCode</tt></font> and from
<font size="3"><tt>build_SaveECode</tt></font>.
<P>
Arguments:
<UL>
<LI> <font size="3"><tt>pBuild</tt></font> is the build object
<LI> <font size="3"><tt>fp</tt></font> is the <font size="3"><tt>FILE *</tt></font> file pointer to an already binary write opened (<font size="3"><tt>"wb"</tt></font>) file.
@end itemize
<P>
The file <font size="3"><tt>fp</tt></font> is not closed even if error occures while writing the file.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int build_SaveCore(pBuildObject pBuild,
                   FILE *fp
  )@{
</PRE></FONT>
The function returns <font size="3"><tt>BU_ERROR_SUCCESS</tt></font> (zero) if there was no error or <font size="3"><tt>BU_ERROR_FAIL</tt></font> if the function fails
writing the file.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.11."><H4>2.5.3.11. build_SaveCode()</H4></A>

This function saves the binary code of the program into the file
given by the name <font size="3"><tt>szFileName</tt></font>.
<P>
This version is hard wired saving the code into an operating system
file because it uses <font size="3"><tt>fopen</tt></font>, <font size="3"><tt>fclose</tt></font> and <font size="3"><tt>fwrite</tt></font>. Later versions
may use other compatible functions passed as argument and thus allowing
output redirection to other storage media (a database for example).
<P>
However I think that this code is quite simple and therefore it is easier
to rewrite the whole function along with <a href="#2.5.3.16.">build_LoadCode()</A> for other storage
media than writing an interface function.
<P>
The saved binary code is NOT portable. It saves the internal values
as memory image to the disk. It means that the size of the code depends
on the actual size of long, char, int and other types. The byte ordering
is also system dependant.
<P>
The saved binary code can only be loaded with the same version, and build of
the program, therefore it is vital to distinguish each compilation of
the program. To help the recognition of the different versions, the code starts
with a version structure.
<P>
The very first byte of the code contains the size of the long on the target machine.
If this is not correct then the code was created on a different processor and the code
is incompatible.
<P>
The version info structure has the following fileds:
<UL>
<LI> <font size="3"><tt>MagicCode</tt></font> is a magic constant. This contains the characters BAS and a character 1A that
stops output to screen on DOS operating systems.
<LI> <font size="3"><tt>VersionHigh</tt></font> The high part of the version of the STANDARD version.
<LI> <font size="3"><tt>VersionLow</tt></font> The low part of the version of the STANDARD version.
<LI> <font size="3"><tt>MyVersionHigh</tt></font> The high part of the version of the variation.
This is always zero for the STANDARD version.
<LI> <font size="3"><tt>MyVersionLow</tt></font>  The low part of the version of the variation.
This is always zero for the STANDARD version.
<LI> <font size="3"><tt>Build</tt></font> A build code which is automatically calculated from the compilation date.
<LI> <font size="3"><tt>Variation</tt></font> 8 characters (NOT ZERO TERMINATED!) naming the version "STANDARD" for the
STANDARD version (obvious?)
@end itemize
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int build_SaveCode(pBuildObject pBuild,
                   char *szFileName
  )@{
</PRE></FONT>
The function returns zero on success (<font size="3"><tt>BU_ERROR_SUCCESS</tt></font>) and <font size="3"><tt>BU_ERROR_FAIL</tt></font>
if the code could not be saved.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.12."><H4>2.5.3.12. build_SaveECode()</H4></A>

This function saves the binary code of the program into the file
given by the name <font size="3"><tt>szFileName</tt></font> in exe format.
<P>
This is actually nothing but the copy of the original interpreter file and
the binary code of the BASIC program appended to it and some extra information
at the end of the file to help the reader to find the start of the binary 
BASIC program when it tries to read the exe file.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void build_SaveECode(pBuildObject pBuild,
                     char *pszInterpreter,
                     char *szFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.13."><H4>2.5.3.13. build_GetExeCodeOffset()</H4></A>

This function checks that the actually running exe contains the binary BASIC program
attached to its end. It returns zero if not, otherwise it returns 1.
<P>
<UL>
<LI> The argument <font size="3"><tt>pszInterpreter</tt></font> should be <font size="3"><tt>argv[0]</tt></font> thus the code can open the executable
file and check if it really contains the BASIC code
<LI> <font size="3"><tt>plOffset</tt></font> should point to a long variable ready to recieve the file offset where the BASIC
code starts
<LI> <font size="3"><tt>plEOFfset</tt></font> should point to a long variable ready to receive the file offset where the
BASIC code finishes. This is the position of the last byte belonging to the BASIC code, thus if
<font size="3"><tt>ftell(fp) </tt></font>&gt;<font size="3"><tt> *plEOFfset</tt></font> means the file pointer is after the code and should treat it as EOF
condition when reading the BASIC program code.
@end itemize
<P>
It is guaranteed that both <font size="3"><tt>*plOffset</tt></font> and <font size="3"><tt>*plEOFfset</tt></font> will be set to <font size="3"><tt>0</tt></font> (zero) if the file
proves to be a standard BASIC interpreter without appended BASIC code.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int build_GetExeCodeOffset(char *pszInterpreter,
                            long *plOffset,
                            long *plEOFfset
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.14."><H4>2.5.3.14. build_LoadCore()</H4></A>

This function loads the binary code from an opened file.
<P>
Arguments:
<P>
<UL>
<LI> <font size="3"><tt>pBuild</tt></font> is the build object
<LI> <font size="3"><tt>szFileName</tt></font> is the name of the file that is opened. Needed for reporting purposes.
<LI> <font size="3"><tt>fp</tt></font> opened <font size="3"><tt>FILE *</tt></font> file pointer opened for binary reading (aka <font size="3"><tt>"rb"</tt></font>), and positioned where the
BASIC code starts.
<LI> <font size="3"><tt>lEOFfset</tt></font> should be the position of the last byte that belongs to the BASIC code so that <font size="3"><tt>ftell(fp)</tt></font>&gt;<font size="3"><tt>lEOFfset</tt></font>
is treated as EOF condition. If this value is zero that means that the BASIC code is contained in the file until the
physical end of file.
@end itemize
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void build_LoadCore(pBuildObject pBuild,
                    char *szFileName,
                    FILE *fp,
                    long lEOFfset
  )@{
</PRE></FONT>
Note that the program does not return error code, but calls the reporting function to report error. The file <font size="3"><tt>fp</tt></font> is not closed in the
function even if error has happened during reading.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.15."><H4>2.5.3.15. build_LoadCodeWithOffset()</H4></A>

For detailed definition of the binary format see the code and the documentation of
<a href="#2.5.3.11.">build_SaveCode()</A>
<P>
In case the file is corrupt the function reports error.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void build_LoadCodeWithOffset(pBuildObject pBuild,
                              char *szFileName,
                              long lOffset,
                              long lEOFfset
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.16."><H4>2.5.3.16. build_LoadCode()</H4></A>

For detailed definition of the binary format see the code and the documentation of
<a href="#2.5.3.11.">build_SaveCode()</A>
<P>
In case the file is corrupt the function reports error.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void build_LoadCode(pBuildObject pBuild,
                    char *szFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.17."><H4>2.5.3.17. build_IsFileBinaryFormat()</H4></A>

This function test a file reading its first few characters and decides
if the file is binary format of a basic program or not.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int build_IsFileBinaryFormat(char *szFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.18."><H4>2.5.3.18. build_pprint()</H4></A>

This is a debug function that prints the build code into a file.
<P>
This function is not finished and the major part of it is commented out using <font size="3"><tt>#if 0</tt></font> construct.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void build_pprint(pBuildObject pBuild,
                  FILE *f
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.19."><H4>2.5.3.19. build_CreateFTable()</H4></A>

When the binary code of the BASIC program is saved to disk the symbol table of the user
defined functions and the symbol table of global variables is also saved. This may be needed
by some applications that embed ScriptBasic and want to call specific function or alter global variables
of a given name from the embedding C code. To do this they need the serial number of the global variable
or the entry point of the function. Therefore ScriptBasic v1.0b20 and later can save these two tables into
the binary code.
<P>
The format of the tables is simple optimized for space and for simplicity of generation. They are stored
first in a memory chunk and then written to disk just as a series of bytes.
<P>
The format is
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long      serial number of variable or entry point of the function
zchar     zero character terminated symbol
</PRE></FONT>
<P>
This is easy to save and to load. Searching for it is a bit slow. Embedding applications usually
have to search for the values only once, store the serial number/entry point value
in their local variable and use the value.
<P>
The function <font size="3"><tt>CreateFTable</tt></font> converts the symbol table of user defined function
collected by symbolic analysis into a single memory chunk.
<P>
The same way <a href="#2.5.3.20.">build_CreateVTable()</A> converts the symbol table of global variables
collected by symbolic analysis into a single memory chunk.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int build_CreateFTable(pBuildObject pBuild
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.20."><H4>2.5.3.20. build_CreateVTable()</H4></A>

When the binary code of the BASIC program is saved to disk the symbol table of the user
defined functions and the symbol table of global variables is also saved. This may be needed
by some applications that embed ScriptBasic and want to call specific function or alter global variables
of a given name from the embedding C code. To do this they need the serial number of the global variable
or the entry point of the function. Therefore ScriptBasic v1.0b20 and later can save these two tables into
the binary code.
<P>
The format of the tables is simple optimized for space and for simplicity of generation. They are stored
first in a memory chunk and then written to disk just as a series of bytes.
<P>
The format is
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long      serial number of variable or entry point of the function
zchar     zero character terminated symbol
</PRE></FONT>
<P>
This is easy to save and to load. Searching for it is a bit slow. Embedding applications usually
have to search for the values only once, store it in their local variable and use the value.
<P>
The function <a href="#2.5.3.19.">build_CreateFTable()</A> converts the symbol table of user defined function
collected by symbolic analysis into a single memory chunk.
<P>
The same way <font size="3"><tt>CreateVTable</tt></font> converts the symbol table of global variables
collected by symbolic analysis into a single memory chunk.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int build_CreateVTable(pBuildObject pBuild
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.21."><H4>2.5.3.21. build_LookupFunctionByName()</H4></A>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long build_LookupFunctionByName(pBuildObject pBuild,
                          char *s
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.5.3.22."><H4>2.5.3.22. build_LookupVariableByName()</H4></A>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long build_LookupVariableByName(pBuildObject pBuild,
                          char *s
  )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6."><H2>2.6. Executor</H2></A>

The executor kills the code. Oh, no! I was just kidding. It executes the code, which means something different. Starts with the first node and goes on.
<P>
The execution of the code starts calling the function <font size="3"><tt>execute_Execute</tt></font> implemented in the file `<font size="3"><tt>execute.c</tt></font>'
<P>
This function initializes the execution environment that was not initialized before calling the function <font size="3"><tt>execute_InitStructure</tt></font>
<P>
It allocates global variables, it fills command and instruction parameters and finalizer function pointers with <font size="3"><tt>NULL</tt></font> and starts the function <font size="3"><tt>execute_Execute_r</tt></font><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.1."><H3>2.6.1. Command parameters</H3></A>

Each command type has a pointer that it can use for its own purpose. This is to avoid using global variables. The file commands for example use the pointer available for the command <font size="3"><tt>OPEN</tt></font>. To access this pointer the macro <font size="3"><tt>PARAMPTR</tt></font> is used defined in the file `<font size="3"><tt>command.c</tt></font>'<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.2."><H3>2.6.2. Instrunction parameters</H3></A>

Not only the commands have a pointer for their use, but there are pointers available for each instruction. To make it clear:
<P>
If there are three <font size="3"><tt>OPEN</tt></font> statements in a program they share a <I>common command pointer</I>, but <I>each have its own instruction pointer</I>.
<P>
The code fragments implementing the different commands are free to use their own or any other related command or instruction pointer.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.3."><H3>2.6.3. Finalizer function</H3></A>

Finalizer function pointers are available for each command type. This way they are similar to command parameters. There can be many OPEN statements in a program they share a common finalizer pointer. Each finalizer pointer is initialized to <font size="3"><tt>NULL</tt></font>.
<P>
The code fragments may put a function entry address in the finalizer pointer. When the execution of a program is finished the executing function calls each function that has a non NULL pointer in the finalizer array.
<P>
The <font size="3"><tt>_r</tt></font> in the function name tells that this is a recursive function that may call itself when an expression evaluation performs a function or subroutine call.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4."><H3>2.6.4. Functions implemented in this module</H3></A>

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.
<P>

<P>

<P>

<P>
This module contain the functions that execute the code resuled by the builder.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.1."><H4>2.6.4.1. execute_GetCommandByName()</H4></A>

The op-code of a command can easily be identified, because <font size="3"><tt>syntax.h</tt></font> contains
symbolic constant for it. This function can be used by external modules to
get this opcode based on the name of the function. The argument <font size="3"><tt>pszCommandName</tt></font>
should be the name of the command, for example <font size="3"><tt>"ONERRORRESUMENEXT"</tt></font>. The third 
argument is the hint for the function to help to find the value. It should always
be the opcode of the command. The return value is the actual opcode of the command.
For example:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
i = execute_GetCommandByName(pEo,"ONERRORRESUMENEXT",CMD_ONERRORRESUMENEXT);
</PRE></FONT>
<P>
will return <font size="3"><tt>CMD_ONERRORRESUMENEXT</tt></font>.
<P>
<I>Why is this function all about then?</I>
<P>
The reason is that the external module may not be sure that the code
<font size="3"><tt>CMD_ONERRORRESUMENEXT</tt></font> is the same when the external module is compiled
and when it is loaded. External modules negotiate the interface version
information with the calling interpreter, but the opcodes may silently changed
from interpreter version to the next interpreter version and still supporting
the same extension interface version.
<P>
When an external module needs to know the opcode of a command of the calling
interpreter it first calls this function telling:
<P>
I&lt;I need the code of the command ONERRORRESUMENEXT. I think that the code is
CMD_ONERRORRESUMENEXT, but is it the real code?&gt;
<P>
The argument <font size="3"><tt>lCodeHint</tt></font> is required only, because it speeds up search.
<P>
If there is no function found for the given name the returnvalue is zero.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long execute_GetCommandByName(pExecuteObject pEo,
                              char *pszCommandName,
                              long lCodeHint
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.2."><H4>2.6.4.2. execute_CopyCommandTable()</H4></A>

The command table is a huge table containing pointers to functions. For example
the <font size="3"><tt>CMD_LET</tt></font>-th element of the table points to the function <font size="3"><tt>COMMAND_LET</tt></font>
implementing the assignment command.
<P>
This table is usually treated as constant and is not moduified during run time.
In case a module wants to reimplement a command it should alter this table.
However the table is shared all concurrently running interpreter threads in
a multi-thread variation of ScriptBasic.
<P>
To avoid altering the command table of an independent interpreter threadthe module
wanting altering the command table should call this function. This function allocates
memory for a new copy of the command table and copies the original constant
value to this new place. After the copy is done the <font size="3"><tt>ExecuteObject</tt></font> will point to
the copied command table and the extension is free to alter the table.
<P>
In case the function is called more than once for the same interpreter thread
only the first time is effective. Later the function returns without creating superfluous
copies of the command table.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int execute_CopyCommandTable(pExecuteObject pEo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.3."><H4>2.6.4.3. execute_InitStructure()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
int execute_InitStructure(pExecuteObject pEo,
                          pBuildObject pBo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.4."><H4>2.6.4.4. execute_ReInitStructure()</H4></A>

This function should be used if a code is executed repeatedly. The first
initialization call is <a href="#2.6.4.3.">execute_InitStructure()</A> and consecutive executions
should call this function.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int execute_ReInitStructure(pExecuteObject pEo,
                            pBuildObject pBo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.5."><H4>2.6.4.5. execute_Execute_r()</H4></A>

This function executes a program fragment. The execution starts from the class variable
<font size="3"><tt>ProgramCounter</tt></font>. This function is called from the <a href="#2.6.4.8.">execute_Execute()</A> function which is the
main entry point to the basic main program. This function is also called recursively from
the function <a href="#2.6.4.10.">execute_Evaluate()</A> when a user defined function is to be executed.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void execute_Execute_r(pExecuteObject pEo,
                       int *piErrorCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.6."><H4>2.6.4.6. execute_InitExecute()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
void execute_InitExecute(pExecuteObject pEo,
                        int *piErrorCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.7."><H4>2.6.4.7. execute_FinishExecute()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
void execute_FinishExecute(pExecuteObject pEo,
                           int *piErrorCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.8."><H4>2.6.4.8. execute_Execute()</H4></A>

This function was called from the basic <font size="3"><tt>main</tt></font> function. This function performs inititalization
that is needed before each execution of the code and calls <a href="#2.6.4.5.">execute_Execute_r()</A> to perform the execution.
<P>
Note that <a href="#2.6.4.5.">execute_Execute_r()</A> is recursively calls itself.
<P>
This function is obsolete and is not used anymore. This is kept in the source
for the shake of old third party variations that may depend on this function.
<P>
Use of this function in new applications is discouraged.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void execute_Execute(pExecuteObject pEo,
                     int *piErrorCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.9."><H4>2.6.4.9. execute_ExecuteFunction()</H4></A>

This function is used by the embedding layer (aka <font size="3"><tt>scriba_</tt></font> functions) to execute a function.
This function is not directly called by the execution of a ScriptBasic program. It may be
used after the execution of the program by a special embeddign application that keeps the
code and the global variables in memory and calls functions of the program.
<P>
The function takes <font size="3"><tt>pEo</tt></font> as the execution environment. <font size="3"><tt>StartNode</tt></font> should be the node where the
sub or function is defined. <font size="3"><tt>cArgs</tt></font> should give the number of arguments. <font size="3"><tt>pArgs</tt></font> should point
to the argument array. <font size="3"><tt>pResult</tt></font> will point to the result. If <font size="3"><tt>pResult</tt></font> is <font size="3"><tt>NULL</tt></font> the result is
dropped. Otherwise the result is a mortal variable.
<P>
Note that this code does not check the number of arguments you provide. There can be more arguments
passed to the SUB than it has declared, therefore you can initialize the local variables of the sub.
(You should know that arguments are local variables in ScriptBasic just as any other non-argument local
variable.)
<P>
The arguments should be normal immortal variables. They are passed to the SUB by reference and in case
they are modified the old variable is going to be released.
<P>
<font size="3"><tt>piErrorCode</tt></font> returns the error code of the execution which is zero in case of no error.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void execute_ExecuteFunction(pExecuteObject pEo,
                             unsigned long StartNode,
                             long cArgs,
                             pFixSizeMemoryObject *pArgs,
                             pFixSizeMemoryObject *pResult,
                             int *piErrorCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.10."><H4>2.6.4.10. execute_Evaluate()</H4></A>

This function evaluates an expression. You should not get confused! This is not syntax analysis, caring
operator precedences and grouping by nested parentheses. That has already been done during syntax analysis.
This code performs the code that was generated from an expression.
<P>
The result is usually a mortal memory value which is the final result of the expression. However this piece of
code assumes that the caller is careful enough to handle the result as read only, and sometimes the return
value is not mortal. In this case the return value is a memory object that a variable points to. Whenever the
caller needs this value to perform an operation that does not alter the value it is OK. Duplicating the structure
to create a mortal would be waste of time and memory. On the other hand sometimes operations modify their operands
assuming that they are mortal values. They should be careful.
<P>
Operators are actually created in the directory <font size="3"><tt>commands</tt></font> and they use the macros defined in <font size="3"><tt>command.h</tt></font> (created
by <font size="3"><tt>headerer.pl</tt></font> from <font size="3"><tt>command.c</tt></font>). They help to avoid pitfalls.
<P>
The argument <font size="3"><tt>iArrayAccepted</tt></font> tells the function whether an array as a result is accepted or not. If a whole
array is accepted as a result of the expression evaluation the array is returned. If the array is not an
acceptable result, then the first element of the array is retuned in case the result is an array. If the result
is NOT an array this parameter has no effect.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject execute_Evaluate(pExecuteObject pEo,
                                      unsigned long lExpressionRootNode,
                                      pMortalList pMyMortal,
                                      int *piErrorCode,
                                      int iArrayAccepted
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.11."><H4>2.6.4.11. execute_LeftValue()</H4></A>

This function evaluate a left value. A left value is a special expression that value can be assigned, and therefore
they usually stand on the left side of the assignment operator. That is the reason for the name.
<P>
When an expression is evaluates a pointer to a memory object is returned. Whenever a left value is evaluated a pointer
to the variable is returned. If any code assignes value to the variable pointed by the return value of this function
it should release the memory object that the left value points currently.
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject *execute_LeftValue(pExecuteObject pEo,
                                        unsigned long lExpressionRootNode,
                                        pMortalList pMyMortal,
                                        int *piErrorCode,
                                        int iArrayAccepted
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.12."><H4>2.6.4.12. execute_EvaluateArray()</H4></A>

This function should be used to evaluate an array access to get the actual
value. This is called by <a href="#2.6.4.10.">execute_Evaluate()</A>.
<P>
An array is stored in the expression as an operator with many operands. The first
operand is a local or global variable, the rest of the operators are the indices.
<P>
Accessing a variable holding scalar value with array indices automatically converts
the variable to array. Accessing an array variable without indices gets the "first"
element of the array.
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject execute_EvaluateArray(pExecuteObject pEo,
                                      unsigned long lExpressionRootNode,
                                      pMortalList pMyMortal,
                                      int *piErrorCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.13."><H4>2.6.4.13. execute_EvaluateSarray()</H4></A>

This function should be used to evaluate an array access to get the actual
value. This is called by <a href="#2.6.4.10.">execute_Evaluate()</A>.
<P>
An array is stored in the expression as an operator with many operands. The first
operand is a local or global variable, the rest of the operators are the indices.
<P>
Associative arrays are normal arrays, only the access mode is different. When accessing
an array using the fom <font size="3"><tt>a@{key@</tt></font>} then the access searches for the value <font size="3"><tt>key</tt></font> in the 
evenly indexed elements of the array and gives the next index element of the array. This
if
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
a[0] = "kakukk"
a[1] = "birka"
a[2] = "kurta"
a[3] = "mamus"
</PRE></FONT>
<P>
then <font size="3"><tt>a@{"kakukk"@</tt></font>} is "birka". <font size="3"><tt>a@{"birka"@</tt></font>} is <font size="3"><tt>undef</tt></font>. <font size="3"><tt>a@{"kurta"@</tt></font>} is "mamus".
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject execute_EvaluateSarray(pExecuteObject pEo,
                                      unsigned long lExpressionRootNode,
                                      pMortalList pMyMortal,
                                      int *piErrorCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.14."><H4>2.6.4.14. execute_LeftValueArray()</H4></A>

This function evaluates an array access left value. This function is also called by <a href="#2.6.4.12.">execute_EvaluateArray()</A>
and the result pointer is dereferenced.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject *execute_LeftValueArray(pExecuteObject pEo,
                                             unsigned long lExpressionRootNode,
                                             pMortalList pMyMortal,
                                             int *piErrorCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.15."><H4>2.6.4.15. execute_LeftValueSarray()</H4></A>

This function evaluates an associative array access left value.
This function is also called by <a href="#2.6.4.13.">execute_EvaluateSarray()</A> and the result
pointer is dereferenced.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject *execute_LeftValueSarray(pExecuteObject pEo,
                                              unsigned long lExpressionRootNode,
                                              pMortalList pMyMortal,
                                              int *piErrorCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.16."><H4>2.6.4.16. execute_Convert2String()</H4></A>

This functionconverts a variable to string. When the variable is already a string then it returns the pointer to the
variable. When the variable is long or double <font size="3"><tt>sprintf</tt></font> is used to convert the number to string.
<P>
When the conversion from number to string is done the result is always a newly allocated mortal. In other words
this conversion routine is safe, not modifying the argument memory object.
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject execute_Convert2String(pExecuteObject pEo,
                                          pFixSizeMemoryObject pVar,
                                          pMortalList pMyMortal
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.17."><H4>2.6.4.17. execute_Convert2Long()</H4></A>

This function should be used to convert a variable to long. The conversion is
usually done in place. However strings can not be converted into long in place, because
they have different size. In such a case a new variable is created. If the mortal list <font size="3"><tt>pMyMortal</tt></font>
is <font size="3"><tt>NULL</tt></font> then the new variable in not mortal. In such a case care should be taken
to release the original variable.
<P>
Usually there is a mortal list and a new mortal variable is generated. In such a case
the original value is also a mortal and is automatically released after the command
executing the conversion is finished.
<P>
Note that strings are converted to long in two steps. The first step converts the string to
<font size="3"><tt>double</tt></font> and then this value is converted to long in-place.
<P>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject execute_Convert2Long(pExecuteObject pEo,
                                          pFixSizeMemoryObject pVar,
                                          pMortalList pMyMortal
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.18."><H4>2.6.4.18. execute_Convert2LongS()</H4></A>

This is the safe version of the conversion function <a href="#2.6.4.17.">execute_Convert2Long()</A>.
<P>
This function ALWAYS create a new variable and does NOT convert a
double to long in place. This function is called by the extensions,
because extensions tend to be more laisy regarding conversion and
many converts arguments in place and thus introduce side effect.
<P>
To solve this problem we have introduced this function and have
set the support table to point to this function.
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject execute_Convert2LongS(pExecuteObject pEo,
                                           pFixSizeMemoryObject pVar,
                                           pMortalList pMyMortal
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.19."><H4>2.6.4.19. execute_Convert2Double()</H4></A>

This function should be used to convert a variable to double. The conversion is
usually done in place. However strings can not be converted into double in place, because
they have different size. In such a case a new variable is created. If the mortal list
is <font size="3"><tt>NULL</tt></font> then the new variable in not mortal. In such a case care should be taken
to release the original variable.
<P>
Usually there is a mortal list and a new mortal variable is generated. In such a case
the original value is also a mortal and is automatically released after the command
executing the conversion is finished.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject execute_Convert2Double(pExecuteObject pEo,
                                            pFixSizeMemoryObject pVar,
                                            pMortalList pMyMortal
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.20."><H4>2.6.4.20. execute_Convert2DoubleS()</H4></A>

This is the safe version of the conversion function <a href="#2.6.4.19.">execute_Convert2Double()</A>.
<P>
This function ALWAYS create a new variable and does NOT convert a
long to double in place. This function is called by the extensions,
because extensions tend to be more laisy regarding conversion and
many converts arguments in place and thus introduce side effect.
<P>
To solve this problem we have introduced this function and have
set the support table to point to this function.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject execute_Convert2DoubleS(pExecuteObject pEo,
                                             pFixSizeMemoryObject pVar,
                                             pMortalList pMyMortal
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.21."><H4>2.6.4.21. execute_Convert2Numeric()</H4></A>

<P>
This function should be used to convert a variable to numeric type.
<P>
The conversion results a double or long variable. If the source variable
was already a long or double the function does nothing but results the
source variable.
<P>
<font size="3"><tt>undef</tt></font> is converted to long zero.
<P>
The function calls <a href="#2.6.4.17.">execute_Convert2Long</A> and <a href="#2.6.4.19.">execute_Convert2Double</A> thus
all other parameters are treated according to that.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject execute_Convert2Numeric(pExecuteObject pEo,
                                             pFixSizeMemoryObject pVar,
                                             pMortalList pMyMortal
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.22."><H4>2.6.4.22. execute_Dereference()</H4></A>

This function recursively follows variable references and returns
the original variable that was referenced by the original variable.
<P>
A reference variable is a special variable that does not hold value
itself but rather a pointer to another variable. Such reference variables
are used when arguments are passed by reference to BASIC subroutines.
<P>
Calling this function the caller can get the original variable and the
value of the original variable rather than a reference.
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject execute_Dereference(pExecuteObject pEo,
                                         pFixSizeMemoryObject p,
                                         int *piErrorCode
  )@{
</PRE></FONT>
See also <a href="#2.6.4.23.">execute_DereferenceS()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.23."><H4>2.6.4.23. execute_DereferenceS()</H4></A>

This function does the same as <a href="#2.6.4.22.">execute_Dereference()</A> except that it has
different arguments fitted to support external modules and <font size="3"><tt>besXXX</tt></font>
macros.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int execute_DereferenceS(unsigned long refcount,
                         pFixSizeMemoryObject *p
  )@{
</PRE></FONT>
See also <a href="#2.6.4.22.">execute_Dereference()</A>.
<P>
If the argument is referencing an <font size="3"><tt>undef</tt></font> value then this function
converts the argument to be a real <font size="3"><tt>NULL</tt></font> to allow external modules
to compare <font size="3"><tt>besDEREFERENCE</tt></font>d variables against <font size="3"><tt>NULL</tt></font>.
<P>
The subroutine is also error prone handling <font size="3"><tt>NULL</tt></font> pointer as argument,
though it should never be happen if the external module programmer
uses the macro <font size="3"><tt>besDEREFERENCE</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.24."><H4>2.6.4.24. execute_GetDoubleValue()</H4></A>

Use this function whenever you want to access the <B>value</B> of a variable as a <font size="3"><tt>double</tt></font>.
Formerly ScriptBasic in such situation converted the variable to double calling
<a href="#2.6.4.19.">execute_Convert2Double()</A> and then used the macro <font size="3"><tt>DOUBLEVALUE</tt></font>. This method is faster
because this does not create a new mortal variable but returns directly the
double value.
<P>
The macro <font size="3"><tt>GETDOUBLEVALUE</tt></font> can be used to call this function with the default
execution environment variable <font size="3"><tt>pEo</tt></font>
<P>
Note however that the macro <font size="3"><tt>GETDOUBLEVALUE</tt></font> and <font size="3"><tt>DOUBLEVALUE</tt></font> are not 
interchangeable. <font size="3"><tt>GETDOUBLEVALUE</tt></font> is returnig a <font size="3"><tt>double</tt></font> while 
<font size="3"><tt>DOUBLEVALUE</tt></font> is a left value available to store a <font size="3"><tt>double</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
double execute_GetDoubleValue(pExecuteObject pEo,
                              pFixSizeMemoryObject pVar
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.25."><H4>2.6.4.25. execute_GetLongValue()</H4></A>

Use this function whenever you want to access the <B>value</B> of a variable as a <font size="3"><tt>long</tt></font>.
Formerly ScriptBasic in such situation converted the variable to long calling
<a href="#2.6.4.17.">execute_Convert2Long()</A> and then used the macro <font size="3"><tt>LONGVALUE</tt></font>. This method is faster
because this does not create a new mortal variable but returns directly the
long value.
<P>
The macro <font size="3"><tt>GETLONGVALUE</tt></font> can be used to call this function with the default
execution environment variable <font size="3"><tt>pEo</tt></font>
<P>
Note however that the macro <font size="3"><tt>GETLONGVALUE</tt></font> and <font size="3"><tt>LONGVALUE</tt></font> are not 
interchangeable. <font size="3"><tt>GETLONGVALUE</tt></font> is returnig a <font size="3"><tt>long</tt></font> while 
<font size="3"><tt>LONGVALUE</tt></font> is a left value available to store a <font size="3"><tt>long</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long execute_GetLongValue(pExecuteObject pEo,
                          pFixSizeMemoryObject pVar
  )@{
</PRE></FONT>
<P>
Please also note that the result of converting a string variable to LONG and then
accessing its longvalue may not result the same number as calling this function.
The reason is that conversion of a string to a LONG variable is done in two steps.
First it converts the string to a <font size="3"><tt>double</tt></font> and then it rounds the <font size="3"><tt>double</tt></font> value
to <font size="3"><tt>long</tt></font>. On the other hand this function converts a string diretly to <font size="3"><tt>long</tt></font>.
<P>
For example the string <font size="3"><tt>"3.7"</tt></font> becomes 4 when converted to long and 3 when getting the
value as a long.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.26."><H4>2.6.4.26. execute_IsStringInteger()</H4></A>

This function should be used to check a string before converting it to numeric value.
If the string contains only digits it should be converted to <font size="3"><tt>long</tt></font>. If the string contains
other characters then it should be converted to double. This function decides what characters
the string contains.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int execute_IsStringInteger(pFixSizeMemoryObject pVar
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.6.4.27."><H4>2.6.4.27. execute_IsInteger()</H4></A>

This function checks that a variable being long, double or string can be
converted to long without loosing information.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int execute_IsInteger(pFixSizeMemoryObject pVar
  )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7."><H2>2.7. Configuration File Handling</H2></A>

ScriptBasic contains a fairly sophisticated configuration handling module. The configuration information is read each time the interpreter starts, therefore it is vital that the information can be processed fast even if the configuration data is complex. This can be the case because the configuration information may also contain data for external modules that the interpreter loads when it starts and the external modules can access it any time they run.
<P>
The configuration information for ScriptBasic has to be maintained in textual format in a file that has more or less LISP syntax.
<P>
The format of the text file version of the configuration information is simple. It contains the keys and the corresponding values separated by one or more spaces and new lines. Usually a key and the assigned value is written on a line. Lines starting with the character ; is comment.
<P>
The values can be integer numbers, real numbers, strings and sub-configurations. Strings can either be single line or multi-line strings starting and ending with three """ characters, just like in the language ScriptBasic or in the language Python.
<P>
Sub-configurations start with the character ( and are closed with the character ). The list between the parentheses are keys and corresponding values.
<P>
This text file has to be converted to binary format. The ScriptBasic interpreter loads this binary format into memory without processing its content, thus loading speed of the configuration information is limited only by IO.
<P>
When the interpreter or an external module needs some configuration information there are functions in this module that can search and read information from the configuration file.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1."><H3>2.7.1. Functions implemented in this module</H3></A>

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.1."><H4>2.7.1.1. cft_init()</H4></A>

Before calling any other configuration handling function the caller has to prepare a <font size="3"><tt>tConfigTree</tt></font>
structure. To do this it has to call this function.
<P>
The first argument has to point to an allocated and uninitialized <font size="3"><tt>tConfigTree</tt></font> structure. The second
argument has to point to a memory allocating function. The third argument has to point to the memory releasing
function that is capable releasing the memory allocated by the memory allocating function.
<P>
The argument <font size="3"><tt>pMemorySegment</tt></font> should be the segment pointer to the memory handling functions. All memory allocation
will be performed calling the <font size="3"><tt>memory_allocating_function</tt></font> and passing the <font size="3"><tt>pMemorySegment</tt></font> pointer as second argument
to it. All memory releasing will be done via the function <font size="3"><tt>memory_releasing_function</tt></font> passing 
<font size="3"><tt>pMemorySegment</tt></font> pointer as second argument. This lets the caller to use sophisticated memory handling architecture.
<P>
<B>On the other hand for the simple use</B> all these three arguments can be <font size="3"><tt>NULL</tt></font>. In this case the configuration
management system will use its own memory allocating and releasing function that simply uses <font size="3"><tt>malloc</tt></font> and <font size="3"><tt>free</tt></font>.
In this case <font size="3"><tt>pMemorySegment</tt></font> is ignored.
<P>
For a ready made module that delivers more features see the alloc module of the ScriptBasic project at
<font size="3"><tt>http://scriptbasic.com</tt></font>
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int cft_init(ptConfigTree pCT,
              void *(*memory_allocating_function)(size_t, void *),
              void (*memory_releasing_function)(void *, void *),
              void *pMemorySegment
  )@{
</PRE></FONT>
Note that suggested convention is to use the '<font size="3"><tt>.</tt></font>' character as separator for hierarchical key structures, but
this is only a suggestion. In other words the module writers advice is to use <font size="3"><tt>key.subkey.subsubkey</tt></font> as key string
for hierarchical strings. On the other hand you can use any character as separator except the zero character and
except the characters that are used as key characters. You can write
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
key\subkey\subsubkey
</PRE></FONT>
<P>
if you are a windows geek. To do this you have to change the character saying
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
    pCT-&gt;TC = '\\';
</PRE></FONT>
<P>
after calling the initialization function. You can change this character any time, this character is not
used in the configuration structure. The only point is that you have to use the actual character when you have
changed it. The best practice is to use the dot  ever.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.2."><H4>2.7.1.2. cft_GetConfigFileName()</H4></A>

This function tries to locate the configuration file. The working of this function
is system dependant. There are two different implementations: one for UNIX and one for Win32.
<P>
<B>WIN32</B>
<P>
On Win32 systems the function tries to read the system registry. The value of the key given in the argument
<font size="3"><tt>env</tt></font> is used and returned as the config file name. For example if the argument <font size="3"><tt>env</tt></font> is
<font size="3"><tt>Software\myprog\conf</tt></font> then the registry value of the key <font size="3"><tt>HKEY_LOCAL_MACHINE\Software\myprog\conf</tt></font> will
be returned as configuration file name. The program does not check that the file really exists. It only
checks that the registry key exists, it is a string and has some value.
<P>
If the registry key does not exists the program tries to locate the system directory getting the environment
variable <font size="3"><tt>windir</tt></font>, then <font size="3"><tt>systemroot</tt></font> and finally taking <font size="3"><tt>c:\WINDOWS</tt></font>. The argument <font size="3"><tt>DefaultFileName</tt></font> is
appended to the directory name and is returned.
<P>
<B>UNIX</B>
<P>
On UNIX it is more simple. The environment variable <font size="3"><tt>env</tt></font> is used as a file name.
If this does not exists the <font size="3"><tt>DefaultFileName</tt></font> is used and returned.
<P>
<B>BOTH</B>
<P>
The return value of the function is zero if no error has happened. A pointer to the resulting file name
is returned in the variable <font size="3"><tt>ppszConfigFile</tt></font>. The space to hold the resulting file name is allocated
via the allocation function given by the <font size="3"><tt>tConfigTree</tt></font> structure pointed by <font size="3"><tt>pCT</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int cft_GetConfigFileName(ptConfigTree pCT,
                          char **ppszConfigFile,
                          char *env,/* environment variable or registry key on win32 */
                          char *DefaultFileName
  )@{
</PRE></FONT>
This function is <font size="3"><tt>static</tt></font> and can not be called from outside of this module.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.3."><H4>2.7.1.3. cft_start()</H4></A>

When writing real applications you usually want to call this function. This function initializes the
<font size="3"><tt>tConfigTree</tt></font> structure pointed by <font size="3"><tt>pCT</tt></font>, searches for the configuration file and reads it.
<P>
When trying to allocate the configuration file the static internal function <a href="#">GetConfigFileName</A> is used.
<P>
The argument <font size="3"><tt>Envir</tt></font> is the registry key under <font size="3"><tt>HKLM</tt></font>, eg <font size="3"><tt>Software\Myprog\conf</tt></font> under Win32 or
the environment variable to look for the configuration file name. The argument <font size="3"><tt>pszDefaultFileName</tt></font>
is the file name searched on WIN32 in the system directories or the full path to the default configuration
file nam eunder UNIX. The argument <font size="3"><tt>pszForcedFileName</tt></font> can overrride the file name search or
has to be <font size="3"><tt>NULL</tt></font> to let the reader search the environment and registry for file name.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int cft_start(ptConfigTree pCT,
              void *(*memory_allocating_function)(size_t, void *),
              void (*memory_releasing_function)(void *, void *),
              void *pMemorySegment,
              char *Envir,
              char *pszDefaultFileName,
              char *pszForcedFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.4."><H4>2.7.1.4. strmyeq()</H4></A>

This is an internal <font size="3"><tt>static</tt></font> function that compares two strings and returns true iff they
are equal. The string terminator is the usual zero character or the dot. Both are legal terminators
for this functions and their difference in the compared strings is not treated as difference in the result.
If one string is terminated by zero character and the other is terminated by a dot but they are the same in any
other character then the return value is true.
<P>
This function is used find a sub-key when the caller has specified a dot separated hierarchical key.
<P>
Note that the dot is only a convention and the default value for the separator and the caller has 
<FONT SIZE="3" COLOR="BLUE"><PRE>
/**/
static int strmyeq(ptConfigTree pCT,char *a, char *b)@{
</PRE></FONT>
This function is <font size="3"><tt>static</tt></font> and can not be called from outside of this module.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.5."><H4>2.7.1.5. cft_FindNode()</H4></A>

Find a node starting from the start node <font size="3"><tt>lStartNode</tt></font>
and searching for the <font size="3"><tt>key</tt></font>.
<P>
The function returns zero if the key is not found in the configuration
information tree <font size="3"><tt>pCT</tt></font> or returns the node id of the key. This node
can either be an internal node or leaf.
<P>
Note that the string <font size="3"><tt>key</tt></font> may contain dot characters. In this case the
key is searched down in the configuration tree. (You can set the separator character
different from the dot character.)
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
CFT_NODE cft_FindNode(ptConfigTree pCT,
                      CFT_NODE lStartNode,
                      char *key
  )@{
</PRE></FONT>
You need this function when you want to iterate over the sub-keys of a node. You get the
node id for the key and then you can call <a href="#2.7.1.8.">cft_EnumFirst</A> to start the loop and then <a href="#2.7.1.9.">cft_EnumNext</A> to
iterate the loop over the sub-keys.
<P>
If you just want to get the value of a single key you can call the function <a href="#2.7.1.6.">cft_GetEx</A> that
uses this function.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.6."><H4>2.7.1.6. cft_GetEx()</H4></A>

Get the value associated with the key <font size="3"><tt>key</tt></font> from the configuration
structure <font size="3"><tt>pCT</tt></font>, or get the values of a node.
<P>
The arguments:
<P>
<UL>
<LI> <font size="3"><tt>pCT</tt></font> the configuration information searched.
<LI> <font size="3"><tt>key</tt></font> the key that we search the value for, or NULL if we already
      know the node id where the needed information is.
<LI> <font size="3"><tt>plNodeId</tt></font> the id of the node that we need information from. If the
      key argumentum is not NULL then this argument is overwritten with the
      node id associated with the key. If the argument key is NULL this
      argument should specify the id of the node we need information from.
      If the node id is not needed upon return this argument may point to NULL.
<LI> <font size="3"><tt>ppszValue</tt></font> will return a pointer to a constant ZCHAR string if
      the value associated with <font size="3"><tt>key</tt></font> is string. If the argument is <font size="3"><tt>NULL</tt></font>
      then the function ignore this argument.
<LI> <font size="3"><tt>plValue</tt></font> will return a <font size="3"><tt>long</tt></font> if the value associated with
      <font size="3"><tt>key</tt></font> is integer. If the argument is <font size="3"><tt>NULL</tt></font>
      then the function ignore this argument.
<LI> <font size="3"><tt>pdValue</tt></font> will return a <font size="3"><tt>double</tt></font> if the value associated with
      <font size="3"><tt>key</tt></font> is a real number. If the argument is <font size="3"><tt>NULL</tt></font>
      then the function ignore this argument.
<LI> <font size="3"><tt>type</tt></font> will return the type of the key. This can be
  <UL>
  <LI> <font size="3"><tt>CFT_NODE_BRANCH</tt></font> if the key is associated with a subtree.
  <LI> <font size="3"><tt>CFT_TYPE_STRING</tt></font> if the key is associated with a string
  <LI> <font size="3"><tt>CFT_TYPE_INTEGER</tt></font> if the key is associated with an integer number
  <LI> <font size="3"><tt>CFT_TYPE_REAL</tt></font> if the key is associated with a real number
  @end itemize
  This argument can also be NULL if the caller is not interested in the
  type of the value.
@end itemize
<P>
Note that any of <font size="3"><tt>ppszValue</tt></font>, <font size="3"><tt>plValue</tt></font>, <font size="3"><tt>pdValue</tt></font> can point to a
variable or to <font size="3"><tt>NULL</tt></font> in case the caller does not need the actual value.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int cft_GetEx(ptConfigTree pCT,
              char *key,
              CFT_NODE *plNodeId,
              char **ppszValue,
              long *plValue,
              double *pdValue,
              int *type
  )@{
</PRE></FONT>
<P>
The function returns <font size="3"><tt>CFT_ERROR_SUCCESS</tt></font> if no error happens.
The value <font size="3"><tt>CFT_ERROR_SUCCESS</tt></font> is zero.
<P>
If an error happens the error code is returned. These error codes are:
<UL>
<LI> <font size="3"><tt>CFT_ERROR_NOT_FOUND</tt></font> the key is not present in the table, and
      <font size="3"><tt>*plNodeId</tt></font> will also be set to zero.
<LI> <font size="3"><tt>CFT_ERROR_NOTYPE</tt></font> the key is found but has a type that can not
      be returned, because the caller passed NULL as storage location.
      In this case the type of the configuration information is probably
      wrong.
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.7."><H4>2.7.1.7. cft_GetString()</H4></A>

This is the simplest interface function to retrieve a configuration
string. This assumes that you exactly know the name of the key and
you are sure that the value is a string. The function returns the pointer
to the constant string or returns NULL if the configuration key is not
present in the tree or the value is not a string.
<P>
The use of this function is not recommended. This function is present
in this package to ease porting of programs that use simpler configuration
information management software.
<FONT SIZE="3" COLOR="BLUE"><PRE>
char *cft_GetString(ptConfigTree pCT,
                    char *key
  )@{
</PRE></FONT>
This function calls <a href="#2.7.1.6.">cft_GetEx</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.8."><H4>2.7.1.8. cft_EnumFirst()</H4></A>

Whenever you need to enumerate the sub-keys of a key you have to
get the node associated with the key (see <a href="#2.7.1.6.">cft_GetEx</A> or <a href="#2.7.1.5.">cft_FindNode</A>).
When you have the node associated with the key you can get the node of the
first sub-key calling this function.
<P>
The function needs the node id <font size="3"><tt>lNodeId</tt></font> of the key for which
we need to enumerate the sub keys and returns the node id of the
first sub key.
<P>
If the key is associated with a leaf node the function returns zero.
<P>
If the key is associated with a branch node that has no sub-keys the
function returns zero.
<FONT SIZE="3" COLOR="BLUE"><PRE>
CFT_NODE cft_EnumFirst(ptConfigTree pCT,
                       CFT_NODE lNodeId
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.9."><H4>2.7.1.9. cft_EnumNext()</H4></A>

Whenever you need to enumerate the sub-keys of a key you have to
get the node associated with the key (see <a href="#2.7.1.6.">cft_GetEx</A> or <a href="#2.7.1.5.">cft_FindNode</A>).
When you have the node associated with the key you can get the node of the
first sub-key calling the function <a href="#2.7.1.8.">cft_EnumFirst</A>. Later on you can enumerate
the sub keys stepping from node to node calling this function.
<P>
The function needs the node id <font size="3"><tt>lNodeId</tt></font> returned by <a href="#2.7.1.8.">cft_EnumFirst</A> or
by previous call of this function.
<P>
The function returns the node id of the next sub key.
<P>
If the enumeration has ended, in other words there is no next sub-key the
function returns zero.
<FONT SIZE="3" COLOR="BLUE"><PRE>
long cft_EnumNext(ptConfigTree pCT,
                  long lNodeId
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.10."><H4>2.7.1.10. cft_GetKey()</H4></A>

This function returns a pointer to the constant zchar string that
holds the key of the node defined by the id <font size="3"><tt>lNodeId</tt></font>.
<FONT SIZE="3" COLOR="BLUE"><PRE>
char *cft_GetKey(ptConfigTree pCT,
                 CFT_NODE lNodeId
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.11."><H4>2.7.1.11. cft_ReadConfig()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
int cft_ReadConfig(ptConfigTree pCT,
                   char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.12."><H4>2.7.1.12. cft_WriteConfig()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
int cft_WriteConfig(ptConfigTree pCT,
                    char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.7.1.13."><H4>2.7.1.13. cft_DropConfig()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
void cft_DropConfig(ptConfigTree pCT
  )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8."><H2>2.8. Memory Allocation</H2></A>
This module is a general purpose memory allocation module, which can be used in any project
that needs heavy and sophisticated memory allocation. Originally the module was developed for
the ScriptBasic project. Later we used it for Index.hu Rt AdEgine project and multi-thread
features were introduced.
<P>
The major problem with memory allocation is that memory should be released. Old programs depend
on the operating system to release the memory when the process exists and do not release the memory
before program termination. Such programs are extremely difficult to port to multi-thread operation.
In multi thread operation a thread my exit, but the memory still belongs to the process that goes on.
<P>
This module provides a bit of abstraction that helps the programmer to release the memory. The abstraction is
the following:
<P>
A piece of memory is always allocated from a segment. A segment is logical entity and you should not think of
a segment in this content as a continuous memory area. I could also say that: whenever a piece of 
memory is allocated it is assigned to a segment. When a piece of memory is released it is removed from the segment.
A segment is an administrative entity that keep track of the memory pieces that were allocated and assigned to the
segment.
<P>
To explain segment to the fines details: segments are implemented as linked lists. Each element of the list contains
the allocated memory piece as well as a pointer to the next and previous list members.
<P>
Whenever the programmer starts a sophisticated task that allocates several memory pieces it has to create a new segment
and allocate the memory from that segment. When the memory is to be release the programmer can just say: release all the
memory from the segment. This way he or she does not need keep track of the allocated memory structures, and walk through
the memory pointers of his or her program which are designed to the program function instead of releasing the memory.
<P>
The overhead is the space allocated by two pointers for each memory piece and the size of the three pointers for
each segment.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1."><H3>2.8.1. Functions implemented in this module</H3></A>

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.1."><H4>2.8.1.1. Multi-thread use of this module</H4></A>

You can use this module in multi threaded environment. In this case the module depend on the module <font size="3"><tt>thread.c</tt></font>
which contains the thread and mutex interface functions that call the operating system thread and mutex functions
on UNIX and on Windows NT.
<P>
In single thread environment there is no need to use the locking mechanism. To get a single-thread version either you can
edit this file (<font size="3"><tt>myalloc.c</tt></font>) or compile is using the option <font size="3"><tt>-DMTHREAD=0</tt></font> The default compilation is multi threaded.
<P>
Multi thread implementation has two levels. One is that the subroutines implemented in this module call
the appropriate locking functions to ensure that no two concurrent threads access and modify the same data at a time
and thus assure that the data of the module is correct. The other level is that you can tell the module that the
underlying memory allocation and deallocation modules are mot thread safe. There are global variables
implementing global mutexes that are locked and unlocked if you use the module that way. This can be useful in some
environment where <font size="3"><tt>malloc</tt></font> and <font size="3"><tt>free</tt></font> are not thread safe.
<P>
Note that this should not be the case if you call <font size="3"><tt>malloc</tt></font> and <font size="3"><tt>free</tt></font> or you linked the wrong versio of libc.
However you may use a non-thread safe debug layer for example the one that ScriptBasic uses.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.2."><H4>2.8.1.2. alloc_InitSegment()</H4></A>

Call this function to get a new segment. You should specify the functions that the segement should use to
get memory from the operating system, and the function the segment should use to release the memory to the
operating system. These functions should be like <font size="3"><tt>malloc</tt></font> and <font size="3"><tt>free</tt></font>.
<P>
If the second argument is <font size="3"><tt>NULL</tt></font> then the function will treat the first argument as an already
allocated and initialized memory segment and the memory allocation and freeing functions will be
inherited from that segment.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void *alloc_InitSegment(void * (*maf)(size_t), /* a 'malloc' and a 'free' like functions */
                        void   (*mrf)(void *)
  )@{
</PRE></FONT>
<P>
The return value is a <font size="3"><tt>void*</tt></font> pointer which identifies the segment and should be passed to the other functions
as segment argument.
<P>
The first argument is the <font size="3"><tt>malloc</tt></font> like function and the second if the <font size="3"><tt>free</tt></font> like function.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.3."><H4>2.8.1.3. alloc_GlobalUseGlobalMutex()</H4></A>

Some installation use memory allocation function that are not thread safe. On some
UNIX installations <font size="3"><tt>malloc</tt></font> is not thread safe. To tell the module that all the allocation
function primitives are not thread safe call this function before initializing any segment.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void alloc_GlobalUseGlobalMutex(
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.4."><H4>2.8.1.4. alloc_SegmentLimit()</H4></A>

You can call this function to set a segment limit. Each segment keeps track of the actual memory
allocated to the segment. When a new piece of memory allocated in a segment the calculated segment
size is increased by the size of the memory chunk. When a piece of memory is release the calculated
size of the segment is decreased.
<P>
Whenever a segment approaches its limit the next allocation function requesting memory
that would exceed the limit returns <font size="3"><tt>NULL</tt></font> and does not allocate memory.
<P>
The value of the limit is the number of bytes allowed for the segment. This is the requested number of
bytes without the segment management overhead.
<P>
Setting the limit to zero means no limit except the limits of the underlying memory allocation layers,
usually <font size="3"><tt>malloc</tt></font>.
<P>
You can dynamically set the limit during handling the memory at any time except that you should not
set the limit to zero unless the segment is empty and you should not set the limit to a positive value
when the actual limit is zero (no limit) and the segment is not empty. This restriction is artificial
in this release but is needed to be followed to be compatible with planned future developments.
<P>
This function sets the limit for the segment pointed by <font size="3"><tt>p</tt></font> and returns the old value of the segment.
<FONT SIZE="3" COLOR="BLUE"><PRE>
long alloc_SegmentLimit(void *p,
                        unsigned long NewMaxSize
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.5."><H4>2.8.1.5. alloc_FreeSegment()</H4></A>

Use this function to release all the memory that was allocated to the segment <font size="3"><tt>p</tt></font>.
Note that after calling this function the segment is still usable, only the memory
that it handled was released. If you do not need the segment anymore call the function
<a href="#2.8.1.6.">alloc_FinishSegment()</A> that calls this function and then releases the memory allocated to store
the segment information.
<P>
Sloppy programmers may pass <font size="3"><tt>NULL</tt></font> as argument, it just returns.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void alloc_FreeSegment(void *p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.6."><H4>2.8.1.6. alloc_FinishSegment()</H4></A>

Use this function to release all the memory that was allocated to the segment <font size="3"><tt>p</tt></font>.
This function also releases the memory of the segment head and therefore the
segment pointed by <font size="3"><tt>p</tt></font> is not usable anymore.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void alloc_FinishSegment(void *p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.7."><H4>2.8.1.7. alloc_Alloc()</H4></A>

Use this function to allocate a memory piece from a segment.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void *alloc_Alloc(size_t n,
                  void *p
  )@{
</PRE></FONT>
<P>
The first argument is the size to be allocated. The second argument is the
segment which should be used for the allocation.
<P>
If the memory allocation fails the function returns <font size="3"><tt>NULL</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.8."><H4>2.8.1.8. alloc_Free()</H4></A>

You should call this function whenever you want to release a single piece of memory
allocated from a segment. Note that you also have to pass the segment pointer as the
second argument, because the segment head pointed by this <font size="3"><tt>void</tt></font> pointer contains the
memory releasing function pointer.
<P>
Sloppy programmers may try to release <font size="3"><tt>NULL</tt></font> pointer without harm.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void alloc_Free(void *pMem, void *p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.9."><H4>2.8.1.9. alloc_Merge()</H4></A>

Call this function in case you want to merge a segment into another. This can be the
case when your program builds up a memory structure in several steps.
<P>
This function merges the segment <font size="3"><tt>p2</tt></font> into <font size="3"><tt>p1</tt></font>. This means that the segment <font size="3"><tt>p1</tt></font> will
contain all the memory pieces that belonged to <font size="3"><tt>p2</tt></font> before and <font size="3"><tt>p2</tt></font> will not contain any
allocated memory. However the segment <font size="3"><tt>p2</tt></font> is still valid and can be used to allocated memory
from. If you also want to finish the segment <font size="3"><tt>p2</tt></font> call the function <a href="#2.8.1.10.">alloc_MergeAndFinish()</A>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void alloc_Merge(void *p1, void *p2
  )@{
</PRE></FONT>
<P>
Note that the two segments SHOULD use the same, or at least compatible system memory handling functions!
You better use the same functions for both segments.
<P>
Example:
<P>
ScriptBasic builds up a sophisticated memory structure during syntactical analysis. This memory structure
contains the internal code generated from the program lines of the basic program. When ScriptBasic analyses
a line it tries several syntax descriptions. It checks each syntax defintion against the tokens of the line
until it finds one that fits. These checks need to build up memory structure. However if the check fails and
ScriptBasic should go for the next syntac definition line to check the memory allocated during the failed
checking should be released. Therefore these memory pieces are allocated from a segment that the program
calls <font size="3"><tt>pMyMemorySegment</tt></font>. If the syntax check fails this segment if freed. If the syntax check succedes this
segment is merged into another segement that contains the memory structures allocated from the previous basic program
lines.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.10."><H4>2.8.1.10. alloc_MergeAndFinish()</H4></A>
Use this function in case you not only want to merge a segment into another but you also
want to finish the segment that was merged into the other.
<P>

See also <a href="#2.8.1.9.">alloc_Merge()</A>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void alloc_MergeAndFinish(void *p1, void *p2
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.11."><H4>2.8.1.11. alloc_InitStat()</H4></A>

This function initializes the global statistical variables. These variables
can be used in a program to measure the memory usage.
<P>
This function should be called before any other memory handling function.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void alloc_InitStat(
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.12."><H4>2.8.1.12. alloc_GlobalGetStat()</H4></A>

From period to period the code using this memory management layer may need to know
how much memory the program is using.
<P>
Calling this function from time to time you can get the minimum and maximum memory
that the program used via this layer since the last call to this function or since
program start in case of the first call.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void alloc_GlobalGetStat(unsigned long *pNetMax,
                         unsigned long *pNetMin,
                         unsigned long *pBruMax,
                         unsigned long *pBruMin,
                         unsigned long *pNetSize,
                         unsigned long *pBruSize
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.8.1.13."><H4>2.8.1.13. alloc_GetStat()</H4></A>

From period to period the code using this memory management layer may need to know
how much memory the program is using.
<P>
Calling this function from time to time you can get the minimum and maximum memory
that the program used via this layer since the last call to this function or since
program start in case of the first call.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void alloc_GetStat(void *p,
                   unsigned long *pMax,
                   unsigned long *pMin,
                   unsigned long *pActSize
  )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9."><H2>2.9. Variable Allocation</H2></A>

This module implemented in the source file `<font size="3"><tt>memory.c</tt></font>' provides functions to allocate and deallocate memory for BASIC variables. This module itself allocates memory calling the underlying allocation module implemented in the file `<font size="3"><tt>myalloc.c</tt></font>'. The role of this module is to help ScriptBasic to reuse the allocated memory used for BASIC variable value store effectively.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1."><H3>2.9.1. Functions implemented in this module</H3></A>

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.1."><H4>2.9.1.1. memory_InitStructure()</H4></A>

Each execution context should have its own memory object responsible for the administration
of the variables and the memory storing the values assigned to variables.
<P>
This function initializes such a memory object.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int memory_InitStructure(pMemoryObject pMo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.2."><H4>2.9.1.2. memory_RegisterType()</H4></A>

This function should be used to register a variable type. The return value
is the serial number of the type that should later be used to reference the type.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int memory_RegisterType(pMemoryObject pMo,
                        unsigned long SizeOfThisType
  )@{
</PRE></FONT>
The argument of the function is the size of the type in terms of bytes. Usually this
is calculated using the C structure <font size="3"><tt>sizeof</tt></font>.
<P>
If the type can not be registered -1 is returned.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.3."><H4>2.9.1.3. memory_RegisterTypes()</H4></A>

This function should be used to initialize the usual <font size="3"><tt>FixSizeMemoryObject</tt></font> types. This
sets some usual string sizes, but the caller may not call this function and set different
size objects.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void memory_RegisterTypes(pMemoryObject pMo
  )@{
</PRE></FONT>
This function registers the different string sizes. In the current implementation a string has
at least 32 characters. If this is longer that that (including the terminating zchar) then
a 64 byte fix size object is allocated. If this is small enough then a 128 byte fix size memory
object is allocated and so on up to 1024 bytes. If a string is longer that that then a LARGE_OBJECT_TYPE
is allocated.
<P>
The reason to register these types is that this memory management module keeps a list for these
memory pieces and when a new short string is needed it may be available already without calling
<font size="3"><tt>malloc</tt></font>. On the other hand when a <font size="3"><tt>LARGE_OBJECT_TYPE</tt></font> value is released it is always passed back
to the operating system calling <font size="3"><tt>free</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.4."><H4>2.9.1.4. memory_DebugDump()</H4></A>

This is a debugging function that dumps several variable data to the standard output.
The actual behavior of the function may change according to the actual debug needs.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void memory_DebugDump(pMemoryObject pMo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.5."><H4>2.9.1.5. memory_NewVariable()</H4></A>

This function should be used whenever a new variable is to be allocated.
The function returns a pointer to a <font size="3"><tt>FixSizeMemoryObject</tt></font> structure that
holds the variable information and pointer to the memory that stores the
actual value for the memory.
<P>
If there is not engough memory or the calling is illegal the returned value is <font size="3"><tt>NULL</tt></font>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewVariable(pMemoryObject pMo,
                                        int type,
                                        unsigned long LargeBlockSize
  )@{
</PRE></FONT>
<P>
The second argument gives the type of the memory object to be allocated. If this
value is <font size="3"><tt>LARGE_BLOCK_TYPE</tt></font> then the third argument is used to determine the size of the
memory to be allocated. If the type if NOT <font size="3"><tt>LARGE_BLOCK_TYPE</tt></font> then this argument is
ignored and the proper size is allocated.
<P>
If the type has memory that was earlier allocated and released it is stored in a free list
and is reused.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.6."><H4>2.9.1.6. memory_ReleaseVariable()</H4></A>

This function should be used to release a memory object.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int memory_ReleaseVariable(pMemoryObject pMo,
                           pFixSizeMemoryObject p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.7."><H4>2.9.1.7. memory_NewString()</H4></A>

This function should be used to allocate string variable.
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewString(pMemoryObject pMo,
                                      unsigned long StringSize
  )@{
</PRE></FONT>
<P>
The second argument specifies the length of th required string including.
<P>
The function checks the desired length and if this is small then is allocates a fix size
object. If this is too large then it allocates a <font size="3"><tt>LARGE_BLOCK_TYPE</tt></font><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.8."><H4>2.9.1.8. memory_NewCString()</H4></A>

This function should be used to allocate variable to store a constant string.
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewCString(pMemoryObject pMo,
                                       unsigned long StringSize
  )@{
</PRE></FONT>
<P>
The second argument specifies the length of the required string.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.9."><H4>2.9.1.9. memory_SetRef()</H4></A>

Set the variable <font size="3"><tt>ppVar</tt></font> to reference the variable <font size="3"><tt>ppVal</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int memory_SetRef(pMemoryObject pMo,
                   pFixSizeMemoryObject *ppVar,
                   pFixSizeMemoryObject *ppVal
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.10."><H4>2.9.1.10. memory_NewRef()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewRef(pMemoryObject pMo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.11."><H4>2.9.1.11. memory_IsUndef()</H4></A>

This function returns if the examined variable is <font size="3"><tt>undef</tt></font>. Since a
variable containing <font size="3"><tt>undef</tt></font> but having other variables referencing this
variable is NOT stored as <font size="3"><tt>NULL</tt></font> examining the variable agains <font size="3"><tt>NULL</tt></font> is
not enough anymore since reference variables were introduced.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int memory_IsUndef(pFixSizeMemoryObject pVar
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.12."><H4>2.9.1.12. memory_Type()</H4></A>

This function returns the type of the variable. In case the program
does not want to check the <font size="3"><tt>NULL</tt></font> undef, but wants to get <font size="3"><tt>VTYPE_UNDEF</tt></font>
even if the variable is real <font size="3"><tt>undef</tt></font> being <font size="3"><tt>NULL</tt></font> calling this function
is safe. Use this function instead of the macro <font size="3"><tt>TYPE</tt></font> defined in <font size="3"><tt>command.h</tt></font>
is there is doubt.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int memory_Type(pFixSizeMemoryObject pVar
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.13."><H4>2.9.1.13. memory_SelfOrRealUndef()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_SelfOrRealUndef(pFixSizeMemoryObject pVar
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.14."><H4>2.9.1.14. memory_NewUndef()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewUndef(pMemoryObject pMo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.15."><H4>2.9.1.15. memory_ReplaceVariable()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
int memory_ReplaceVariable(pMemoryObject pMo,
                           pFixSizeMemoryObject *Lval,
                           pFixSizeMemoryObject NewValue,
                           pMortalList pMortal,
                           int iDupFlag
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.16."><H4>2.9.1.16. memory_NewLong()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewLong(pMemoryObject pMo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.17."><H4>2.9.1.17. memory_NewDouble()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewDouble(pMemoryObject pMo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.18."><H4>2.9.1.18. memory_CopyArray</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_CopyArray(pMemoryObject pMo,
                                      pFixSizeMemoryObject p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.19."><H4>2.9.1.19. memory_NewArray()</H4></A>

This function should be used whenever a new array is to be allocated.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewArray(pMemoryObject pMo,
                                     long LowIndex,
                                     long HighIndex
  )@{
</PRE></FONT>
The index variables define the indices that are to be used when accessing an
array element. The index values are inclusive.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.20."><H4>2.9.1.20. memory_ReDimArray()</H4></A>

This function should be used when an array needs redimensioning.
If the redimensioning is succesful the function returns the pointer
to the argument <font size="3"><tt>p</tt></font>. If memory allocation is needed and the memory
allocation fails the function returns <font size="3"><tt>NULL</tt></font>. In this case the 
original array is not changed.
<P>
If the redimensioned array is smaller that the original no memory allocation
takes place, only the array elements (pointers) are moved.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_ReDimArray(pMemoryObject pMo,
                                       pFixSizeMemoryObject p,
                                       long LowIndex,
                                       long HighIndex
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.21."><H4>2.9.1.21. memory_CheckArrayIndex()</H4></A>

This function should be called before accessing a certain element of an array.
The function checks that the index is within the index limitsof the array
and in case the index is outside the index limits of the array it redimensionate the
array.
<P>
The function returns the pointer passed as parameter <font size="3"><tt>p</tt></font> or NULL in case there is a
memory allocation error.
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_CheckArrayIndex(pMemoryObject pMo,
                                            pFixSizeMemoryObject p,
                                            long Index
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.22."><H4>2.9.1.22. memory_Mortalize()</H4></A>

This function should be used when a variable is to be put in a mortal list.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void memory_Mortalize(pFixSizeMemoryObject p,
                      pMortalList pMortal
  )@{
</PRE></FONT>
Note that care should be taken to be sure that the variable is NOT on a mortal
list. If the variable is already on a mortal list calling this function will
break the original list and therefore may loose the variables that follow this one.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.23."><H4>2.9.1.23. memory_Immortalize()</H4></A>

Use this function to immortalize a variable. This can be used when the result of an expression
evaluation gets into a mortal variable and instead of copiing the value from the mortal variable to
an immortal variable the caller can immortalize the variable. However it should know which mortal list
the variable is on.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void memory_Immortalize(pFixSizeMemoryObject p,
                        pMortalList pMortal
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.24."><H4>2.9.1.24. memory_NewMortal()</H4></A>

When an expression is evaluated mortal variables are needed to store
the intermediate results. These variables are called mortal variables.
Such a variable is is allocated using this function and specifying a
variable of type <font size="3"><tt>MortalList</tt></font> to assign the mortal to the list of
mortal variables.
<P>
When the expression is evaluated all mortal variables are to be released
and they are calling the function <font size="3"><tt>memory_ReleaseMortals</tt></font> (see <a href="#2.9.1.28.">memory_ReleaseMortals()</A>).
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewMortal(pMemoryObject pMo,
                                      BYTE type,
                                      unsigned long LargeBlockSize,
                                      pMortalList pMortal
  )@{
</PRE></FONT>
If the parameter <font size="3"><tt>pMortal</tt></font> is <font size="3"><tt>NULL</tt></font> the generated variable is not mortal.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.25."><H4>2.9.1.25. memory_DupImmortal()</H4></A>

This function creates a new mortal and copies the argument <font size="3"><tt>pVar</tt></font> into this
new mortal.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_DupImmortal(pMemoryObject pMo,
                                        pFixSizeMemoryObject pVar,
                                        int *piErrorCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.26."><H4>2.9.1.26. memory_DupVar()</H4></A>

This function creates a new mortal and copies the argument <font size="3"><tt>pVar</tt></font> into this
new mortal.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_DupVar(pMemoryObject pMo,
                                   pFixSizeMemoryObject pVar,
                                   pMortalList pMyMortal,
                                   int *piErrorCode
  )@{
</PRE></FONT>
This function is vital, when used in operations that convert the
values to <font size="3"><tt>long</tt></font> or <font size="3"><tt>double</tt></font>. Expression evaluation may return an immortal
value, when the expression is a simple variable access. Conversion of the
result would modify the value of the variable itself. Therefore functions and
operators call this function to duplicate the result to be sure that the value
they convert is mortal and to be sure they do not change the value of a variable
when they are not supposed to.
<P>
Note that you can duplicate <font size="3"><tt>long</tt></font>, <font size="3"><tt>double</tt></font> and <font size="3"><tt>string</tt></font> values, but you can not
duplicate arrays! The string value is duplicated and the characters are copied to
the new location. This is perfect. However if you do the same with an array the array
pointers will point to the same variables, which are not going to be duplicated. This
result multiple reference to a single value. This situation is currently not supported
by this system as we do not have either garbage collection or any other solution to support
such memory structures.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.27."><H4>2.9.1.27. memory_DupMortalize()</H4></A>

This function creates a new mortal and copies the argument <font size="3"><tt>pVar</tt></font> into this
new mortal only if the value is immortal. If the value is mortal the it returns
the original value.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_DupMortalize(pMemoryObject pMo,
                                         pFixSizeMemoryObject pVar,
                                         pMortalList pMyMortal,
                                         int *piErrorCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.28."><H4>2.9.1.28. memory_ReleaseMortals()</H4></A>

This function should be used to release the mortal variables.
<P>
When an expression is evaluated mortal variables are needed to store
the intermediate results. These variables are called mortal variables.
Such a variable is is allocated using this function and specifying a
variable of type <font size="3"><tt>MortalList</tt></font> to assign the mortal to the list of
mortal variables.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void memory_ReleaseMortals(pMemoryObject pMo,
                           pMortalList pMortal
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.29."><H4>2.9.1.29. memory_DebugDumpVariable()</H4></A>

This function is used for debugging purposes. (To debug ScriptBasic and not
to debug a BASIC program using ScriptBasic. <font size="3"><tt>:-o</tt></font> )
<P>
The function prints the content of a variable to the standard output.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void memory_DebugDumpVariable(pMemoryObject pMo,
                              pFixSizeMemoryObject pVar
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.30."><H4>2.9.1.30. memory_DebugDumpMortals()</H4></A>

This function is used for debugging purposes. (To debug ScriptBasic and not
to debug a BASIC program using ScriptBasic. <font size="3"><tt>:-o</tt></font> )
<P>
The function prints the content of the mortal list to the standard output.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void memory_DebugDumpMortals(pMemoryObject pMo,
                             pMortalList pMortal
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.31."><H4>2.9.1.31. memory_NewMortalString()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewMortalString(pMemoryObject pMo,
                                            unsigned long StringSize,
                                            pMortalList pMortal
  )@{
</PRE></FONT>
If the parameter <font size="3"><tt>pMortal</tt></font> is <font size="3"><tt>NULL</tt></font> the generated variable is not mortal.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.32."><H4>2.9.1.32. memory_NewMortalCString()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewMortalCString(pMemoryObject pMo,
                                             unsigned long StringSize,
                                             pMortalList pMortal
  )@{
</PRE></FONT>
If the parameter <font size="3"><tt>pMortal</tt></font> is <font size="3"><tt>NULL</tt></font> the generated variable is not mortal.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.33."><H4>2.9.1.33. memory_NewMortalLong()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewMortalLong(pMemoryObject pMo,
                                            pMortalList pMortal
  )@{
</PRE></FONT>
If the parameter <font size="3"><tt>pMortal</tt></font> is <font size="3"><tt>NULL</tt></font> the generated variable is not mortal.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.34."><H4>2.9.1.34. memory_NewMortalRef()</H4></A>

This function was never used. It was presented in the code to allow external modules to
create mortal reference variables. However later I found that the variable structure design does
not allow mortal reference variables and thus this function is nonsense.
<P>
Not to change the module interface defintion the function still exists but returns NULL, like if
memory were exhausted.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewMortalRef(pMemoryObject pMo,
                                         pMortalList pMortal
  )@{
</PRE></FONT>
If the parameter <font size="3"><tt>pMortal</tt></font> is <font size="3"><tt>NULL</tt></font> the generated variable is not mortal.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.35."><H4>2.9.1.35. memory_NewMortalDouble()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewMortalDouble(pMemoryObject pMo,
                                            pMortalList pMortal
  )@{
</PRE></FONT>
If the parameter <font size="3"><tt>pMortal</tt></font> is <font size="3"><tt>NULL</tt></font> the generated variable is not mortal.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.9.1.36."><H4>2.9.1.36. memory_NewMortalArray()</H4></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
pFixSizeMemoryObject memory_NewMortalArray(pMemoryObject pMo,
                                           pMortalList pMortal,
                                           long IndexLow,
                                           long IndexHigh
  )@{
</PRE></FONT>
If the parameter <font size="3"><tt>pMortal</tt></font> is <font size="3"><tt>NULL</tt></font> the generated variable is not mortal.
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.10."><H2>2.10. Error Reporting</H2></A>
<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.10.1."><H3>2.10.1. Functions implemented in this module</H3></A>

The following subsections list the functions that are implemented in this module. The source text of this documentation was extracted from the source
Documentation embedded in the C source as comment. Treat these subsections more as reference documentation and less tutorial like.
<P>

<P>

<P>

This file contains a simple error report handling function that prints the error to the standard error.
<P>
This is a default reporting function used by most variations of ScriptBasic. However some variations
like the ISAPI one needs to implements a function having the same interface.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.10.1.1."><H4>2.10.1.1. report_report()</H4></A>

This function implements the default error reporting function for both run-time and parse time errors and
warnings.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void report_report(void *filepointer,
                   char *FileName,
                   long LineNumber,
                   unsigned int iErrorCode,
                   int iErrorSeverity,
                   int *piErrorCounter,
                   char *szErrorString,
                   unsigned long *fFlags
  )@{
</PRE></FONT>
Aguments:
<UL>
<P>
<LI> <font size="3"><tt>filepointer</tt></font> is a <font size="3"><tt>void *</tt></font> pointer. The default value of this pointer is <font size="3"><tt>stderr</tt></font> unless the
variation sets it different. This implementation uses this pointer as a <font size="3"><tt>FILE *</tt></font> pointer. Other implementations
of this function may use it for any other purpose so long as long the usage of this pointer fits the variation.
<P>
<LI> <font size="3"><tt>FileName</tt></font> is the name of the source file where the error was detected. This parameter is <font size="3"><tt>NULL</tt></font> in case of
a run-time error. The reporting function is encouraged to display this information for the user.
<P>
<LI> <font size="3"><tt>LineNumber</tt></font> is the line number within the source file where the error has happened. This parameter is valid
only in case the parameter <font size="3"><tt>FileName</tt></font> is not <font size="3"><tt>NULL</tt></font>
<P>
<LI> <font size="3"><tt>iErrorCode</tt></font> is the error code.
<P>
<LI> <font size="3"><tt>iErrorSeverity</tt></font> should define the severity of the error. It can be
<font size="3"><tt>REPORT_INFO</tt></font>,
<font size="3"><tt>REPORT_WARNING</tt></font>,
<font size="3"><tt>REPORT_ERROR</tt></font>,
<font size="3"><tt>REPORT_FATAL</tt></font>,
<font size="3"><tt>REPORT_INTERNAL</tt></font>.
Whenever the error severity is above the warning level the <font size="3"><tt>*piErrorCounter</tt></font> has to be incremented.
<P>
<LI> <font size="3"><tt>piErrorCounter</tt></font> points to an <font size="3"><tt>int</tt></font> counter that counts the number of errors. If there are errors
during syntax analysis the ScriptBasic interpreter stops its execution before starting execution.
<P>
<LI> <font size="3"><tt>szErrorString</tt></font> is an optional error parameter string and not the displayable error message.
The error message is stored in the global constant array <font size="3"><tt>en_error_messages</tt></font>. This string may
contain a <font size="3"><tt>%s</tt></font> control referring to the error parameter string.
<P>
<LI> <font size="3"><tt>fFlags</tt></font> is an <font size="3"><tt>unsigned long</tt></font> bit field. The bits currently used are:
<font size="3"><tt>REPORT_F_CGI</tt></font> is set if the error is to be reported as a CGI script. See the code for more details.
<font size="3"><tt>REPORT_F_FRST</tt></font> is reset when the report function is called first time and is set by the report function. 
This allows the report function to report a header in case it needs.
Other bits are reserved for later use.
<P>
@end itemize
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.11."><H2>2.11. The Logger Module</H2></A>

<P>
The logger module is included in ScriptBasic though it is not a critical part of it. The command line
version itself does not use the functions implemented in this module, though the functions are
available for external modules. The Eszter SB Application Engine uses this module to asynchronously
log hits and other events to ASCII text log files.
<P>
This module can be used to log events. The module implements two type of logs.
<P>
<UL>
<LI> synchronous logs
<LI> asynchronous logs
@end itemize
<P>
<B>Synchronous</B> logs are just the normal plain logging technic writing messages to a log file. This
is low performance, because the caller has to wait until the logging is performed and written to a file.
On the other hand this is a safe logging.
<P>
Asynchronous logging is a fast performance logging method. In this case the caller passes
the log item to the logger. The logger puts the item on a queue and sends it to the log file
in another thread when disk I/O bandwith permits. This is high performance, because the caller
does not need to wait for the log item written to the disk. On the other hand this logging is not
safe because the caller can not be sure that the log was written to the disk.
<P>
The program using this module should use asynchronous logging for high volume logs and synchronous
logging for low volume logging. For example a panic log that reports configuration error has to
be written synchronously.
<P>
Using this module you can initialize a log specifying the file where to write the log, send logs and
you can tell the log to shut down. When shutting down all waiting logs are written to the file and no more
log items are accepted. When all logs are written the logging thread terminates.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.11.1."><H3>2.11.1. log_state()</H3></A>

This function safely returns the actual state of the log. This can be:
<P>
<UL>
<LI> <font size="3"><tt>LOGSTATE_NORMAL</tt></font> the log is normal state accepting log items
<LI> <font size="3"><tt>LOGSTATE_SHUTTING</tt></font> the log is currently performing shut down, it does not accept any log item
<LI> <font size="3"><tt>LOGSTATE_DEAD</tt></font> the log is shut down all files are closed
<LI> <font size="3"><tt>LOGSTATE_SYNCHRONOUS</tt></font> the log is synchronous accepting log items
@end itemize
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int log_state(ptLogger pLOG
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.11.2."><H3>2.11.2. log_init()</H3></A>

Initialize a log. The function sets the parameters of a logging thread. 
The parameters are the usual memory allocation and deallocation functions
and the log file name format string. This format string can contain at most four
<font size="3"><tt>%d</tt></font> as formatting element. This will be passed to <font size="3"><tt>sprintf</tt></font> with arguments as
year, month, day and hour in this order. This will ease log rotating.
<P>
Note that log file name calculation is a CPU consuming process and therefore it is not
performed for each log item. The log system recalculates the log file name and closes the
old log file and opens a new one whenever the actual log to be written and the last log wrote
is in a different time interval. The time interval is identified by the time stamp value
divided (integer division) by the time span value. This is 3600 when you want to rotate the log
hourly, 86400 if you want to rotate the log daily. Other rotations, like monthly do not work correctly.
<P>
To do this the caller has to set the <font size="3"><tt>TimeSpan</tt></font> field of the log structure. There is no support function
to set this.
<P>
For example:
<FONT SIZE="3" COLOR="BLUE"><PRE>
<P>
  if( log_init(&amp;ErrLog,alloc_Alloc,alloc_Free,pM_AppLog,CONFIG("log.err.file"),LOGTYPE_NORMAL) )
    return 1;
  if( cft_GetEx(&amp;MyCONF,"log.err.span",&amp;ConfNode,NULL,&amp;(ErrLog.TimeSpan),NULL,NULL) )
    ErrLog.TimeSpan = 0;
<P>
</PRE></FONT>
<P>
as you can see in the file <font size="3"><tt>ad.c</tt></font> Setting TimeSpan to zero results no log rotation.
<P>
Note that it is a good practice to set the TimeSpan value to positive (non zero) even if the
log is not rotated. If you ever delete the log file while the logging application is running
the log is not written anymore until the log file is reopened.
<P>
The log type can be <font size="3"><tt>LOGTYPE_NORMAL</tt></font> to perform asynchronous high performance logging and
<font size="3"><tt>LOGTYPE_SYNCHRONOUS</tt></font> for syncronous, "panic" logging. Panic logging keeps the file continously
opened until the log is shut down and does not perform log rotation.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int log_init(ptLogger pLOG,
             void *(*memory_allocating_function)(size_t, void *),
             void (*memory_releasing_function)(void *, void *),
             void *pMemorySegment,
             char *pszLogFileName,
             int iLogType
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.11.3."><H3>2.11.3. log_printf()</H3></A>

This function can be used to send a formatted log to the log file. The
function creates the formatted string and then puts it onto the log queue.
The log is actually sent to the log file by the asynchronous logger thread.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int log_printf(ptLogger pLOG,
               char *pszFormat,
               ...
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.11.4."><H3>2.11.4. log_shutdown()</H3></A>

Calling this function starts the shutdown of a log queue. This function allways return 0 as success.
When the function returns the log queue does not accept more log items, however the queue is not completely
shut down. If the caller wants to wait for the queue to shut down it has to wait and call the function
<a href="#2.11.1.">log_state</A> to ensure that the shutdown procedure has been finished.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int log_shutdown(ptLogger pLOG
  )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12."><H2>2.12. Hook Functions</H2></A>

<P>
This file contains the hook functions that are called by the commands whenever
a command wants to access the operating system functions. The hook functions
implemented here are transparent, they call the operating system. However these hook
functions are called via the HookFunctions function pointer table and external modules
may alter this table supplying their own hook functions.
<P>
There are some hook functions, which do not exist by default. In this case the hook functions table
points to <font size="3"><tt>NULL</tt></font>. These functions, if defined are called by ScriptBasic at certain points of execution.
For example the function <font size="3"><tt>HOOK_ExecBefore</tt></font> is called each time before executing a command in case
an external module defines the function altering the hook function table.
<P>
The hook functions have the same arguments as the original function preceeded by the
pointer to the execution object <font size="3"><tt>pExecuteObject pEo</tt></font>. For example the function <font size="3"><tt>fopen</tt></font> has two arguments
to <font size="3"><tt>char *</tt></font>, and therefore HOOK_fopen has three. The first should point to <font size="3"><tt>pEo</tt></font> and the second and third should
point to <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.1."><H3>2.12.1. hook_Init</H3></A>

This function allocates a hook function table and fills the
function pointers to point to the original transparent hook functions.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_Init(pExecuteObject pEo,
              pHookFunctions *pHookers
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.2."><H3>2.12.2. hook_file_access</H3></A>
@c  file_access
<P>
This function gets a file name as an argument and return an integer code that tells
the caller if the program is allowed to read, write or both read and write to the file.
The default implementation just dumbly answers that the program is allowed both read
and write. This function is called by each other hook functions that access a file via the
file name. If a module wants to restrict the basic code to access files based on the file
name the module does not need to alter all hook functions that access files via file name.
<P>
The module has to write its own <font size="3"><tt>file_access</tt></font> hook function instead, alter the hook function table
to point to the module's function and all file accessing functions will ask the module's
hook function if the code may access the file.
<P>
The argument <font size="3"><tt>pszFileName</tt></font> is the name of the file that the ScriptBasic program
want to do something. The actual <font size="3"><tt>file_access</tt></font> hook function should decide if the
basic program is
<P>
<UL>
<LI> 0 not allowed to access the file
<LI> 1 allowed to read the file
<LI> 2 allowed to write the file (modify)
<LI> 3 allowed to read and write the file
@end itemize
<P>
The default implementation of this function just
allows the program to do anything. Any extension module may
have its own implementation and restrict the basic program to
certain files.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_file_access(pExecuteObject pEo,
                     char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.3."><H3>2.12.3. hook_fopen</H3></A>
@c  fopen
<FONT SIZE="3" COLOR="BLUE"><PRE>
FILE *hook_fopen(pExecuteObject pEo,
                 char *pszFileName,
                 char *pszOpenMode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.4."><H3>2.12.4. hook_fclose</H3></A>
@c  fclose
<FONT SIZE="3" COLOR="BLUE"><PRE>
void hook_fclose(pExecuteObject pEo,
                  FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.5."><H3>2.12.5. hook_size</H3></A>
@c  size
<FONT SIZE="3" COLOR="BLUE"><PRE>
long hook_size(pExecuteObject pEo,
               char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.6."><H3>2.12.6. hook_time_accessed</H3></A>
@c  time_accessed
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long hook_time_accessed(pExecuteObject pEo,
                        char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.7."><H3>2.12.7. hook_time_modified</H3></A>
@c  time_modified
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long hook_time_modified(pExecuteObject pEo,
                        char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.8."><H3>2.12.8. hook_time_created</H3></A>
@c  time_created
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long hook_time_created(pExecuteObject pEo,
                        char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.9."><H3>2.12.9. hook_isdir</H3></A>
@c  isdir
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_isdir(pExecuteObject pEo,
               char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.10."><H3>2.12.10. hook_isreg</H3></A>
@c  isreg
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_isreg(pExecuteObject pEo,
               char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.11."><H3>2.12.11. hook_fileexists</H3></A>
@c  fileexists
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_exists(pExecuteObject pEo,
                char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.12."><H3>2.12.12. hook_truncate</H3></A>
@c  truncate
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_truncate(pExecuteObject pEo,
                  FILE *fp,
                  long lNewFileSize
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.13."><H3>2.12.13. hook_fgetc</H3></A>
@c  fgetc
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_fgetc(pExecuteObject pEo,
               FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.14."><H3>2.12.14. hook_ferror</H3></A>
@c  ferror
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_ferror(pExecuteObject pEo,
               FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.15."><H3>2.12.15. hook_fread</H3></A>
@c  fread
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_fread(pExecuteObject pEo,
               char *buf,
               int size,
               int count,
               FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.16."><H3>2.12.16. hook_setmode</H3></A>
@c  Set the mode of a file stream to binary or to ASCII
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void hook_setmode(pExecuteObject pEo,
                  FILE *fp,
                  int mode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.17."><H3>2.12.17. hook_binmode</H3></A>
@c  Set a file stream to binary mode
<FONT SIZE="3" COLOR="BLUE"><PRE>
void hook_binmode(pExecuteObject pEo,
                  FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.18."><H3>2.12.18. hook_textmode</H3></A>
@c  Set a file stream to text mode
<FONT SIZE="3" COLOR="BLUE"><PRE>
void hook_textmode(pExecuteObject pEo,
                   FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.19."><H3>2.12.19. hook_fwrite</H3></A>
@c  fwrite
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_fwrite(pExecuteObject pEo,
               char *buf,
               int size,
               int count,
               FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.20."><H3>2.12.20. hook_fputc</H3></A>
@c  fputc
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_fputc(pExecuteObject pEo,
               int c,
               FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.21."><H3>2.12.21. hook_flock</H3></A>
@c  flock
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_flock(pExecuteObject pEo,
               FILE *fp,
               int iLockType
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.22."><H3>2.12.22. hook_lock</H3></A>
@c  lock
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_lock(pExecuteObject pEo,
              FILE *fp,
              int iLockType,
              long lStart,
              long lLength
  )@{
  return file_lock(fp,iLockType,lStart,lLength);
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.23."><H3>2.12.23. hook_feof</H3></A>
@c  feof
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_feof(pExecuteObject pEo,
              FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.24."><H3>2.12.24. hook_mkdir</H3></A>
@c  mkdir
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_mkdir(pExecuteObject pEo,
               char *pszDirectoryName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.25."><H3>2.12.25. hook_rmdir</H3></A>
@c  rmdir
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_rmdir(pExecuteObject pEo,
               char *pszDirectoryName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.26."><H3>2.12.26. hook_remove</H3></A>
@c  remove
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_remove(pExecuteObject pEo,
                char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.27."><H3>2.12.27. hook_deltree</H3></A>
@c  deltree
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_deltree(pExecuteObject pEo,
                 char *pszDirectoryName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.28."><H3>2.12.28. hook_MakeDirectory</H3></A>
@c  MakeDirectory
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_MakeDirectory(pExecuteObject pEo,
                       char *pszDirectoryName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.29."><H3>2.12.29. hook_opendir</H3></A>
@c  opendir
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
DIR *hook_opendir(pExecuteObject pEo,
                  char *pszDirectoryName,
                  tDIR *pDirectory
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.30."><H3>2.12.30. hook_readdir</H3></A>
@c  readdir
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
struct dirent *hook_readdir(pExecuteObject pEo,
                            DIR *pDirectory
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.31."><H3>2.12.31. hook_closedir</H3></A>
@c  closedir
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void hook_closedir(pExecuteObject pEo,
                   DIR *pDirectory
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.32."><H3>2.12.32. hook_sleep</H3></A>
@c  sleep
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void hook_sleep(pExecuteObject pEo,
                long lSeconds
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.33."><H3>2.12.33. hook_curdir</H3></A>
@c  curdir
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_curdir(pExecuteObject pEo,
                char *Buffer,
                unsigned long cbBuffer
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.34."><H3>2.12.34. hook_chdir</H3></A>
@c  chdir
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_chdir(pExecuteObject pEo,
               char *Buffer
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.35."><H3>2.12.35. hook_chown</H3></A>
@c  chown
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_chown(pExecuteObject pEo,
               char *pszFileName,
               char *pszOwner
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.36."><H3>2.12.36. hook_SetCreateTime</H3></A>
@c  SetCreateTime
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_SetCreateTime(pExecuteObject pEo,
                       char *pszFileName,
                       long lTime
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.37."><H3>2.12.37. hook_SetModifyTime</H3></A>
@c  SetModifyTime
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_SetModifyTime(pExecuteObject pEo,
                       char *pszFileName,
                       long lTime
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.38."><H3>2.12.38. hook_SetAccessTime</H3></A>
@c  SetAccessTime
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_SetAccessTime(pExecuteObject pEo,
                       char *pszFileName,
                       long lTime
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.39."><H3>2.12.39. hook_gethostname</H3></A>
@c  gethostname
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_gethostname(pExecuteObject pEo,
                     char *pszBuffer,
                     long cbBuffer
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.40."><H3>2.12.40. hook_gethost</H3></A>
@c  gethost
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_gethost(pExecuteObject pEo,
                 char *pszBuffer,
                 struct hostent *pHost
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.41."><H3>2.12.41. hook_tcpconnect</H3></A>
@c  tcpconnect
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_tcpconnect(pExecuteObject pEo,
                    SOCKET *sClient,
                    char *pszRemoteSocket
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.42."><H3>2.12.42. hook_tcpsend</H3></A>
@c  tcpsend
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_tcpsend(pExecuteObject pEo,
                 SOCKET sClient,
                 char *pszBuffer,
                 long cbBuffer,
                 int iFlags
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.43."><H3>2.12.43. hook_tcprecv</H3></A>
@c  tcprecv
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_tcprecv(pExecuteObject pEo,
                 SOCKET sClient,
                 char *pszBuffer,
                 long cbBuffer,
                 int iFlags
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.44."><H3>2.12.44. hook_tcpclose</H3></A>
@c  tcpclose
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_tcpclose(pExecuteObject pEo,
                  SOCKET sClient
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.45."><H3>2.12.45. hook_killproc</H3></A>
@c  killproc
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_killproc(pExecuteObject pEo,
                  long pid
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.46."><H3>2.12.46. hook_getowner</H3></A>
@c  getowner
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_getowner(pExecuteObject pEo,
                  char *pszFileName,
                  char *pszOwnerBuffer,
                  long cbOwnerBuffer
 )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.47."><H3>2.12.47. hook_fcrypt</H3></A>
@c  fcrypt
<FONT SIZE="3" COLOR="BLUE"><PRE>
char *hook_fcrypt(pExecuteObject pEo,
                  char *buf,
                  char *salt,
                  char *buff
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.48."><H3>2.12.48. hook_CreateProcess</H3></A>
@c  CreateProcess
<FONT SIZE="3" COLOR="BLUE"><PRE>
long hook_CreateProcess(pExecuteObject pEo,
                         char *pszCommandLine
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.49."><H3>2.12.49. hook_CreateProcessEx</H3></A>
@c  CreateProcessEx
<FONT SIZE="3" COLOR="BLUE"><PRE>
long hook_CreateProcessEx(pExecuteObject pEo,
                          char *pszCommandLine,
                          long lTimeOut,
                          unsigned long *plPid,
                          unsigned long *plExitCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.50."><H3>2.12.50. hook_waitpid</H3></A>
@c  waitpid
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_waitpid(pExecuteObject pEo,
                 long pid,
                 unsigned long *plExitCode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.12.51."><H3>2.12.51. hook_CallScribaFunction</H3></A>
@c  Start to execute a scriba function
<P>
This is a hook function that performs its operation itself without
calling underlying <font size="3"><tt>file_</tt></font> function. This function is called
by external modules whenever the external module wants to execute
certain ScriptBasic function.
<P>
The external module has to know the entry point of the ScriptBasic
function.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int hook_CallScribaFunction(pExecuteObject pEo,
                            unsigned long lStartNode,
                            pFixSizeMemoryObject *pArgument,
                            unsigned long NumberOfPassedArguments,
                            pFixSizeMemoryObject *pFunctionResult
  )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.13."><H2>2.13. Handle Pointers in External Modules Support Functions</H2></A>

@c Handling handle pointer conversion
<P>
The functions in this file help the various ScriptBasic extension
modules to avoid crashing the system even if the BASIC programs use 
the values passed by the module in a bad way. 
<P>
For example a database handling module opens a database and allocates 
a structure describing the connection. The usual way to identify the structure 
is to return a BASIC string variable to the BASIC code that byte by byte holds 
the value of the pointer. This works on any machine having 32bit or 64bit pointers 
because strings can be arbitrary length in ScriptBasic. 
<P>
When another external module function need access to the structure it needs a 
pointer to it. This is easily done by passing the string variable to the module. 
The module converts the string variable back byte by byte to a pointer and all is fine.
<P>
Is it?
<P>
The issue is that the BASIC program may alter the pointer and pass a string containg garbage
back to the module. The module has no way to check the correctness tries to use it
and crashes the whole interpreter. (Even the other interpreters running in the same process
in different threads.)
<P>
=bold
ScriptBasic external modules should never ever pass pointers in strings back to the BASIC code.
=nobold
<P>
(Even that some of the modules written by the ScriptBasic developers followed this method formerly.)
<P>
The better solution is to store these module pointers in arrays and pass the index of the pointer
in the array to the basic application. This way the BASIC program will get INTEGER values instead
of STRING and will not be able to alter the pointer value and crash the program.
<P>
To store the pointer and get the index (we call it a handle) these functions can be used.
<P>
Whenever a pointer needs a handle the module has to call <font size="3"><tt>GetHandle</tt></font>. This function stores the
pointer and returns the handle to it. When the BASIC program passes the handle back to the module
and the module needs the pointer associated with the handle it has to call <font size="3"><tt>GetPointer</tt></font>.
<P>
When a pointer is not needed anymore the handle should be freed calling <font size="3"><tt>FreeHandle</tt></font>.
<P>
This implementation uses arrays to hold the pointers. The handles are the indexes to the array.
The index 0 is never used. Handle value zero is returned as an invalid handle value whenever
some error occures, like out of memory condition.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.13.1."><H3>2.13.1. handle_GetHandle</H3></A>
@c GetHandle
<P>
Having a pointer allocate a handle. This function stores the
pointer and returns the handle.
<P>
The handle is a small positive integer.
<P>
If any error is happened (aka out of memory) zero is returned.
<FONT SIZE="3" COLOR="BLUE"><PRE>
unsigned long handle_GetHandle(void **pHandle,
                               void *pMEM,
                               void *pointer
  )@{
</PRE></FONT>
<P>
<UL>
<LI> The first argument <font size="3"><tt>pHandle</tt></font> is a pointer to the handle array.
<LI> The second argument <font size="3"><tt>pMEM</tt></font> is the memory segment that is to be used to allocate
memory.
<LI> The last argument <font size="3"><tt>pointer</tt></font> is the pointer to store.
@end itemize
<P>
Note that <font size="3"><tt>NULL</tt></font> pointer can not be stored in the array.
<P>
The pointer to the handle array <font size="3"><tt>pHandle</tt></font> should be initialized to NULL
before the first call to <font size="3"><tt>handle_GetHandle</tt></font>. For example:
<FONT SIZE="3" COLOR="BLUE"><PRE>
   void *Handle = NULL;
     ....
   if( !handle_GetHandle(&amp;Handle,pMEM,pointer) )return ERROR_CODE;
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.13.2."><H3>2.13.2. handle_GetPointer</H3></A>
@c GetPointer
<P>
This function is the opposite of <a href="#">GetHandle</A>. If a pointer was
stored in the handle array this function can be used to retrieve the
pointer knowing the handle.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void *handle_GetPointer(void **pHandle,
                        unsigned long handle
  )@{
</PRE></FONT>
<UL>
<LI> The first argument <font size="3"><tt>pHandle</tt></font> is the pointer to the handle array.
=ite, The second argument <font size="3"><tt>handle</tt></font> is the handle of the pointer.
@end itemize
<P>
If there was not pointer registered with that handle the return value of the
function is <font size="3"><tt>NULL</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.13.3."><H3>2.13.3. handle_FreeHandle</H3></A>
@c FreeHandle
<P>
Use this function when a pointer is no longer valid. Calling
this function releases the <font size="3"><tt>handle</tt></font> for further pointers.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void handle_FreeHandle(void **pHandle,
                       unsigned long handle
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.13.4."><H3>2.13.4. handle_DestroyHandleArray</H3></A>
@c DestroyHandleArray
<P>
Call this function to release the handle array after all handles are
freed and there is no need for the handle heap.
<P>
Use the same memory head <font size="3"><tt>pMEM</tt></font> that was used in <a href="#">GetHandle</A>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void handle_DestroyHandleArray(void **pHandle,
                               void *pMEM
  )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14."><H2>2.14. Thread Support Functions</H2></A>

@c thread handling routines
<P>
This file implements global thread handling functions. If the programmer uses these functions instead
of the operating system provided functions the result will be Windows NT <I>and</I> UNIX portable program.
These routines handling thread and mutex locking functions had been extensively tested in commercial
projects.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.1."><H3>2.14.1. thread_CreateThread</H3></A>
@c Create a new thread
<P>
This is a simplified implementation of the create thread interface.
<P>
The function creates a new <B>detached</B> thread.
If the thread can not be created for some reason the return value is the error
code returned by the system call <font size="3"><tt>pthread_start</tt></font> on UNIX or <font size="3"><tt>GetLastError</tt></font> on NT.
<P>
If the thread was started the return value is 0.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int thread_CreateThread(PTHREADHANDLE pThread,
                      void *pStartFunction,
                      void *pThreadParameter
  )@{
</PRE></FONT>
The arguments
<UL>
<LI> <font size="3"><tt>pThread</tt></font> is a thread handle. This should be a pointer to a variable of type <font size="3"><tt>THREADHANDLE</tt></font>. This
argument is set to hold the thread handle returned by <font size="3"><tt>CreateThread</tt></font> on NT or the pointer
returned as first argument of <font size="3"><tt>pthread_create</tt></font> under UNIX. This argument is not used further in this
module but can be used if calling system dependant functions.
<LI> <font size="3"><tt>pStartFunction</tt></font> should be a pointer pointing to the start function where the thread should start. This
is usually just the name of the function to start in the separate thread.
<LI> <font size="3"><tt>pThreadParameter</tt></font> is the pointer passed as argument to the start function.
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.2."><H3>2.14.2. thread_ExitThread</H3></A>
@c Exit from a thread
<P>
Exit from a thread created by <a href="#">CreateThread</A>. The implementation is simple
and does not allow any return value from the thread.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void thread_ExitThread(
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.3."><H3>2.14.3. thread_InitMutex</H3></A>
@c Initialize a mutex object
<P>
This function initializes a <font size="3"><tt>MUTEX</tt></font> variable. A <font size="3"><tt>MUTEX</tt></font> variable can be used for exclusive access.
If a mutex is locked another lock on that mutex will wait until the first lock is removed. If there are
several threads waiting for a mutex to be released a random thread will get the lock when 
the actually locking thread releases the mutex. In other words
if there are several threads waiting for a mutex there is no guaranteed order of the threads getting the
mutex lock.
<P>
Before the first use of a <font size="3"><tt>MUTEX</tt></font> variable it has to be initialized calling this function.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void thread_InitMutex(PMUTEX pMutex
  )@{
</PRE></FONT>
Arguments:
<UL>
<LI> <font size="3"><tt>pMutex</tt></font> should point to a mutex variable of the type <font size="3"><tt>MUTEX</tt></font>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.4."><H3>2.14.4. thread_FinishMutex</H3></A>
@c Delete a mutex object
<P>
When a mutex is not used anymore by a program it has to be released to free the system resources
allocated to handle the mutex.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void thread_FinishMutex(PMUTEX pMutex
  )@{
</PRE></FONT>
Arguments:
<UL>
<LI> <font size="3"><tt>pMutex</tt></font> should point to an initialized mutex variable of the type <font size="3"><tt>MUTEX</tt></font>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.5."><H3>2.14.5. thread_LockMutex</H3></A>
@c Lock a mutex object
<P>
Calling this function locks the mutex pointed by the argument. If the mutex is currently locked the
calling thread will wait until the mutex becomes available.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void thread_LockMutex(PMUTEX pMutex
  )@{
</PRE></FONT>
Arguments:
<UL>
<LI> <font size="3"><tt>pMutex</tt></font> should point to an initialized mutex variable of the type <font size="3"><tt>MUTEX</tt></font>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.6."><H3>2.14.6. thread_UnlockMutex</H3></A>
@c Unlock a mutex object
<P>
Calling this function unlocks the mutex pointed by the argument. Calling this function on a mutex
currently not locked is a programming error and results undefined result. Different operating system
may repond different.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void thread_UnlockMutex(PMUTEX pMutex
  )@{
</PRE></FONT>
Arguments:
<UL>
<LI> <font size="3"><tt>pMutex</tt></font> should point to an initialized mutex variable of the type <font size="3"><tt>MUTEX</tt></font>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.7."><H3>2.14.7. thread_shlckstry</H3></A>
@c Shared locks
<P>
The following functions implement shared locking. These functions do not call system
dependant functions. These are built on the top of the MUTEX locking functions.
<P>
A shareable lock can be <B>READ</B> locked and <B>WRITE</B> locked. When a shareable lock is READ locked
another thread can also read lock the lock.
<P>
On the other hand a write lock is exclusive. A write lock can appear when there is no read lock on
a shareable lock and not write lock either.
<P>
@cr
<P>
The story to understand the workings:
<P>
Imagine a reading room with several books. You can get into the room through a small 
entrance room, which is dark. To get in you have to switch on the light. The reading room 
has a light and a switch as well. You are not expected to read in the dark. The reading 
room is very large with several shelves that easily hide the absent minded readers and 
therefore the readers can not easily decide upon leaving if they are the last or not. This 
actually led locking up late readers in the dark or the opposite: lights running all the night.
<P>
To avoid this situation the library placed a box in the entrance room where each reader 
entering the room have to place his reader Id card. When they leave they remove the 
card. The first reader coming switches the light on, and the last one switches the light off. 
Coming first and leaving last is easily determined looking at the box after dropping the 
card or after taking the card out. If there is a single card after dropping the reader card 
into you are the first coming and if there is no card in it you took your one then you are 
the last.
<P>
To avoid quarreling and to save up energy the readers must switch on the light of the 
entrance room when they come into and should switch it off when they leave. However 
they have to do it only when they go into the reading room, but not when leaving. When 
someone wants to switch a light on, but the light is already on he or she should wait until 
the light is switched off. (Yes, this is a MUTEX.)
<P>
When the librarian comes to maintain ensures that no one is inside, switches the light of 
the entrance room on, and then switches the reading room light on. If someone is still 
there he cannot switch the light on as it is already switched on. He waits until the light is 
switched off then he switches it on. When he has switched the light of the reading room on 
he switches the light of the entrance room off and does his job in the reading room. Upon 
leaving he switches off the light of the reading room.
<P>
Readers can easily enter through the narrow entrance room one after the other. They can 
also easily leave. When the librarian comes he can not enter until all readers leave the 
reading room. Before getting into the entrance room he has equal chance as any of the 
readers. <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.8."><H3>2.14.8. thread_InitLock</H3></A>
@c Initialize a shareable lock
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void shared_InitLock(PSHAREDLOCK p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.9."><H3>2.14.9. thread_FinishLock</H3></A>
@c Finish a shareable lock
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void shared_FinishLock(PSHAREDLOCK p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.10."><H3>2.14.10. thread_LockRead</H3></A>
@c Lock a shareable lock for shared (read) lock
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void shared_LockRead(PSHAREDLOCK p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.11."><H3>2.14.11. thread_LockWrite</H3></A>
@c Lock a shareable lock for exclusive locking
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void shared_LockWrite(PSHAREDLOCK p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.12."><H3>2.14.12. thread_UnlockRead</H3></A>
@c Unlock a sharebale lock that was locked shared
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void shared_UnlockRead(PSHAREDLOCK p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.14.13."><H3>2.14.13. thread_UnlockWrite</H3></A>
@c Unlock a sharebale lock that was locked exclusive
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void shared_UnlockWrite(PSHAREDLOCK p
  )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.15."><H2>2.15. Dynamic Library Handling Support Functions</H2></A>

@c Handling Dynamic Load Libraries
<P>
The Dynamic Load Libraries are handled different on all operating systems. This file
implements a common functional base handling the DLLs for ScriptBasic. All other modules
of ScriptBasic that want to use DLLs should call only the functions implemented in this
file.
<P>
=toc<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.15.1."><H3>2.15.1. dynlolib_LoadLibrary</H3></A>
@c Load a library
<P>
This function loads a library and returns a pointer that can be used in other functions
referencing the loaded library.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void *dynlolib_LoadLibrary(
  char *pszLibraryFile
  )@{
</PRE></FONT>
The argument <font size="3"><tt>pszLibraryFile</tt></font> is the ZCHAR file name.
<P>
The file name is either absolute or relative. When a relative file name is specified the
directories searched may be different on different operating systems.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.15.2."><H3>2.15.2. dynlolib_FreeLibrary</H3></A>
@c Release a library
<P>
This function releases the library that was loaded before using <a href="#2.15.1.">dynlolib_LoadLibrary</A>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void dynlolib_FreeLibrary(
  void *pLibrary
  )@{
</PRE></FONT>
The argument <font size="3"><tt>pLibrary</tt></font> is the pointer, which was returned by the function <a href="#2.15.1.">dynlolib_LoadLibrary</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.15.3."><H3>2.15.3. dynlolib_GetFunctionByName</H3></A>
@c Get the entry point of a function by its name
<P>
This function can be used to get the entry point of a function of a loaded module
specifying the name of the function.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void *dynlolib_GetFunctionByName(
  void *pLibrary,
  char *pszFunctionName
  )@{
</PRE></FONT>
The argument <font size="3"><tt>pLibrary</tt></font> is the pointer, which was returned by the function <a href="#2.15.1.">dynlolib_LoadLibrary</A>
<P>
The argument <font size="3"><tt>pszFunctionName</tt></font> is the ZCAR function name.
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16."><H2>2.16. Other System Dependant Functions</H2></A>

@c Handling system specific file operations
=abstract
The file <font size="3"><tt>filesys.h</tt></font> contains file handling primitive functions. The reason for this module
is to have all system specific file handling functions to be separated in a single file.
All other modules use these functions that behave the same on Win32 platform as well as on UNIX.
=end
These functions are to be used by other parts of the program. They implement system
specific operations, and other levels need not care about these system specific stuff.
<P>
The function names are prefixed usually with <font size="3"><tt>file_</tt></font>, some are prefixed with <font size="3"><tt>sys_</tt></font>.
<P>
=toc<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.1."><H3>2.16.1. file_fopen</H3></A>
@c Open a file
<P>
This is same as fopen.
<P>
VMS has some specialities when writing a file.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
FILE *file_fopen(
  char *pszFileName,
  char *pszOpenMode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.2."><H3>2.16.2. file_fclose</H3></A>
@c Close a file
<P>
This is same as fclose. Nothing special. This is just a placeholder.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void file_fclose(FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.3."><H3>2.16.3. file_size</H3></A>
@c return the size of a file
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long file_size(char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.4."><H3>2.16.4. file_time_accessed</H3></A>
@c return the time the file was last accessed
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long file_time_accessed(char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.5."><H3>2.16.5. file_time_modified</H3></A>
@c return the time the file was modified
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long file_time_modified(char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.6."><H3>2.16.6. file_time_created</H3></A>
@c return the time the file was created
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long file_time_created(char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.7."><H3>2.16.7. file_isdir</H3></A>
@c return true if the file is a directory
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_isdir(char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.8."><H3>2.16.8. file_isreg</H3></A>
@c return true if the file is a regular file (not directory)
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_isreg(char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.9."><H3>2.16.9. file_exists</H3></A>
@c return true if the file exists
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_exists(char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.10."><H3>2.16.10. file_truncate</H3></A>
@c truncate a file to a given length
<P>
It return 0 on success and -1 on error.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_truncate(FILE *fp,
                  long lNewFileSize
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.11."><H3>2.16.11. file_fgetc</H3></A>
@c Get a single character from a file
<P>
Nothing special, it is just a placeholder.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_fgetc(FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.12."><H3>2.16.12. file_ferror</H3></A>
@c ferror
<P>
Nothing special, it is just a placeholder.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_ferror(FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.13."><H3>2.16.13. file_fread</H3></A>
@c fread
<P>
Nothing special, it is just a placeholder.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_fread(char *buf,
               int size,
               int count,
               FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.14."><H3>2.16.14. file_fwrite</H3></A>
@c fwrite
<P>
Nothing special, it is just a placeholder.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_fwrite(char *buf,
               int size,
               int count,
               FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.15."><H3>2.16.15. file_fputc</H3></A>
@c Get a single character from a file
<P>
Nothing special, it is just a placeholder.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_fputc(int c, FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.16."><H3>2.16.16. file_setmode</H3></A>
@c Set the mode of a file stream to binary or to ASCII
<P>
Nothing special, it is just a placeholder. On UNIX this is doing
nothing transparently.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void file_setmode(FILE *fp,
                  int mode
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.17."><H3>2.16.17. file_binmode</H3></A>
@c Set a file stream to binary mode
<FONT SIZE="3" COLOR="BLUE"><PRE>
void file_binmode(FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.18."><H3>2.16.18. file_textmode</H3></A>
@c Set a file stream to text mode
<FONT SIZE="3" COLOR="BLUE"><PRE>
void file_textmode(FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.19."><H3>2.16.19. file_flock</H3></A>
@c Lock a file
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_flock(FILE *fp,
               int iLockType
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.20."><H3>2.16.20. file_lock</H3></A>
@c Lock a range of a file
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_lock(FILE *fp,
              int iLockType,
              long lStart,
              long lLength
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.21."><H3>2.16.21. file_feof</H3></A>
@c Check end of file condition
<P>
Nothing special, it is just a placeholder.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_feof(FILE *fp
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.22."><H3>2.16.22. file_mkdir</H3></A>
@c Create a directory
<P>
This is the usual UNIX mkdir function. The difference is that the access code is always 0777 on UNIX
which means that the user, group and others can read, write and execute the directory. If the permission
needed is different from that you have to call the <font size="3"><tt>file_chmod</tt></font> function as soon as it becomes available.
<P>
The argument of the function is the name of the desired directory.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_mkdir(char *pszDirectoryName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.23."><H3>2.16.23. file_rmdir</H3></A>
@c Remove a directory
<P>
This is the usual UNIX rmdir function.
<P>
The argument of the function is the name of the directory to be deleted.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_rmdir(char *pszDirectoryName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.24."><H3>2.16.24. file_remove</H3></A>
@c Remove a file
<P>
Nothing special, it is just a placeholder. This function performs the UNIX <font size="3"><tt>remove</tt></font> functionality. This
function also exists under WIN32, therefore this function is only a placeholder.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_remove(char *pszFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.25."><H3>2.16.25. file_deltree</H3></A>
@c Delete a directory tree
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_deltree(char *pszDirectoryName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.26."><H3>2.16.26. file_MakeDirectory</H3></A>

This function is a bit out of the line of the other functions in this module. This function uses the
<font size="3"><tt>file_mkdir</tt></font> function to create a directory. The difference is that this function tries to create a
directory recursively. For example you can create the directory
<P>
<font size="3"><tt>/usr/bin/scriba</tt></font>
<P>
with a simple call and the function will create the directories <font size="3"><tt>/usr</tt></font> if it did not exist, then 
<font size="3"><tt>/usr/bin</tt></font> and finally <font size="3"><tt>/usr/bin/scriba</tt></font> The function fails if the directory can not be created
because of access restrictions or because the directory path or a sub path already exists, and is not
a directory.
<P>
The argument of the function is the name of the desired directory.
<P>
The function alters the argument replacing each \ character to /
<P>
The argument may end with / since v1.0b30
<P>
If the argument is a Windows full path including the drive letter, like
'C:' the function tries to create the directory 'C:', which fails, but
ignores this error because only the last creation in the line down the
directory path is significant.
<P>
In case of error, the argument may totally be destroyed.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_MakeDirectory(char *pszDirectoryName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.27."><H3>2.16.27. file_opendir</H3></A>
@c Open a directory for listing
<P>
This function implements the <font size="3"><tt>opendir</tt></font> function of UNIX. The difference between this implementation and
the UNIX version is that this implementation requires a <font size="3"><tt>DIR</tt></font> structure to be passed as an argument. The
reason for this is that the Windows system calls do not allocate memory and pass return values in structures
allocated by the caller. Because we did not want to implement memory allocation in these routines
we followed the Windows like way.
<P>
The first argument <font size="3"><tt>pszDirectoryName</tt></font> is a ZCAR directory name to be scanned. The second argument is an
allocated <font size="3"><tt>DIR</tt></font> structure that has to be valid until the <font size="3"><tt>file_closedir</tt></font> is called.
<P>
The second parameter under UNIX is not used. However to be safe and portable to Win32 the parameter
should be handled with care.
<FONT SIZE="3" COLOR="BLUE"><PRE>
DIR *file_opendir(char *pszDirectoryName,
                  tDIR *pDirectory
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.28."><H3>2.16.28. file_readdir</H3></A>
@c Read next item from a directory
<P>
This function is the implementation of the UNIX <font size="3"><tt>readdir</tt></font>
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
struct dirent *file_readdir(DIR *pDirectory
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.29."><H3>2.16.29. file_closedir</H3></A>
@c Close a directory opened for listing
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void file_closedir(DIR *pDirectory
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.30."><H3>2.16.30. file_sleep</H3></A>
@c Sleep the process
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void sys_sleep(long lSeconds
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.31."><H3>2.16.31. file_curdir</H3></A>
@c Get the current working directory
<P>
The first argument should point to a buffer having space for at least
<font size="3"><tt>cbBuffer</tt></font> characters. The function will copy the name of the current
directory into this buffer. 
<P>
Return value is zero on success. If the current directory can not be
retrieved or the buffer is too short the return value is -1.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_curdir(char *Buffer,
                unsigned long cbBuffer
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.32."><H3>2.16.32. file_chdir</H3></A>
@c Change the current working direcory
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_chdir(char *Buffer
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.33."><H3>2.16.33. file_chown</H3></A>
@c Change owner of a file
<P>
This function implements the chown command of the UNIX operating system
on UNIX and Windows NT. The first argument is the ZCHAR terminated
file name. No wild card characters are allowed.
<P>
The second argument is the name of the desired new user. The function
sets the owner of the file to the specified user, and returns zero
if the setting was succesful. If the setting fails the function returns
an error code. The error codes are:
<P>
COMMAND_ERROR_CHOWN_NOT_SUPPORTED
COMMAND_ERROR_CHOWN_INVALID_USER
COMMAND_ERROR_CHOWN_SET_OWNER
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_chown(char *pszFile,
               char *pszOwner
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.34."><H3>2.16.34. file_getowner</H3></A>
@c Get the owner of a file
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_getowner(char *pszFileName,
                  char *pszOwnerBuffer,
                  long cbOwnerBuffer
 )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.35."><H3>2.16.35. file_SetCreateTime</H3></A>
@c Set the creation time of a file
<P>
Note that this time value does not exist on UNIX and
therefore calling this function under UNIX result error.
<P>
The argument to the function is the file name and the desired time
in number of seconds since the epoch. (January 1, 1970. 00:00)
<P>
If the time was set the return value is zero. If there is an error the
return value is the error code.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_SetCreateTime(char *pszFile,
                       long lTime
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.36."><H3>2.16.36. file_SetModifyTime</H3></A>
@c Set the modification time of a file
<P>
The argument to the function is the file name and the desired time
in number of seconds since the epoch. (January 1, 1970. 00:00)
<P>
If the time was set the return value is zero. If there is an error the
return value is the error code.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_SetModifyTime(char *pszFile,
                       long lTime
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.37."><H3>2.16.37. file_SetAccessTime</H3></A>
@c Set the access time of a file
<P>
The argument to the function is the file name and the desired time
in number of seconds since the epoch. (January 1, 1970. 00:00)
<P>
If the time was set the return value is zero. If there is an error the
return value is the error code.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_SetAccessTime(char *pszFile,
                       long lTime
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.38."><H3>2.16.38. file_gethostname</H3></A>
@c Get the name of the actual host
<P>
This function gets the name of the host that runs the program.
The result of the function is positive if no TCP/IP protocol is
available on the machine or some error occured.
<P>
In case of success the return value is zero.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_gethostname(char *pszBuffer,
                     long cbBuffer
  )@{
</PRE></FONT>
The first argument should point to the character buffer, and the second
argument should hold the size of the buffer in bytes.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.39."><H3>2.16.39. file_gethost</H3></A>
@c Get host by name or by address
<P>
This function gets the <font size="3"><tt>struct hostent</tt></font> entry for the given address.
The address can be given as a FQDN or as an IP octet tuple, like
www.digital.com or 16.193.48.55
<P>
Optionally the address may contain a port number separated by : from
the name or the IP number. The port number is simply ignored.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_gethost(char *pszBuffer,
                 struct hostent *pHost
  )@{
</PRE></FONT>
<font size="3"><tt>pszBuffer</tt></font> should hold the name or the address of the target machine.
This buffer is not altered during the function.
<P>
<font size="3"><tt>pHost</tt></font> should point to a buffer ready to hold the hostent information.
<P>
Note that the structure <font size="3"><tt>hostent</tt></font> contains pointers outside the structre.
Those pointers are copied verbatim thus they point to the original content
as returned by the underlying socket layer. This means that the values
the <font size="3"><tt>hostent</tt></font> structure points to should not be freed, altered and 
the values needed later should be copied as soon as possible into a safe
location before any other socket call is done.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.40."><H3>2.16.40. file_tcpconnect</H3></A>
@c Connect a socket to a server:port
<P>
This function tries to connect to the remote port of a remote server.
The first argument of the function should be a pointer to <font size="3"><tt>SOCKET</tt></font>
variable as defined in <font size="3"><tt>filesys.h</tt></font> or in the Windows header files. The
second argument is a string that contains the name of the remote host,
or the IP number of the remote host and the desired port number following
the name separated by a colon. For example <font size="3"><tt>index.hu:80</tt></font> tries to connect
to the http port of the server <font size="3"><tt>index.hu</tt></font>. You can also write
<font size="3"><tt>16.192.80.33:80</tt></font> to get a connection. The function automatically recognizes
IP numbers and host names. The socket is created automatically calling the
system function <font size="3"><tt>socket</tt></font>.
<P>
If the function successfully connected to the remote server the return value
is zero. Otherwise the return value is the error code.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_tcpconnect(SOCKET *sClient,
                    char *pszRemoteSocket
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.41."><H3>2.16.41. file_tcpsend</H3></A>
@c send bytes to remote server via socket
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_tcpsend(SOCKET sClient,
                 char *pszBuffer,
                 long cbBuffer,
                 int iFlags
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.42."><H3>2.16.42. file_tcprecv</H3></A>
@c receive bytes from remote server via socket
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_tcprecv(SOCKET sClient,
                 char *pszBuffer,
                 long cbBuffer,
                 int iFlags
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.43."><H3>2.16.43. file_tcpclose</H3></A>
@c close a tcp connection
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_tcpclose(SOCKET sClient
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.44."><H3>2.16.44. file_killproc</H3></A>
@c Kill a process
<P>

This function kills a process identified by the process ID (PID).
<P>
If the process is killed successfully the return value is zero, otherwise
a positive value.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_killproc(long pid
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.45."><H3>2.16.45. file_fcrypt</H3></A>
@c Calculate encrypted password
<P>
This function implements the password encryption algorithm
using the DES function. The first argument is the clear text
password, the second argument is the two character salt value.
This need not be zero terminated. The third argument should
point to a 13 characters char array to get the encoded
password. <font size="3"><tt>buff[13]</tt></font> will contain the terminating zchar upon return.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
char *file_fcrypt(char *buf, char *salt, char *buff
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.46."><H3>2.16.46. file_CreateProcess</H3></A>
@c Run a new program
<P>
This function creates a new process using the argument as command line.
The function does NOT wait the new process to be finished but returns
the pid of the new process.
<P>
If the new process can not be started the return value is zero.
<P>
The success of the new process however can not be determined by the
return value. On UNIX this value is generated by the fork system call
and it still may fail to replace the executeable image calling <font size="3"><tt>exevp</tt></font>.
By that time the new program creation is already in the newprocess and
is not able to send back any error information to the caller.
<P>
The caller of this function should also check other outputs of the
created process that of the pid is returned. For example if the
<font size="3"><tt>execv</tt></font> call failed the process exit code is <font size="3"><tt>1</tt></font>. This is usually an
error information of a process.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long file_CreateProcess(char *pszCommandLine
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.47."><H3>2.16.47. file_CreateProcessEx</H3></A>
@c Run a new program and wait for it
<P>
This function starts a new process and starts to wait for the process.
The caller can specify a timeout period in seconds until the function
waits.
<P>
When the process terminates or the timeout period is over the function returns.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_CreateProcessEx(char *pszCommandLine,
                          long lTimeOut,
                          unsigned long *plPid,
                          unsigned long *plExitCode
  )@{
</PRE></FONT>
Arguments:
<UL>
<LI> <font size="3"><tt>pszCommandLine</tt></font> the command to execute
<LI> <font size="3"><tt>lTimeOut</tt></font> the maximum number of seconds to wait for the process to finish. If this is zero the
function will not wait for the process. If the value is <font size="3"><tt>-1</tt></font> the function wait without limit until the created
process finishes.
<LI> <font size="3"><tt>plPid</tt></font> pointer to variable where the PID of the new process is placed.
This parameter can be <font size="3"><tt>NULL</tt></font>. If the function returns after the new process has terminated this
value is more or less useless. However this parameter can be used to kill processes that reach the
timeout period and do not terminate.
<LI> <font size="3"><tt>plExitCode</tt></font> pointer to a variable where the exit code of the new process is placed. If the
process is still running when the function returns this parameter is unaltered.
@end itemize
<P>
The return value indicates the success of the execution of the new process:
<P>
<UL>
<LI> <font size="3"><tt>FILESYSE_SUCCESS</tt></font> The process was started and terminated within the specified timeout period.
<LI> <font size="3"><tt>FILESYSE_NOTSTARTED</tt></font> The function could not start the new process. (not used under UNIX)
<LI> <font size="3"><tt>FILESYSE_TIMEOUT</tt></font> The process was started but did not finish during the timeout period.
<LI> <font size="3"><tt>FILESYSE_NOCODE</tt></font> The process was started and finished within the timeout period but
it was not possible to retrieve the exit code.
@end itemize
<P>
Note that the behaviour of this function is slightly different on Windows NT and on UNIX. On Windows NT
the function will return <font size="3"><tt>FILESYSE_NOTSTARTED</tt></font> when the new process can not be started. Under UNIX
the process performs a <font size="3"><tt>fork()</tt></font> and then an <font size="3"><tt>execv</tt></font>. The <font size="3"><tt>fork()</tt></font> does not return an error value. When the
<font size="3"><tt>execvp</tt></font> fails it is already in the new process and can not return an error code. It exists using the
exit code 1. This may not be distinguished from the program started and returning an exit code 1.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.16.48."><H3>2.16.48. file_waitpid</H3></A>
@c Check on a process
<P>

This function checks if a process identified by the
process ID (PID) is still running.
<P>
If the process is live the return value is zero (FALSE), otherwise
a positive value (TRUE) is returned and the second parameter contains
the exited process's final status.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int file_waitpid(long pid,
                 unsigned long *plExitCode
   )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.17."><H2>2.17. Module Management</H2></A>

@c Module management
<P>
This file contains all the functions that handle external module management.
<P>
Note that all function names are prepended by <font size="3"><tt>modu_</tt></font><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.17.1."><H3>2.17.1. modu_Init</H3></A>
@c Initialize the module management
<P>
This function allocates memory for the external module interface table and
initializes the function pointers.
<P>
If the interface already exists and the function is called again it just
silently returns.
<P>
The second argument can be zero or 1. The normal operation is zero. If <font size="3"><tt>iForce</tt></font>
is true the function sets each function pointer to its initial value even if an
initialization has already occured before.
<P>
This can be used in a rare case when a module modifies the interface table and
want to reinitialize it to the original value. Be carefule with such
constructions.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int modu_Init(pExecuteObject pEo,
              int iForce
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.17.2."><H3>2.17.2. modu_Preload</H3></A>
@c Preload the modules configured in the configuration file
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int modu_Preload(pExecuteObject pEo
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.17.3."><H3>2.17.3. modu_GetModuleFunctionByName</H3></A>
@c Get a function entry point from a module
<P>
This function gets the entrypoint of a module function. This module can either
be statically or dynamically linked to ScriptBasic. This function is one level higher than
<a href="#">GetStaticFunctionByName</A> or 
<a href="#2.15.3.">dynlolib_GetFunctionByName</A>. The first argument to this function
is not the module handle as returned by <a href="#2.15.1.">dynlolib_LoadLibrary</A> but rather the pointer to the
module description structure that holds other information on the modula. Namely the information
that the module is loaded from dll or so, or if the module is linked to the interpreter static.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void *modu_GetModuleFunctionByName(
  pModule pThisModule,
  char *pszFunctionName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.17.4."><H3>2.17.4. modu_GetStaticFunctionByName</H3></A>
@c Get a function entry point from a statically linked library
<P>
Get the entry point of a function that was linked to the ScriptBasic environment statically.
<P>
This is the counterpart of the function <font size="3"><tt>dynlolib_GetFunctionByName</tt></font> for functions in library
linked static. This function searches the <font size="3"><tt>SLFST</tt></font> table for the named function and returns the
entry point or <font size="3"><tt>NULL</tt></font> if there is no functions with the given name defined.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void *modu_GetStaticFunctionByName(
  void *pLibrary,
  char *pszFunctionName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.17.5."><H3>2.17.5. modu_LoadModule</H3></A>
@c Load a module
<P>
This function loads a module and returns the module pointer to in the argument
<font size="3"><tt>pThisModule</tt></font>. If the module is already loaded it just returns the module
pointer.
<P>
When the function is called first time for a module it loads the module, calls
the version negotiation function and the module initializer.
<P>
If module file name given in the argument <font size="3"><tt>pszLibrary</tt></font> file name is an absolute
file name this is used as it is. Otherwise the different configured module
directories are seached for the module file, and the operating system specific
extension is also appended to the file name automatically.
<P>
If the caller does not need the pointer to the module the argument <font size="3"><tt>pThisModule</tt></font>
can be <font size="3"><tt>NULL</tt></font>.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int modu_LoadModule(pExecuteObject pEo,
                    char *pszLibraryFile,
                    pModule **pThisModule
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.17.6."><H3>2.17.6. modu_GetFunctionByName</H3></A>

This function can be called to get the entry point of a function from an external module.
If the module was not loaded yet it is automatically loaded.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int modu_GetFunctionByName(pExecuteObject pEo,
                           char *pszLibraryFile,
                           char *pszFunctionName,
                           void **ppFunction,
                           pModule **pThisModule
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.17.7."><H3>2.17.7. modu_UnloadAllModules</H3></A>
@c Unload all loaded modules
<P>
This function unloads all modules. This is called via the command finalizer mechanizm. If ever any module
was loaded via a "declare sub" statement the command execution sets the command finalizer function
pointer to point to this function.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int modu_UnloadAllModules(pExecuteObject pEo
  )@{
</PRE></FONT>
<P>
In a multi-threaded environment this function calls the keeper function of the module and in case the
keeper returns 1 the module is kept in memory, though the module finalizer function is called. This
lets multi-thread external modules to keep themselfs in memory even those times when there is not any
interpreter thread using the very module running.
<P>
In that case the module is put on the module list of the process SB object. That list is used to shut down
the modules when the whole process is shut down.
<P>
If there is no process SB object (pEo-&gt;pEPo is NULL) then the variation is a single process single thread
implementation of ScriptBasic. In this case this function first calls the module finalizer function
that is usally called in multi-threaded environment every time an interpreter thread is about to finish and
after this the module shutdown function is called, which is called in a multi-thread environment when
the whole process is to be shut down. After that the module is unloaded even if the keeper function said
that the module wants to stay in memory.
<P>
Don't worry about this: it is not abuse. The keeper function saying 1 means that the module has to 
stay in memory after the actual interpreter thread has finished until the process finishes. However
in this very case the process also terminates.
<P>
<B>Note:</B> A one-process one-thread implementation may also behave like a multi thread implementation
allocating a separate process SB object and a program object to run. Then it should inherit the
support table and the execution object of the process SB object to the runnable program object. After
running finish the runned program object and call the shutdown process for the process SB object.
But that is tricky for a single thread implementation.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.17.8."><H3>2.17.8. modu_UnloadModule</H3></A>
@c Unload the named module
<P>
This function unloads the named module. Note that this function is not
called unless some extension module calls it to unload another module.
<P>
Currently there is no support for a module to unload itself.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int modu_UnloadModule(pExecuteObject pEo,
                      char *pszLibraryFile
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.17.9."><H3>2.17.9. modu_ShutdownModule</H3></A>
@c Shut down a module
<P>
This function calls the shutdown function of a module.
<P>
If the shutdown function performs well and returns SUCCESS this function
also returns success. If the shutdown function returns error code
it means that the module has running thread and thus can not be unloaded.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int modu_ShutdownModule(pExecuteObject pEo,
                        pModule pThisModule
  )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.18."><H2>2.18. Run Time Options Handling</H2></A>

@c Setting and getting option values
<P>
Each BASIC interpreter maintains a symbol table holding option values.
These option values can be set using the BASIC command <font size="3"><tt>OPTION</tt></font> and an
option value can be retrieved using the function <font size="3"><tt>OPTION()</tt></font>.
<P>
An option has an integer value (<font size="3"><tt>long</tt></font>). Options are usually used to
alter the behaviour of some commands or modules, altough BASIC programs
are free to use any string to name an option. For example the option
<font size="3"><tt>compare</tt></font> may alter the behavior of the string comparision function
to be case sensitive or insensitive:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
OPTION compare 1
</PRE></FONT>
<P>
Unitialized options are treated as being zero. There is no special option value for uninitialized 
options. In other words BASIC programs can not distinguish between unitialized options and
options having the value zero.
<P>
This file contains the functions that handle the option symbol table. The option
symbol tableis pointed by the field <font size="3"><tt>OptionsTable</tt></font> of the execution object. This
pointer is initialized to be <font size="3"><tt>NULL</tt></font>, which means no options are available, or in other
words all options are zero.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.18.1."><H3>2.18.1. options_Reset</H3></A>
@c Clear an option data
<P>
Calling this function resets an option. This means that the memory holding
the <font size="3"><tt>long</tt></font> value is released and the pointer that was pointing to it is set <font size="3"><tt>NULL</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int options_Reset(pExecuteObject pEo,
                  char *name
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.18.2."><H3>2.18.2. options_Set</H3></A>
@c Set option data
<P>
This function sets a long value for an option. If the option
did not exist before in the symbol table it is inserted. If the
symbol table was empty (aka <font size="3"><tt>OptionsTable</tt></font> pointed <font size="3"><tt>NULL</tt></font>) the
symbol table is also created.
<P>
If the symbol already existed with some <font size="3"><tt>long</tt></font> value then the new value
is stored in the already allocated place and thus the caller
may store the pointer to the long returned by <a href="#">GetR</A> and access 
possibly updated data without searching the table again and again.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int options_Set(pExecuteObject pEo,
                char *name,
                long value
  )@{
</PRE></FONT>
The function returns zero if the option was set or <font size="3"><tt>1</tt></font> if there was a memory failure.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.18.3."><H3>2.18.3. options_Get</H3></A>
@c Get option data
<P>
This function retrieves and returns the value of an option data.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long options_Get(pExecuteObject pEo,
                 char *name
  )@{
</PRE></FONT>
The return value is the option value or zero in case the option is not set.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.18.4."><H3>2.18.4. options_GetR</H3></A>
@c Get option data
<P>
This function retrieves and returns the value of an option data.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long *options_GetR(pExecuteObject pEo,
                 char *name
  )@{
</PRE></FONT>
The return value is a <font size="3"><tt>long *</tt></font> pointer to the option value or <font size="3"><tt>NULL</tt></font> if the option is
not set. If the caller sets the <font size="3"><tt>long</tt></font> variable pointed by the returned pointer the value of the
option is changed directly.
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.19."><H2>2.19. Simple Pattern Matching</H2></A>

@c Simple Pattern Matching
<P>
=abstract
A simple, non-regular expression pattern matching module mainly to perform
file name pattern matching, like <font size="3"><tt>*.txt</tt></font> or <font size="3"><tt>file0?.bin</tt></font> and alikes.
=end
<P>
This is a simple and fast pattern matching algorithm.
This can be used when the matching does not require
regular expression complexity and the processign on 
the other hand should be fast.
<P>
There are two major tasks implemented here. One is to match a string against a pattern.
The second is to create a replacement string. When a pattern is matched by a string an
array of string values are created. Each contains a substring that matches a joker character.
Combining this array and a format string a replacement string can be created.
<P>
For example:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
<P>
String = "mortal  combat"
Pattern = "mo?tal co*"
<P>
</PRE></FONT>
<P>
the joker characters are the ?, the space (matching one or more space) and the * character.
They are matched by <font size="3"><tt>r</tt></font>, two spaces and <font size="3"><tt>mbat</tt></font>. If we use the format string
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
Format string = "$1u$2"
</PRE></FONT>
<P>
we get the result string <font size="3"><tt>rumbat</tt></font>. The format string can contain <font size="3"><tt>$n</tt></font> placeholders
where <font size="3"><tt>n</tt></font> starts with 1 and is replaced by the actual value of the n-th joker character.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.19.1."><H3>2.19.1. match_index</H3></A>
@c Return the joker index of the character
<P>
There are a few characters that can be used as joker character. These are
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
*#$@?&amp;%!+/|&lt;&gt;
</PRE></FONT>
<P>
<font size="3"><tt>match_index</tt></font> returns the serial number of the character.
<FONT SIZE="3" COLOR="BLUE"><PRE>
unsigned long match_index(char ch
)@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.19.2."><H3>2.19.2. InitSets</H3></A>
@c Initialize a set collection
<P>
Call this function to initialize a set collection. The argument should point to
a <font size="3"><tt>MatchSets</tt></font> structure and the function fills in the default values.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void match_InitSets(pMatchSets pMS
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.19.3."><H3>2.19.3. ModifySet</H3></A>
@c Modify a joker set
<P>
This function can be used to modify a joker set. The first argument <font size="3"><tt>pMS</tt></font> points to the
joker set collection. The second argument <font size="3"><tt>JokerCharacter</tt></font> specifies the joker character
for which the set has to be modified.
<P>
The argument <font size="3"><tt>nChars</tt></font> and <font size="3"><tt>pch</tt></font> give the characters that are to be modified in the set.
<font size="3"><tt>nChars</tt></font> is the number of characters in the character array pointed by <font size="3"><tt>pch</tt></font>.
<P>
The last argument <font size="3"><tt>fAction</tt></font> specifies what to do. The following constants can be used in
logical OR.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
TO_HEADER:
<P>
#define MATCH_ADDC 0x0001 //add characters to the set
#define MATCH_REMC 0x0002 //remove characters from the set
#define MATCH_INVC 0x0004 //invert the character
#define MATCH_SNOJ 0x0008 //set becomes no-joker
#define MATCH_SSIJ 0x0010 //set becomes single joker
#define MATCH_SMUJ 0x0020 //set becomes multiple joker
#define MATCH_NULS 0x0040 //nullify the set
#define MATCH_FULS 0x0080 //fullify the set
<P>
*/
</PRE></FONT>
<P>
The function first checks if it has to modify the state of the joker character. If
any of the bits <font size="3"><tt>MATCH_SNOJ</tt></font>, <font size="3"><tt>MATCH_SSIJ</tt></font> or <font size="3"><tt>MATCH_SMUJ</tt></font> is set in the field
<font size="3"><tt>fAction</tt></font> the type of the set is modified.
<P>
If more than one bit of these is set then result is undefined. Current implementation
checks these bits in a specific order, but later versions may change.
<P>
If the bit <font size="3"><tt>MATCH_NULS</tt></font> is set all the characters are removed from the set. If
the bit <font size="3"><tt>MATCH_FULS</tt></font> is set all characters are put into the set.
<P>
If more than one bit of these is set then result is undefined. Current implementation
checks these bits in a specific order, but later versions may change.
<P>
<font size="3"><tt>MATCH_NULS</tt></font> or <font size="3"><tt>MATCH_FULS</tt></font> can be used in a single call to initialize the set before
adding or removing the specific characters.
<P>
The bits <font size="3"><tt>MATCH_ADDC</tt></font>, <font size="3"><tt>MATCH_REMC</tt></font> and <font size="3"><tt>MATCH_INVC</tt></font> can be used to add characters to the set,
remove characters from the set or to invert character membership. The characters are taken
from the character array pointed by the function argument <font size="3"><tt>pch</tt></font>.
<P>
If more than one bit of these is set then result is undefined. Current implementation
checks these bits in a specific order, but later versions may change.
<P>
If none of these bits is set the value of the pointer <font size="3"><tt>pch</tt></font> is ignored.
<P>
It is no problem if a character is already in the set and is added or if it is not member of the set
and is removed. Although it has no practical importance the array pointed by <font size="3"><tt>pch</tt></font> may contain a
character many times.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void match_ModifySet(pMatchSets pMS,
                     char JokerCharacter,
                     int nChars,
                     unsigned char *pch,
                     int fAction
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.19.4."><H3>2.19.4. match</H3></A>
@c Match pattern to string
FUNCTION:
<P>
<font size="3"><tt>match</tt></font> checks if pszString matches the pattern pszPattern.
pszPattern is a string containing joker characters. These are:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
 * matches one or more any character
 # matches one or more digit
 $ matches one or more alphanumeric character
 @ matches one or more alpha character
   (space) matches one or more spaces
 ? matches a single character
</PRE></FONT>
<P>
 <font size="3"><tt>~x</tt></font> matches <font size="3"><tt>x</tt></font> even if <font size="3"><tt>x</tt></font> is pattern matching character or tilde
<P>
 <font size="3"><tt>x</tt></font> matches character <font size="3"><tt>x</tt></font> unless it is a joker character
<P>
RETURN VALUE:
<P>
The function returns zero if no error occures and returns an error code
in case some of the memory buffer does not have enough space. (Either
pszBuffer or ParameterArray)
<P>
PARAMETERS:
<P>
<font size="3"><tt>pszPattern</tt></font> IN
the pattern to match
<P>
--
<P>
<font size="3"><tt>cbPattern</tt></font> IN
the number of characters in the pattern
<P>
--
<P>
<font size="3"><tt>pszString</tt></font> IN 
the string which is compared to the pattern
<P>
--
<P>
<font size="3"><tt>cbString</tt></font> IN
the number of characters in the string
<P>
--
<P>
<font size="3"><tt>ParameterArray</tt></font> OUT
is an uninitialized character pointer array. Upon return
<font size="3"><tt>ParameterArray[i]</tt></font> points the string that matches the
<font size="3"><tt>i</tt></font>-th joker character.
<P>
--
<P>
<font size="3"><tt>pcbParameterArray</tt></font> OUT
is an uninititalized <font size="3"><tt>unsigned long</tt></font> array. Upon return
<font size="3"><tt>pcbParameterArray[i]</tt></font> contains the length of the
output parameter <font size="3"><tt>ParameterArray[i]</tt></font>.
<P>
--
<P>
<font size="3"><tt>pszBuffer</tt></font> OUT
should point to a buffer. The size of the buffer
should be specified by cbBufferSize. A size equal
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
             cbString
</PRE></FONT>
is a safe size. The actual strings matching the joker characters
will get into this buffer zero terminated one after the other:
<P>
--
<P>
<font size="3"><tt>cArraySize</tt></font> IN
number of elements in the array <font size="3"><tt>ParameterArray</tt></font>
<P>
--
<P>
<font size="3"><tt>cbBufferSize</tt></font> IN
size of the buffer pointed by pszBuffer
<P>
--
<P>
<font size="3"><tt>fCase</tt></font> IN
pattern matching is performed case sensitive if this value if TRUE.
<P>
--
<P>
<font size="3"><tt>iResult</tt></font> OUT
TRUE if <font size="3"><tt>pszString</tt></font> matches the pattern <font size="3"><tt>pszPattern</tt></font>.
FALSE otherwise.
<P>
NOTE:
<P>
<font size="3"><tt>pszPattern</tt></font> and <font size="3"><tt>pszString</tt></font> are NOT changed.
<P>
If the function returns non-zero (error code) none of the output
variables can be reliably used.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int match_match(char *pszPattern,
                unsigned long cbPattern,
                char *pszString,
                unsigned long cbString,
                char **ParameterArray,
                unsigned long *pcbParameterArray,
                char *pszBuffer,
                int cArraySize,
                int cbBufferSize,
                int fCase,
                pMatchSets pThisMatchSets,
                int *iResult
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.19.5."><H3>2.19.5. count</H3></A>
@c Count the joker characters in a pattern
<P>
This function counts the number of jokers in the string and returns it.
This function should be used to calculate the safe length of the pszBuffer
given as a parameter to match.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int match_count(char *pszPattern,
                unsigned long cbPattern
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.19.6."><H3>2.19.6. parameter</H3></A>
@c Fill parameters into format string
<P>
This function takes a format string and a string array and
copies the format string replacing <font size="3"><tt>$0</tt></font>, <font size="3"><tt>$1</tt></font> ... <font size="3"><tt>$n</tt></font> values with
the appropriate string values given in the array pointed by
ParameterArray.
<P>
RETURN VALUE:
<P>
The function returns zero if no error occures and returns an error code
in case some of the memory buffer does not have enough space or invalid
parameter is referenced.
<P>
PARAMETERS:
<font size="3"><tt>pszFormat</tt></font> IN
The format string containing the $i placeholders.
<P>
--
<P>
<font size="3"><tt>cbFormat</tt></font> IN
The number of characters in the format string
<P>
--
<P>
<font size="3"><tt>ParameterArray</tt></font> IN
string array so that <font size="3"><tt>ParameterArray[i]</tt></font> is to be inserted in place of the <font size="3"><tt>$i</tt></font> placeholders
<P>
--
<P>
<font size="3"><tt>pcbParameterArray</tt></font> IN
array of <font size="3"><tt>unsigned long</tt></font> values. <font size="3"><tt>pcbParameterArray[i]</tt></font> gives the length of the i-th string parameter.
<P>
--
<P>
<font size="3"><tt>pszBuffer</tt></font> OUT
buffer to put the result
<P>
--
<P>
<font size="3"><tt>cArraySize</tt></font> IN
Number of parameters given in the ParameterArray
<P>
--
<P>
<font size="3"><tt>pcbBufferSize</tt></font> IN/OUT
Available bytes in buffer pointed by <font size="3"><tt>pszBuffer</tt></font>. Upon return it contains the number of characters
that were placed in the buffer.
<P>
--
<P>
NOTE:
<P>
If the function returns non-zero (error code) none of the output
variables can be reliably used.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int match_parameter(char *pszFormat,
                    unsigned long cbFormat,
                    char **ParameterArray,
                    unsigned long *pcbParameterArray,
                    char *pszBuffer,
                    int cArraySize,
                    unsigned long *pcbBufferSize
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.19.7."><H3>2.19.7. size</H3></A>
@c Calculate the neccessary buffer size
<P>
Calculate the size of the output. The IN/OUT parameter <font size="3"><tt>cbBufferSize</tt></font>
is increased by the number of needed characters.
<P>
The return value is zero if no error occured or the error code.
<P>
NOTE: cbBuffer size should be initialized to 0 if you want to get the
size of the buffer needed.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int match_size(char *pszFormat,
               unsigned long cbFormat,
               unsigned long *pcbParameterArray,
               int cArraySize,
               int *cbBufferSize
  )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.20."><H2>2.20. Symbol Table Handling</H2></A>
The functions in this module implement a general purpose symbol table handling.
<P>
Generally a symbol table is a binding functionality that associates symbols with
attributes. Symbols in this implementation is a zero terminated string, and the 
attribute is a <font size="3"><tt>void *</tt></font> pointer. This is a general approach that can be used to store and retrieve any kind of symbols.
<P>
The symbol table handling functions usually always return a <font size="3"><tt>void **</tt></font> that can be modified to point to the actual structure storing the attributes of the symbol.
<P>
The internal structure of a symbol table is a hash table of <font size="3"><tt>PRIME</tt></font> elements (211). Each hash stores a binary table sorting the symbols.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.20.1."><H3>2.20.1. sym_NewSymbolTable()</H3></A>

This function creates a new symbol table. Later this symbol table should be used
to store and retrieve symbol information.
<FONT SIZE="3" COLOR="BLUE"><PRE>
SymbolTable sym_NewSymbolTable(
  void* (*memory_allocating_function)(size_t,void *),
  void *pMemorySegment
  )@{
</PRE></FONT>
The second argument should point to the memory allocating function that the
symbol table creation process should use. The last argument is an pointer to a memory
segment which is passed to the memory allocation function. The actual arguments of the
memory allocation function fits the allocation function from the package alloc. However the
defintion is general enough to use any other function.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.20.2."><H3>2.20.2. sym_FreeSymbolTable()</H3></A>

This function should be used to release the memory allocated for a symbol table.
This function releases all the memory that was allocated during symbol table creation
and during symbol insertion.
<P>
Note that the memory allocated outside the symbol table handling routines is not
released. This means that it is the caller responsibility to relase all memory
that holds the actual values associated with the symbols.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void sym_FreeSymbolTable(
  SymbolTable table,
  void (*memory_releasing_function)(void *,void *),
  void *pMemorySegment
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.20.3."><H3>2.20.3. sym_TraverseSymbolTable()</H3></A>

This function can be used to traverse through all the symbols stored
in a symbol table. The function starts to go through the symbols and
for each symbol calls the function <font size="3"><tt>call_back_function</tt></font>.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void sym_TraverseSymbolTable(
  SymbolTable table,
  void (*call_back_function)(char *SymbolName, void *SymbolValue, void *f),
  void *f
  )@{
</PRE></FONT>
The first argument is the symbol table to traverse. The second argument is the
function to be called for each symbol. This function gets three arguments. The
first is a pointer to the symbol string. The second is the pointer to the symbol
arguments. The third argument is a general pointer which is passed to the
function <font size="3"><tt>sym_TraverseSymbolTable</tt></font>.
<P>
Note that the call back function gets the pointer to the symbol arguments and
not the pointer to the pointer to the symbol arguments, and therefore call back
function can not change the actual symbol value pointer.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.20.4."><H3>2.20.4. sym_LookupSymbol()</H3></A>

This function should be used to search a symbol or to insert a new symbol.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void **sym_LookupSymbol(
  char *s,                 /* zero terminated string containing the symbol                 */
  SymbolTable hashtable,   /* the symbol table                                             */
  int insert,              /* should a new empty symbol inserted, or return NULL instead   */
  void* (*memory_allocating_function)(size_t, void *),
  void (*memory_releasing_function)(void *, void *),
  void *pMemorySegment
  )@{
</PRE></FONT>
<P>
This function usually returns a pointer to the <font size="3"><tt>void *</tt></font> pointer which is
supposed to point to the structure, which actually holds the parameters for
the symbol. When a symbol is not found in the symbol table the parameter <font size="3"><tt>insert</tt></font>
is used to decide what to do. If this parameter is zero the function returns <font size="3"><tt>NULL</tt></font>.
If this parameter is 1 the function creates a new symbol and returns a pointer to the
<font size="3"><tt>void *</tt></font> pointer associated with the symbol.
<P>
If a new symbol is to be inserted and the function returns <font size="3"><tt>NULL</tt></font> means that the memory 
allocation function has failed.
<P>
If the new symbol was created and a pointer to the <font size="3"><tt>void *</tt></font> pointer is returned the value of
the pointer is <font size="3"><tt>NULL</tt></font>. In other words:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
<P>
void **a;
<P>
a = sym_LookupSymbol(s,table,1,mymema,mymemr,p);
<P>
if( a == NULL )error("memory releasing error");
if( *a == NULL )error("symbol not found");
<P>
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="2.20.5."><H3>2.20.5. sym_DeleteSymbol()</H3></A>

This function should be used to delete a symbol from the symbol table
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int sym_DeleteSymbol(
  char *s,                 /* zero terminated string containing the symbol                 */
  SymbolTable hashtable,   /* the symbol table                                             */
  void (*memory_releasing_function)(void *, void *),
  void *pMemorySegment
  )@{
</PRE></FONT>
<P>
This function searches the given symbol and if the symbol is found it deletes it from the
symbol table. If the symbol was found in the symbol table the return value is zero. If
the symbol was not found the return value is 1. This may be interpreted by the caller as
an error or as a warning.
<P>
Note that this function only deletes the memory that was part of the symbol table. The
memory allocated by the caller and handled via the pointer <font size="3"><tt>value</tt></font> usually returned by
<a href="#2.20.4.">sym_LookupSymbol()</A> should be released by the caller.
<P>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3."><H1>3. Embedding the Interpreter</H1></A>

ScriptBasic was designed from the very start to be embeddable. This means that C programmers having their own application can fairly easy compile and link ScriptBasic together with their application and have ScriptBasic as a built in scripting language in their application.
<P>
To do this the C programmer should use the C api implemented in the file `<font size="3"><tt>scriba.c</tt></font>'. In this chapter we detail the C API as a reference listing all callable function, but before that there are some sections that describe a bit the overall model of ScriptBasiC. The next section will talk about what object orientation means for ScriptBasic and how to follow this object oriented approach when programming a ScriptBasic extended application in C.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.1."><H2>3.1. Object Oriented Model of ScriptBasic</H2></A>

Although ScriptBasic is implemented in pure C the coding and developing concept is rather object oriented. Such is the concept of the C API calling interface. This means that you have to deal with an abstract ScriptBasic program object when you want to execute a program. The structure of this program object is totally private to ScriptBasic and as a programmer embedding the interpreter you need not worry about it. The only action you have to do is to create such an object before doing any other function call calling <a href="#3.3.1.">scriba_new()</A> and to destroy it after the BASIC program was executed and is not going to be used any more calling the function <a href="#3.3.2.">scriba_destroy()</A>.
<P>
The object is stored in memory and this piece of memory is allocated by ScriptBasic. The function <a href="#3.3.1.">scriba_new()</A> allocates this memory and returns a pointer to this "object". Later this pointer has to be used to refer to this object.
<P>
Because C is not object oriented the functions called should explicitly get this pointer as first argument. When programming C++ the class pointer is used to access the class methods, and that also implicitly passes the object pointer to the method. The pointer passing code is generated by the C++ compiler. When calling ScriptBasic API the programmer has to store the "object" pointer and pass it as first argument to any function.
<P>
The type of the object pointer is <font size="3"><tt>pSbProgram</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2."><H2>3.2. Sample Embedding</H2></A>

The best way of learning is learning by example. Therefore here we will discuss the most obvious embedding application: the command line variation of ScriptBasic. The command line variation of ScriptBasic can be found in the file `<font size="3"><tt>scribacmd.c</tt></font>' in the source directory `<font size="3"><tt>variations/standard</tt></font>'. You may also find there a file named `<font size="3"><tt>basiccmd.c</tt></font>' that contains the code that was used before the <font size="3"><tt>scriba_</tt></font> C API was introduced. Have a look at it and bless God you have the new API.
<P>
In this section we will present the code from the file, but for brevity some code will not be copied to here. Also note that the code is copied and as the program develops the actual code may change while the one copied here most probably remains the same. (The API definitions are not "hand" copied, but rather taken from the C file when the documentation is compiled, so whenever the API changes the new documentation recompiled reflects the change.)<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.1."><H3>3.2.1. Include Header Files</H3></A>

<P>
The main program of the standalone variation is implemented in the file `<font size="3"><tt>scribacmd.c</tt></font>'. If you look at the start of this program you can see that it start including the file `<font size="3"><tt>scriba.h</tt></font>'. This file contains all definitions that are needed by the C compiler to compile the code calling the <font size="3"><tt>scriba_</tt></font> API functions.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
<P>
#include "../../getopt.h"
#include "../../scriba.h"
<P>
#include "../../basext.h"
</PRE></FONT>
<P>
In case you miss the file `<font size="3"><tt>scriba.h</tt></font>' then you should generate it using the program `<font size="3"><tt>headerer.pl</tt></font>' or `<font size="3"><tt>headerer.bas</tt></font>' which are also part of the distribution. C header files in ScriptBasic are not maintained by themselves. The text is rather maintained inside the C code, and is extracted using one of these scripts. (They do the same task.) The reason for this is to eliminate the double maintenance of function prototypes in the C and in the header file.
<P>
The file `<font size="3"><tt>basext.h</tt></font>' is also <font size="3"><tt>#include</tt></font>d by the main program. This is not usually needed by other main programs. The standalone version needs it for the sole reason to be able to print out on the usage screen the extension module interface version that the actual interpreter support. This version is defined in the macro <font size="3"><tt>INTERFACE_VERSION</tt></font>. Other than that there is no reason or need to include any other file than `<font size="3"><tt>scriba.h</tt></font>'.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.2."><H3>3.2.2. Function main(), Variable Declarations</H3></A>

<P>
After some macro definitions that I do not list here the start of the function <font size="3"><tt>main</tt></font> comes:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
main(int argc, char *argv[], char *env[]){
<P>
. . . .  variable declarations . . . . . 
<P>

  pSbProgram pProgram;
<P>

. . . .  variable declarations . . . . . 
<P>
</PRE></FONT>
<P>
This piece of code defines the local variables. The variable <font size="3"><tt>pProgram</tt></font> will hold the pointer to the program object or simply saying <font size="3"><tt>pProgram</tt></font> is the program object variable. The other variables are not described here, their names and the code where they are used should make their usage and purpose clear.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.3."><H3>3.2.3. Command Line handling</H3></A>

<P>
The next piece of code is the command line option handling. This is not described here, because this is nothing special to ScriptBasic.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.4."><H3>3.2.4. Creating Program Object</H3></A>

<P>
The real interesting piece of code starts at this fragment:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
  pProgram = scriba_new(malloc,free);
</PRE></FONT>
<P>

This code first of all creates a new program object calling <a href="#3.3.1.">scriba_new()</A>. The two arguments to this function should be two pointers to two functions that will be used by the interpreter to allocate and release memory. The two functions should exhibit behavior like <font size="3"><tt>malloc</tt></font> and <font size="3"><tt>free</tt></font>. All lower layers inherit these functions and call these functions to get and to release memory. In case there are more than one program objects used they may one after the other or in different threads at the same time use the same functions or different functions. The only requirement is that the functions pointed by the arguments should be thread safe if different threads are started executing ScriptBasic interpreters. Thread safeness also may play important role when some extension module is multi-thread.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.5."><H3>3.2.5. Loading Configuration</H3></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
  scriba_LoadConfiguration(pProgram,pszForcedConfigurationFileName);
</PRE></FONT>
<P>
The next function call is <a href="#3.3.20.">scriba_LoadConfiguration()</A>. This function gets the configuration information from the compiled configuration file. The details of configuration files is detailed in section
<a href="#2.7.">Configuration File Handling</A>.
<P>
It is not a must to call this function from the embedding application, but with some few exceptions most embedding applications will do. Most ScriptBasic interpreter program objects need configuration information to be executed successfully.
<P>
To get the configuration for a program object there are two ways:
<P>
<UL>
<LI> Load the configuration from a file.
<LI> Inherit the configuration information from another program object.
</UL>
<P>
The second approach is necessary to gain performance in case there are several interpreters running one after the other or in parallel threads in the same process. If all these interpreters need the same configuration information they can use the same memory data, because the configuration information is not alterable by the interpreter. This way you can save the successive file loading and the extra memory space.
<P>
When the configuration is inherited it is very important that the program object holding the configuration is not destroyed while any of the inheriting program objects are alive. Therefore such applications usually create a program object that does not run any program but holds the configuration information loaded calling <a href="#"> scriba_LoadConfiguration()</A> and that exists for the life of the whole process.
<P>
For more information how to inherit the configuration information see the function <a href="#3.3.22.">scriba_InheritConfiguration()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.6."><H3>3.2.6. Loading Internal Preprocessors</H3></A>

The next function call loads the internal preprocessors. This is not necessary needed for the applications. This is needed only if there is some way to load an internal preprocessor before the program code is loaded. In the case of the standalone variation the command line option `<font size="3"><tt>-i</tt></font>' can specify internal preprocessor names.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
  iError = scriba_LoadInternalPreprocessor(pProgram,pszIPreproc);
  if( iError ){
    report_report(stderr,"",0,iError,REPORT_ERROR,&amp;iErrorCounter,NULL,&amp;fErrorFlags);
    ERREXIT;
    }
</PRE></FONT>
<P>
If this function is not called by the main program for the program object the interpreter will still process internal preprocessors that are referenced by the program code using the statement <font size="3"><tt>use</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.7."><H3>3.2.7. Setting the File Name</H3></A>

To successfully load a program there is a need for the name of the file that holds the source code. To specify this file name for a program object the function <a href="#"> scriba_SetFileName()</A> should be used.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
  scriba_SetFileName(pProgram,szInputFile);
</PRE></FONT>
<P>
This is the usual way getting the program into the program object, but there is another way. Some applications do not store the BASIC program string in text files, but in some other mass media, like relation database. In that case the application has to load the program string into the application memory and call <a href="#"> scriba_LoadProgramString()</A> to compile and execute the BASIC program. However in this case the program should not contain any <font size="3"><tt>include</tt></font> or <font size="3"><tt>import</tt></font> statement.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.8."><H3>3.2.8. Using the Cache</H3></A>

ScriptBasic is powerful being able to store the compiled version of BASIC programs in binary format in file. The next piece of code checks if there is already a compiled version of the BASIC program in the configured cache directory calling the function <a href="#3.3.45.">scriba_UseCacheFile()</A>
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
  if( scriba_UseCacheFile(pProgram) == SCRIBA_ERROR_SUCCESS ){
    if( (iError = scriba_LoadBinaryProgram(pProgram)) != 0 ){
      ERREXIT;
      }
</PRE></FONT>
<P>
The function <a href="#3.3.36.">scriba_LoadBinaryProgram()</A> loads the binary program.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.9."><H3>3.2.9. Run External Preprocessors</H3></A>

If the cache file is not usable then the source text has to be loaded and compiled. Before that the external preprocessors has to do their jobs if there is any. To do this the function <a href="#3.3.47.">scriba_RunExternalPreprocessor()</A> is called.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
    iError=scriba_RunExternalPreprocessor(pProgram,pszEPreproc);
</PRE></FONT>
<P>
It is not a must for an application to call this function. Some application may require the user to write their program in pure BASIC and not to use any preprocessor.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.10."><H3>3.2.10. Loading the Source Program</H3></A>

When the external preprocessors are done the program has to be loaded calling the function <a href="#3.3.51.">scriba_LoadSourceProgram()</A>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
    if( scriba_LoadSourceProgram(pProgram) )ERREXIT;
</PRE></FONT>
<P>
This call loads the program source and processes it up to the point of execution. All interpreter processing, file reading, inclusion of other files, lexical, syntactical analysis and program building is done calling this function.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.11."><H3>3.2.11. Saving Binary File</H3></A>

Before executing the loaded program the application may save the compiled binary version of the program. This can be done calling the function <a href="#3.3.48.">scriba_SaveCode()</A> to save the binary code into a specific file, or calling the function <a href="#3.3.46.">scriba_SaveCacheFile()</A> to save the binary code into the cache with an automatically calculated name.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
    if( szOutputFile ){
      if( isCoutput )
        scriba_SaveCCode(pProgram,szOutputFile);
      else
        scriba_SaveCode(pProgram,szOutputFile);
      if( !execute )exit(0);
      }
     if( ! nocache )scriba_SaveCacheFile(pProgram);
 </PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.12."><H3>3.2.12. Execute the BASIC Program</H3></A>

This is the step that all the previous steps were done. This function call to <a href="#3.3.53.">scriba_Run()</A> executes the program.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
  if( iError=scriba_Run(pProgram,CmdLinBuffer) ){
 report_report(stderr,"",0,iError,REPORT_ERROR,&amp;iErrorCounter,NULL,&amp;fErrorFlags);
    ERREXIT;
    }
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.2.13."><H3>3.2.13. Destroying the Program Object</H3></A>

Although the program is executed and has finished still there is something extremely important that the application has to do: clean-up.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
  scriba_destroy(pProgram);
<P>

</PRE></FONT>
<P>
The call to <a href="#3.3.2.">scriba_destroy</A> releases all resources (memory) that were allocated to execute the BASIC program. Calling this function is not mandatory in a single process application that executes only one interpreter and exits from the process. In that case not calling this function the operating system is going to release the resources. However this is a bad practice.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3."><H2>3.3. ScriptBasic C API</H2></A>

The ScriptBasic C API is the high level programming interface that any programmer wanting to embed ScriptBasic into any application should use. This is the interface that the readily available variations of ScriptBasic use. This interface provides a general, high level abstraction interface to the ScriptBasic compilation and run-time system.
<P>
The API provides easy to use, and simple functions that can be used straightforward as well as more sophisticated, complex, harder to understand functions for special purpose application. The programmer can start with the simple functions and use the more complex ones as he or she developer the needs not fulfilled with the simpler functions.
<P>
The API delivers an object oriented calling interface even though this API is purely C and not C++. The object oriented interface means that you have to call <font size="3"><tt>scriba_new</tt></font> to create a ScriptBasic object before any other call and you have to pass the returned pointer to each called function as first argument to operate on the actual BASIC program object.
<P>
This approach allow the programmer to allocate, load, compile, run, re-run, release multiple ScriptBasic programs even in multiple threads simultaneously with the limits that the operating system imposes not ScriptBasic.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.1."><H3>3.3.1. scriba_new()</H3></A>

To create a new <font size="3"><tt>SbProgram</tt></font> object you have to call this function. The two arguments
should point to <font size="3"><tt>malloc</tt></font> and <font size="3"><tt>free</tt></font> or similar functions. All later memory allocation
and releasing will be performed using these functions.
<P>
Note that this is the only function that does not require a pointer to an
<font size="3"><tt>SbProgram</tt></font> object.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pSbProgram scriba_new(void * (*maf)(size_t),
                      void   (*mrf)(void *)
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.2."><H3>3.3.2. scriba_destroy()</H3></A>

After a ScriptBasic program was successfully execued and there is no need to
run it anymore call this function to release all memory associated with the
code.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_destroy(pSbProgram pProgram
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.3."><H3>3.3.3. scriba_NewSbData()</H3></A>

Allocate and return a pointer to the allocated <font size="3"><tt>SbData</tt></font> structure.
<P>
This structure can be used to store ScriptBasic variable data,
long, double or string. This function is called by other functions
from this module. Usually the programmer, who embeds ScriptBasic will rarely
call this function directly. Rather he/she will use <a href="#3.3.6.">scriba_NewSbLong()</A> (as an example)
that creates a variable capable holding a <font size="3"><tt>long</tt></font>, sets the type to 
be <font size="3"><tt>SBT_LNG</tt></font> and stores initial value.
<P>
See also <a href="#3.3.6.">scriba_NewSbLong()</A>, <a href="#3.3.7.">scriba_NewSbDouble()</A>, <a href="#3.3.8.">scriba_NewSbUndef()</A>, <a href="#3.3.9.">scriba_NewSbString()</A>,
<a href="#3.3.10.">scriba_NewSbBytes()</A>, <a href="#3.3.11.">scriba_DestroySbData()</A>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pSbData scriba_NewSbData(pSbProgram pProgram
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.4."><H3>3.3.4. scriba_InitSbData()</H3></A>

This function initializes an SbData structure to hold undef value.
This function should be used to initialize an allocated <font size="3"><tt>SbData</tt></font>
memory structure. This function internally is called by <a href="#3.3.3.">scriba_NewSbData()</A>.
<P>
See also <a href="#3.3.6.">scriba_NewSbLong()</A>, <a href="#3.3.7.">scriba_NewSbDouble()</A>, <a href="#3.3.8.">scriba_NewSbUndef()</A>, <a href="#3.3.9.">scriba_NewSbString()</A>,
<a href="#3.3.10.">scriba_NewSbBytes()</A>, <a href="#3.3.11.">scriba_DestroySbData()</A>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_InitSbData(pSbProgram pProgram,
                         pSbData p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.5."><H3>3.3.5. scriba_UndefSbData()</H3></A>

This function sets an <font size="3"><tt>SbData</tt></font> structure to hold the undefined value.
<P>
This function should should not be used instead of <a href="#3.3.4.">scriba_InitSbData()</A>.
While that function should be used to inititalize the memory structure this
function should be used to set the value of an alreasdy initialized and probably
used <font size="3"><tt>SbData</tt></font> variable to <font size="3"><tt>undef</tt></font>.
<P>
The difference inside is that if the <font size="3"><tt>SbData</tt></font> structure is a string then this
function releases the memory occupied by the string, while <a href="#3.3.4.">scriba_InitSbData()</A> does not.
<P>
See also <a href="#3.3.6.">scriba_NewSbLong()</A>, <a href="#3.3.7.">scriba_NewSbDouble()</A>, <a href="#3.3.8.">scriba_NewSbUndef()</A>, <a href="#3.3.9.">scriba_NewSbString()</A>,
<a href="#3.3.10.">scriba_NewSbBytes()</A>, <a href="#3.3.11.">scriba_DestroySbData()</A>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_UndefSbData(pSbProgram pProgram,
                        pSbData p
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.6."><H3>3.3.6. scriba_NewSbLong()</H3></A>

This function allocates and returns a pointer pointing to a structure of
type <font size="3"><tt>SbData</tt></font> holding a <font size="3"><tt>long</tt></font> value. If the allocation failed the return
value is <font size="3"><tt>NULL</tt></font>. If the memory allocation was successful the allocated
structure will have the type <font size="3"><tt>SBT_LONG</tt></font> and will hold the initial value
specified by the argument <font size="3"><tt>lInitValue</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pSbData scriba_NewSbLong(pSbProgram pProgram,
                         long lInitValue
  )@{
</PRE></FONT>
See also <a href="#3.3.6.">scriba_NewSbLong()</A>, <a href="#3.3.7.">scriba_NewSbDouble()</A>, <a href="#3.3.8.">scriba_NewSbUndef()</A>, <a href="#3.3.9.">scriba_NewSbString()</A>,
<a href="#3.3.10.">scriba_NewSbBytes()</A>, <a href="#3.3.11.">scriba_DestroySbData()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.7."><H3>3.3.7. scriba_NewSbDouble()</H3></A>

This function allocates and returns a pointer pointing to a structure of
type <font size="3"><tt>SbData</tt></font> holding a <font size="3"><tt>double</tt></font> value. If the allocation failed the return
value is <font size="3"><tt>NULL</tt></font>. If the memory allocation was successful the allocated
structure will have the type <font size="3"><tt>SBT_DOUBLE</tt></font> and will hold the initial value
specified by the argument <font size="3"><tt>dInitValue</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pSbData scriba_NewSbDouble(pSbProgram pProgram,
                           double dInitValue
  )@{
</PRE></FONT>
See also <a href="#3.3.6.">scriba_NewSbLong()</A>, <a href="#3.3.7.">scriba_NewSbDouble()</A>, <a href="#3.3.8.">scriba_NewSbUndef()</A>, <a href="#3.3.9.">scriba_NewSbString()</A>,
<a href="#3.3.10.">scriba_NewSbBytes()</A>, <a href="#3.3.11.">scriba_DestroySbData()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.8."><H3>3.3.8. scriba_NewSbUndef()</H3></A>

This function allocates and returns a pointer pointing to a structure of
type <font size="3"><tt>SbData</tt></font> holding an <font size="3"><tt>undef</tt></font> value. If the allocation failed the return
value is <font size="3"><tt>NULL</tt></font>. If the memory allocation was successful the allocated
structure will have the type <font size="3"><tt>SBT_UNDEF</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pSbData scriba_NewSbUndef(pSbProgram pProgram
  )@{
</PRE></FONT>
See also <a href="#3.3.6.">scriba_NewSbLong()</A>, <a href="#3.3.7.">scriba_NewSbDouble()</A>, <a href="#3.3.8.">scriba_NewSbUndef()</A>, <a href="#3.3.9.">scriba_NewSbString()</A>,
<a href="#3.3.10.">scriba_NewSbBytes()</A>, <a href="#3.3.11.">scriba_DestroySbData()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.9."><H3>3.3.9. scriba_NewSbString()</H3></A>

This function allocates and returns a pointer pointing to a structure of
type <font size="3"><tt>SbData</tt></font> holding a string value. If the allocation failed the return
value is <font size="3"><tt>NULL</tt></font>. If the memory allocation was successful the allocated
structure will have the type <font size="3"><tt>SBT_STRING</tt></font> and will hold the initial value
specified by the argument <font size="3"><tt>pszInitValue</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pSbData scriba_NewSbString(pSbProgram pProgram,
                           char *pszInitValue
  )@{
</PRE></FONT>
<B>Note on ZCHAR termination:</B>
<P>
The init value <font size="3"><tt>pszInitValue</tt></font> should be a zchar terminated string. Note that
ScriptBasic internally stores the strings as series byte and the length of the
string without any terminating zchar. Therefore the length of the string
that is stored should have been <font size="3"><tt>strlen(pszInitValue)</tt></font>. This does not contain the
terminating zchar.
<P>
In reality however we allocate an extra byte that stores the zchar, but the
size of the string is one character less. Therefore ScriptBasic routines
will recognize the size of the string correct and also the caller can
use the string using the macro <font size="3"><tt>scriba_GetString</tt></font> as a zchar terminated
C string. This requires an extra byte of storage for each string passed from the
embedding C application to ScriptBasic, but saves a lot of hedeache and also
memory copy when the string has to be used as a zchar terminated string.
<P>
See also <a href="#3.3.6.">scriba_NewSbLong()</A>, <a href="#3.3.7.">scriba_NewSbDouble()</A>, <a href="#3.3.8.">scriba_NewSbUndef()</A>, <a href="#3.3.9.">scriba_NewSbString()</A>,
<a href="#3.3.10.">scriba_NewSbBytes()</A>, <a href="#3.3.11.">scriba_DestroySbData()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.10."><H3>3.3.10. scriba_NewSbBytes()</H3></A>

This function allocates and returns a pointer pointing to a structure of
type <font size="3"><tt>SbData</tt></font> holding a string value. If the allocation failed the return
value is <font size="3"><tt>NULL</tt></font>. If the memory allocation was successful the allocated
structure will have the type <font size="3"><tt>SBT_STRING</tt></font> and will hold the initial value
specified by the argument <font size="3"><tt>pszInitValue</tt></font> of the length <font size="3"><tt>len</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pSbData scriba_NewSbBytes(pSbProgram pProgram,
                          unsigned long len,
                          unsigned char *pszInitValue
  )@{
</PRE></FONT>
This function allocates <font size="3"><tt>len</tt></font>+1 number of bytes data and
stores the initial value pointed by <font size="3"><tt>pszInitValue</tt></font> in it.
<P>
The extra plus one byte is an extra terminating zero char
that may help the C programmers to handle the string
in case it is not binary. Please also read the not on the terminating ZChar
in the function <a href="#3.3.9.">scriba_NewSbString()</A>.
<P>
See also <a href="#3.3.6.">scriba_NewSbLong()</A>, <a href="#3.3.7.">scriba_NewSbDouble()</A>, <a href="#3.3.8.">scriba_NewSbUndef()</A>, <a href="#3.3.9.">scriba_NewSbString()</A>,
<a href="#3.3.10.">scriba_NewSbBytes()</A>, <a href="#3.3.11.">scriba_DestroySbData()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.11."><H3>3.3.11. scriba_DestroySbData()</H3></A>

Call this function to release the memory that was allocated by any
of the <font size="3"><tt>NewSbXXX</tt></font> functions. This function releases the memory and
also cares to release the memory occupied by the characters in case the
value had the type <font size="3"><tt>SBT_STRING</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_DestroySbData(pSbProgram pProgram,
                          pSbData p
  )@{
</PRE></FONT>
See also <a href="#3.3.6.">scriba_NewSbLong()</A>, <a href="#3.3.7.">scriba_NewSbDouble()</A>, <a href="#3.3.8.">scriba_NewSbUndef()</A>, <a href="#3.3.9.">scriba_NewSbString()</A>,
<a href="#3.3.10.">scriba_NewSbBytes()</A>, <a href="#3.3.11.">scriba_DestroySbData()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.12."><H3>3.3.12. scriba_PurgeReaderMemory()</H3></A>

Call this function to release all memory that was allocated by the
reader module. The memory data is needed so long as long the lexical analyzer
has finished.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_PurgeReaderMemory(pSbProgram pProgram
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.13."><H3>3.3.13. scriba_PurgeLexerMemory()</H3></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_PurgeLexerMemory(pSbProgram pProgram
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.14."><H3>3.3.14. scriba_PurgeSyntaxerMemory()</H3></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_PurgeSyntaxerMemory(pSbProgram pProgram
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.15."><H3>3.3.15. scriba_PurgeBuilderMemory()</H3></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_PurgeBuilderMemory(pSbProgram pProgram
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.16."><H3>3.3.16. scriba_PurgePreprocessorMemory()</H3></A>

This function purges the memory that was needed to run the preprocessors.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_PurgePreprocessorMemory(pSbProgram pProgram
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.17."><H3>3.3.17. scriba_PurgeExecuteMemory()</H3></A>

This function purges the memory that was needed to execute the program,
but before that it executes the finalization part of the execution.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_PurgeExecuteMemory(pSbProgram pProgram
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.18."><H3>3.3.18. scriba_SetFileName()</H3></A>

Call this function to set the file name where the source informaton is.
This file name is used by the functions <a href="#3.3.36.">scriba_LoadBinaryProgram()</A> and
<a href="#3.3.51.">scriba_LoadSourceProgram</A> as well as error reporting functions to display
the location of the error.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_SetFileName(pSbProgram pProgram,
                       char *pszFileName
  )@{
</PRE></FONT>
The argument <font size="3"><tt>pszFileName</tt></font> should be zchar terminated
string holding the file name.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.19."><H3>3.3.19. scriba_GettingConfiguration()</H3></A>

<a href="#3.3.20.">scriba_LoadConfiguration()</A> and <a href="#3.3.22.">scriba_InheritConfiguration()</A> can be used to
specify configuration information for a ScriptBasic program. Here
we describe the differences and how to use the two functions for
single-process single-basic and for single-process multiple-basic
applications.
<P>
To execute a ScriptBasic program you usually need configuration information.
The configuration information for the interpreter is stored in a file.
The function <a href="#3.3.20.">scriba_LoadConfiguration()</A> reads the file and loads it into memory
into the <font size="3"><tt>SbProgram</tt></font> object. When the object is destroyed the configuration
information is automatically purged from memory.
<P>
Some implementations like the Eszter SB Engine variation of ScriptBasic starts
several interpreter thread within the same process. In this case the configuration
information is read only once and all the running interpreters share the same
configuration information.
<P>
To do this the embedding program has to create a pseudo <font size="3"><tt>SbProgram</tt></font> object that
does not run any ScriptBasic program, but is used only to load the configuration
information calling the function <a href="#3.3.20.">scriba_LoadConfiguration()</A>. Other <font size="3"><tt>SbProgram</tt></font> objects
that do intepret ScriptBasic program should inherit this configuration calling the
function <a href="#3.3.22.">scriba_InheritConfiguration()</A>. When a <font size="3"><tt>SbProgram</tt></font> object is destroyed the
configuration is not destroyed if that was inherited belonging to a different object.
It remains in memory and can later be used by other intrepreter instances.
<P>
Inheriting the configuration is fast because it does not require loading the
configuration information from file. This is essentially sets a pointer in the
internal interpreter structure to point to the configuration information held
by the other object and all the parallel running interpreters structures
point to the same piece of memory holding the common configuration information.
<P>
See the configuration handling functions <a href="#3.3.20.">scriba_LoadConfiguration()</A> and <a href="#3.3.22.">scriba_InheritConfiguration()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.20."><H3>3.3.20. scriba_LoadConfiguration()</H3></A>

This function should be used to load the configuration information
from a file.
<P>
The return value is zero on success and the error code when error happens.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_LoadConfiguration(pSbProgram pProgram,
                             char *pszForcedConfigurationFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.21."><H3>3.3.21. scriba_GetConfigFileName()</H3></A>

This function tells whet the configuration file is. There is no need to call this function to read the configuration file.
This is needed only when the main program want to manipulate the configuration file in some way. For example the command
line version of ScriptBasic uses this function when the option <font size="3"><tt>-k</tt></font> is used to compile a configuration file.
<P>
The first argument has to be a valid ScriptBasic program object. The second argument should point to a valid <font size="3"><tt>char *</tt></font> pointer that
will get the pointer value to the configuration file name after the function returns.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_GetConfigFileName(pSbProgram pProgram,
                             char **ppszFileName
  )@{
</PRE></FONT>
The function returns zero if no error happens, or the error code.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.22."><H3>3.3.22. scriba_InheritConfiguration()</H3></A>

Use this function to get the configuration from another program object.
<P>
The return value is zero on success and error code if error has happened.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_InheritConfiguration(pSbProgram pProgram,
                                pSbProgram pFrom
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.23."><H3>3.3.23. scriba_InitModuleInterface()</H3></A>

Initialize the Support Function Table of a process level ScriptBasic program object to be inherited
by other program objects. If you read it first time, read on until you understand what this
function really does and rather how to use it!
<P>
This is going to be a bit long, but you better read it along with the documentation of the
function <a href="#3.3.24.">scriba_InheritModuleInterface()</A>.
<P>
This function is needed only for programs that are
<UL>
<LI> multi thread running several interpreters simultaneous in a single process
<LI> support modules like the sample module <font size="3"><tt>mt</tt></font> that support multithread behaviour and
      need to implement worker thread needing call-back functions.
@end itemize
<P>
You most probably know that modules can access system and ScriptBasic fucntions via a
call-back table. That is a huge <font size="3"><tt>struct</tt></font> containing pointers to the functions that
ScriptBasic implements. This is the <font size="3"><tt>ST</tt></font> (aka support table).
<P>
This helps module writers to write system independent
code as well as to access ScriptBasic functions easily. On the other hand modules are
also free to alter this table and because many functions, tough not all are called via this
table by ScriptBasic itself a module may alter the core behavior of ScriptBasic.
<P>
For this reason each interpreter has its own copy of <font size="3"><tt>ST</tt></font>.
This means that if an interpreter alters the table it has no effect on another interpreter
running in the same process in anther thread.
<P>
This is fine so far. How about modules that run asynchronous threads? For example the very first
interpter thread that uses the module <font size="3"><tt>mt</tt></font> starts in the initialization a thread that later 
deletes all sessions that time out. This thread lives a long life.
<P>
The thread that starts the worker thread is an interpreter thread and has its own copy of the <font size="3"><tt>ST</tt></font>.
The thread started asynchronous however should not use this <font size="3"><tt>ST</tt></font> because the table is purged 
from memory when the interpreter instance it blelonged to finishes.
<P>
To have <font size="3"><tt>ST</tt></font> for worker threads there is a need for a program object that is not purged
from memory so long as long the process is alive. Fortunately there is such an object: the
configuration program object. Configuration is usually read only once by multi-thread implementations
and the same configuration information is shared by the serveral threads. The same way the
several program objects may share a <font size="3"><tt>ST</tt></font>.
<P>
The difference is that configuration is NOT altered by the interpreter or by any module in any way
but <font size="3"><tt>ST</tt></font> may. Thus each  execution object has two pointers: <font size="3"><tt>pST</tt></font> and <font size="3"><tt>pSTI</tt></font>. While <font size="3"><tt>pST</tt></font> points to
the support table that belongs to the interpreter instance the secondpointer <font size="3"><tt>pSTI</tt></font> points to
a <font size="3"><tt>ST</tt></font> that is global for the whole process and is permanent. This <font size="3"><tt>ST</tt></font> is to be used by worker threads
and should not be altered by the module without really good reason.
<P>
Thus: Don't call this function for normal program objects! For usualy program objects module
interface is automatically initialized when the first module function is called. Call this function
to initialize a <font size="3"><tt>ST</tt></font> for a pseudo program object that is never executed but rather used to inherit this
<font size="3"><tt>ST</tt></font> for worker threads.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_InitModuleInterface(pSbProgram pProgram
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.24."><H3>3.3.24. scriba_InheritModuleInterface()</H3></A>

Inherit the support function table (<font size="3"><tt>ST</tt></font>) from another program object.
<P>
Note that the program object is going to initialize its own <font size="3"><tt>ST</tt></font> the normal
way. The inherited <font size="3"><tt>ST</tt></font> will only be used by worker threads that live a long
life and may exist when the initiating interpreter thread already exists.
<P>
For further information please read the description of the function <a href="#3.3.23.">scriba_InitModuleInterface()</A>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_InheritModuleInterface(pSbProgram pProgram,
                                  pSbProgram pFrom
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.25."><H3>3.3.25. scriba_InheritExecuteObject()</H3></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_InheritExecuteObject(pSbProgram pProgram,
                                  pSbProgram pFrom
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.26."><H3>3.3.26. scriba_SetProcessSbObject()</H3></A>

Use this program in multi-thread environment to tell the actual interpreter
which object is the process level pseudo object that 
<P>
<UL>
<LI> holds the shared (among interpreter thread objects) configuration 
information (see <a href="#3.3.22.">scriba_InheritConfiguration()</A>)
<LI> holds the process level module interface (see <a href="#3.3.24.">scriba_InheritModuleInterface()</A>)
<LI> holds the list of loaded modules that are not unloaded by the thread loaded the module
@end itemize
<P>
If the embeddingprogram calls this function there is no need to call <a href="#3.3.22.">scriba_InheritConfiguration()</A>
and <a href="#3.3.24.">scriba_InheritModuleInterface()</A>. This function call does all those tasks and also other things.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_SetProcessSbObject(pSbProgram pProgram,
                              pSbProgram pProcessObject
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.27."><H3>3.3.27. scriba_ShutdownMtModules()</H3></A>

A multi threaded application should call this function for the process SB object
when the process finishes. Calling this function will call each of the shutdown
functions of those external modules that decided to keep in memory and export
the shutdown function named <font size="3"><tt>shutmodu</tt></font>. This allows these modules to gracefully
shut down their operation. As an example cached data can be written to disk, or
database connections can be closed.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_ShutdownMtModules(pSbProgram pProgram
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.28."><H3>3.3.28. scriba_SetCgiFlag()</H3></A>

You can call this function to tell the reporting subsystem that
this code runs in a CGI environment and therefore it should format
error messages according to the CGI standard sending to the 
standard output including HTTP headers and HTML code pieces.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_SetCgiFlag(pSbProgram pProgram
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.29."><H3>3.3.29. scriba_SetReportFunction()</H3></A>

This function should be used to set the report function for a program. The report function
is used to send info, warning, error, fatal and internal error messages to the user.
<P>
In case you want to implement a specific report function see the sample implementation in the
file <font size="3"><tt>report.c</tt></font>. The documentation of the function <font size="3"><tt>report_report</tt></font> describes not only the details
of the sample implementation but also the implementation requests for other reporting functions.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_SetReportFunction(pSbProgram pProgram,
                              void *fpReportFunction
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.30."><H3>3.3.30. scriba_SetReportPointer()</H3></A>

This pointer will be passed to the reporting function. The default
reporting uses this pointer as a <font size="3"><tt>FILE *</tt></font> pointer. The default value
for this pointer is <font size="3"><tt>stderr</tt></font>.
<P>
Other implementations of the reporting function may use this pointer
according their needs. For example the WIN32 IIS ISAPI implementation
uses this pointer to point to the extension controll block structure.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_SetReportPointer(pSbProgram pProgram,
                             void *pReportPointer
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.31."><H3>3.3.31. scriba_SetStdin()</H3></A>

You can call this function to define a special standard input function. This
pointer should point to a function that accepts a <font size="3"><tt>void *</tt></font> pointer
as argument. Whenever the ScriptBasic program tries to read from the
standard input it calls this function pasing the embedder pointer as
argument.
<P>
If the <font size="3"><tt>stdin</tt></font> function is not defined or the parameter is <font size="3"><tt>NULL</tt></font>
the interpreter will read the normal <font size="3"><tt>stdin</tt></font> stream.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_SetStdin(pSbProgram pProgram,
                     void *fpStdinFunction
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.32."><H3>3.3.32. scriba_SetStdout()</H3></A>

You can call this function to define a special standard output function. This
pointer should point to a function that accepts a <font size="3"><tt>(char, void *)</tt></font> arguments.
Whenever the ScriptBasic program tries to send a character to the standard output
it calls this function. The first parameter is the character to write, the second
is the embedder pointer.
<P>
If the standard output function is not defined or the parameter is <font size="3"><tt>NULL</tt></font>
the interpreter will write the normal <font size="3"><tt>stdout</tt></font> stream.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_SetStdout(pSbProgram pProgram,
                      void *fpStdoutFunction
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.33."><H3>3.3.33. scriba_SetEmbedPointer()</H3></A>

This function should be used to set the embed pointer.
<P>
The embed pointer is a pointer that is not used by ScriptBasic itself. This
pointer is remembered by ScriptBasic and is passed to call-back functions.
Like the standard input, output and environment functions that the embedding
application may provide this pointer is also available to external modules implemented
in C or other compiled language in DLL or SO files.
<P>
The embedder pointer should usually point to the <font size="3"><tt>struct</tt></font> of the thread local data.
For example the Windows NT IIS variation of ScriptBasic sets this variable to point to
the extension control block.
<P>
If this pointer is not set ScriptBasic will pass <font size="3"><tt>NULL</tt></font> pointer to the extensions and
to the call-back function.
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_SetEmbedPointer(pSbProgram pProgram,
                            void *pEmbedder
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.34."><H3>3.3.34. scriba_SetEnvironment()</H3></A>

You can call this function to define a special environment query function. This
pointer should point to a function that accepts a <font size="3"><tt>(void *, char *, long )</tt></font> arguments.
<P>
Whenever the ScriptBasic program tries to get the value of an enviroment variable
it calls this function. The first argument is the embedder pointer.
<P>
The second argument is the name of the environment variable to retrieve or <font size="3"><tt>NULL</tt></font>.
<P>
The third argument is either zero or is the serial number of the environment variable.
<P>
ScriptBasic never calls this function with both specifying the environment variable name
and the serial number.
<P>
The return value of the function should either be <font size="3"><tt>NULL</tt></font> or should point to a string that
holds the zero character terminated value of the environment variable. This string is not
changed by ScriptBasic.
<P>
If the special environment function is not defined or is <font size="3"><tt>NULL</tt></font> ScriptBasic uses the
usual environment of the process calling the system function<font size="3"><tt>getenv</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_SetEnvironment(pSbProgram pProgram,
                           void *fpEnvirFunction
  )@{
</PRE></FONT>
For a good example of a self-written environment function see the source of the Eszter SB Engine
that alters the environment function so that the ScriptBasic programs feel as if they were executed in a
real CGI environment.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.35."><H3>3.3.35. scriba_LoadBinaryProgramWithOffset()</H3></A>

Use this function to load ScriptBasic program from a file that is already compiled into
internal form, and the content of the program is starting on <font size="3"><tt>lOffset</tt></font>
<P>
The return value is the number of errors (hopefully zero) during program load.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_LoadBinaryProgramWithOffset(pSbProgram pProgram,
                                       long lOffset,
                                       long lEOFfset
  )@{
</PRE></FONT>
Before calling this function the function <a href="#3.3.18.">scriba_SetFileName()</A> should have been called specifying the
file name.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.36."><H3>3.3.36. scriba_LoadBinaryProgram()</H3></A>

Use this function to load ScriptBasic program from a file that is already compiled into
internal form.
<P>
The return value is the number of errors (hopefully zero) during program load.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_LoadBinaryProgram(pSbProgram pProgram
  )@{
</PRE></FONT>
Before calling this function the function <a href="#3.3.18.">scriba_SetFileName()</A> should have been called specifying the
file name.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.37."><H3>3.3.37. scriba_InheritBinaryProgram()</H3></A>

Use this function in application that keeps the program code in memory.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_InheritBinaryProgram(pSbProgram pProgram,
                                pSbProgram pFrom
  )@{
</PRE></FONT>
<P>
The function inherits the binary code from the program object <font size="3"><tt>pFrom</tt></font>.
In server type applications the compiled binary code of a BASIC program may
be kept in memory. To do this a pseudo program object should be created that
loads the binary code and is not destroyed.
<P>
The program object used to execute the code should inherit the binary code from
this pseudo object calling this function. This is similar to the configuration
inheritance.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.38."><H3>3.3.38. scriba_LoadInternalPreprocessor()</H3></A>

This function can be used by embedding applications to load an
internal preprocessor into the interpereter. Note that preprocessors
are usually loaded by the reader module when a <font size="3"><tt>preprocess</tt></font> statement
is found. However some preprocessors in some variation of the interpreter
may be loaded due to configuration or command line option and not
because the source requests it.
<P>
The preprocessors that are requested to be loaded because the source
contains a <font size="3"><tt>preprocess</tt></font> line usually implement special language
fetures. The preprocessors that are loaded independent of the source
because command line option or some other information tells the variation
to call this function are usually debuggers, profilers.
<P>
(To be honest, by the time I write it there is no any internal preprocessors
developed except the test one, but the statement above will become true.)
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_LoadInternalPreprocessor(pSbProgram pProgram,
                            char *ppszPreprocessorName[]
  )@{
</PRE></FONT>
The first argument is the program object. If the program object does not
have a preprocessor object the time it is called the preprocessor object is
created and initiated.
<P>
The second argument is the array of names of the preprocessor as it is present
in the configuration file. This is not the name of the DLL/SO file, but
rather the symbolic name, which is associated with the file. The final element
of the array has to be <font size="3"><tt>NULL</tt></font>.
<P>
The return value is zero or the error code.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.39."><H3>3.3.39. scriba_ReadSource()</H3></A>

Loads the source code of a ScriptBasic program from a text file.
<P>
The return code is the number of errors happened during read.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_ReadSource(pSbProgram pProgram
  )@{
</PRE></FONT>
<B>Do not get confused!</B> This function only reads the source. Does not compile it.
You will usually need <a href="#3.3.51.">scriba_LoadSourceProgram()</A> that does reading, analyzing, building
and all memory releases leaving finally a ready-to-run code in memory.
<P>
Before calling this function the function <a href="#3.3.18.">scriba_SetFileName()</A> should have been called specifying the
file name.
<P>
See also <a href="#3.3.39.">scriba_ReadSource()</A>, <a href="#3.3.40.">scriba_DoLexicalAnalysis()</A>,
<a href="#3.3.41.">scriba_DoSyntaxAnalysis()</A>, <a href="#3.3.42.">scriba_BuildCode()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.40."><H3>3.3.40. scriba_DoLexicalAnalysis()</H3></A>

This function performs lexical analysis after the source file has beed read.
<P>
This function is rarely needeed by applicationdevelopers. See <a href="#3.3.51.">scriba_LoadSourceProgram()</A>
instead.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_DoLexicalAnalysis(pSbProgram pProgram
  )@{
</PRE></FONT>
See also <a href="#3.3.39.">scriba_ReadSource()</A>, <a href="#3.3.40.">scriba_DoLexicalAnalysis()</A>,
<a href="#3.3.41.">scriba_DoSyntaxAnalysis()</A>, <a href="#3.3.42.">scriba_BuildCode()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.41."><H3>3.3.41. scriba_DoSyntaxAnalysis()</H3></A>

This function performs syntax analysis after the lexical analysis has been finished.
<P>
This function is rarely needeed by applicationdevelopers. See <a href="#3.3.51.">scriba_LoadSourceProgram()</A>
instead.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_DoSyntaxAnalysis(pSbProgram pProgram
  )@{
</PRE></FONT>
See also <a href="#3.3.39.">scriba_ReadSource()</A>, <a href="#3.3.40.">scriba_DoLexicalAnalysis()</A>,
<a href="#3.3.41.">scriba_DoSyntaxAnalysis()</A>, <a href="#3.3.42.">scriba_BuildCode()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.42."><H3>3.3.42. scriba_BuildCode()</H3></A>

This function builds the finall ready-to-run code after the syntax
analisys has been finished.
<P>
This function is rarely needeed by applicationdevelopers. See <a href="#3.3.51.">scriba_LoadSourceProgram()</A>
instead.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_BuildCode(pSbProgram pProgram
  )@{
</PRE></FONT>
See also <a href="#3.3.39.">scriba_ReadSource()</A>, <a href="#3.3.40.">scriba_DoLexicalAnalysis()</A>,
<a href="#3.3.41.">scriba_DoSyntaxAnalysis()</A>, <a href="#3.3.42.">scriba_BuildCode()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.43."><H3>3.3.43. scriba_IsFileBinaryFormat()</H3></A>

This function decides if a file is a correct binary format ScriptBasic
code file and returns true if it is binary. If the file is a ScriptBasic
source file or an older version binary of ScriptBasic or any other file
it returns zero.
<P>
This function just calls the function <font size="3"><tt>build_IsFileBinaryFormat</tt></font>
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_IsFileBinaryFormat(pSbProgram pProgram
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.44."><H3>3.3.44. scriba_GetCacheFileName()</H3></A>

Calculate the name of the cache file for the given source file name and
store the calculated file name in the program object.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_GetCacheFileName(pSbProgram pProgram
  )@{
</PRE></FONT>
The program returns zero or the error code. It returns <font size="3"><tt>SCRIBA_ERROR_FAIL</tt></font> if there
is no cache directory configured.
<P>
The code uses a local buffer of length 256 bytes. The full cached file name should
fit into this otherwise the program will return <font size="3"><tt>SCRIBA_ERROR_BUFFER_SHORT</tt></font>.
<P>
The code does not check if there exists an appropriate cache directory or file. It
just calculates the file name.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.45."><H3>3.3.45. scriba_UseCacheFile()</H3></A>

Call this function to test that the cache file is usable. This function
calls the function <a href="#3.3.44.">scriba_GetCacheFileName()</A> to calculate the cache file name.
<P>
If 
<UL>
<LI> the cache file exists
<LI> is newer than the source file set by <a href="#3.3.18.">scriba_SetFileName()</A>
<LI> is a correct ScriptBasic binary file
@end itemize
then this function alters the source file name property (<font size="3"><tt>pszFileName</tt></font>)
of the program object so that the call to <a href="#3.3.36.">scriba_LoadBinaryProgram()</A> will try to
load the cache file.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_UseCacheFile(pSbProgram pProgram
  )@{
</PRE></FONT>
The function returns zero or the error code. The function returns <font size="3"><tt>SCRIBA_ERROR_FAIL</tt></font>
in case the cache file is old, or not valid. Therefore returning a positive value
does not neccessarily mean a hard error.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.46."><H3>3.3.46. scriba_SaveCacheFile()</H3></A>

Call this function to generate a cache file after
a successful program compilation.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_SaveCacheFile(pSbProgram pProgram
  )@{
</PRE></FONT>
The function returns zero (<font size="3"><tt>SCRIBA_ERROR_SUCCESS</tt></font>) if there was no error.
This does not mean that the cache file was saved. If there is no cache
directory configured doing nothing is success.
<P>
Returning any positive error code means that ScriptBasic tried to write a
cache file but it could not.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.47."><H3>3.3.47. scriba_RunExternalPreprocessor()</H3></A>

This function should be called to execute external preprocessors.
<P>
This function does almost nothing else but calls the function
<font size="3"><tt>epreproc()</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_RunExternalPreprocessor(pSbProgram pProgram,
                                   char **ppszArgPreprocessor
  )@{
</PRE></FONT>
The argument <font size="3"><tt>ppszArgPreprocessor</tt></font> should point to a string array. This string array
should contain the configured names of the preprocessors that are applied one after the
other in the order they are listed in the array.
<P>
Note that this array should contain the symbolic names of the preprocessors. The actual
preprocessor executable programs, or command lines are defined in the configuration
file.
<P>
After calling this function the source file name property of the program object (<font size="3"><tt>pszFileName</tt></font>)
is also modified so that it points to the result of the preprocessor. This means that after the
successful return of this function the application may immediately call <a href="#3.3.51.">scriba_LoadSourceProgram()</A>.
<P>
If there is any error during the preprocessor execution the function returns some error code
(returned by <font size="3"><tt>epreproc</tt></font>) otherwise the return value is zero.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.48."><H3>3.3.48. scriba_SaveCode()</H3></A>

Call this function to save the compiled byte code of the program
into a specific file. This function is called by the function <a href="#3.3.46.">scriba_SaveCacheFile()</A>.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_SaveCode(pSbProgram pProgram,
                     char *pszCodeFileName
  )@{
</PRE></FONT>
The function does nothing else, but calls <font size="3"><tt>build_SaveCode</tt></font>.
<P>
The return code is zero or the error code returned by <font size="3"><tt>build_SaveCode</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.49."><H3>3.3.49. scriba_SaveCCode()</H3></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_SaveCCode(pSbProgram pProgram,
                      char *pszCodeFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.50."><H3>3.3.50. scriba_SaveECode()</H3></A>

<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_SaveECode(pSbProgram pProgram,
                      char *pszInterpreter,
                      char *pszCodeFileName
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.51."><H3>3.3.51. scriba_LoadSourceProgram()</H3></A>

Call this function to load a BASIC program from its source format after
optionally checking that there is no available cache file and after
executing all required preprocessors. This function calls
<a href="#3.3.39.">scriba_ReadSource()</A>, <a href="#3.3.40.">scriba_DoLexicalAnalysis()</A>, <a href="#3.3.41.">scriba_DoSyntaxAnalysis()</A>, <a href="#3.3.42.">scriba_BuildCode()</A>,
and also releases the memory that was needed only for code building
calling <a href="#3.3.12.">scriba_PurgeReaderMemory()</A>, <a href="#3.3.13.">scriba_PurgeLexerMemory()</A>, <a href="#3.3.14.">scriba_PurgeSyntaxerMemory()</A>.
<P>
After the successful completion of this program the BASIC program is in
the memory in the ready-to-run state.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_LoadSourceProgram(pSbProgram pProgram
  )@{
</PRE></FONT>
Before calling this function the function <a href="#3.3.18.">scriba_SetFileName()</A> should have been called specifying the
file name.
<P>
The return value is zero (<font size="3"><tt>SCRIBA_ERROR_SUCCESS</tt></font>) or the error code returned by the
underlying layer that has detected the error.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.52."><H3>3.3.52. scriba_LoadProgramString()</H3></A>

Use this function to convert a string containing a BASIC program
that is already in memory to ready-to-run binary format. This function
is same as <a href="#3.3.51.">scriba_LoadSourceProgram()</A> except that this function reads the source
code from a string instead of a file.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_LoadProgramString(pSbProgram pProgram,
                             char *pszSourceCode,
                             unsigned long cbSourceCode
  )@{
</PRE></FONT>
The argument <font size="3"><tt>pProgram</tt></font> is the program object. The argument <font size="3"><tt>pszSourceCode</tt></font>
is the BASIC program itself in text format. Because the source code may
contain ZCHAR just for any chance the caller has to provide the number of
characters in the buffer via the argument <font size="3"><tt>cbSourceCode</tt></font>. In case the
source program is zero terminated the caller can simply say
<font size="3"><tt>strlen(pszSourceCode)</tt></font> to give this argument.
<P>
Before calling this function the function <a href="#3.3.18.">scriba_SetFileName()</A> may be called. Altough
the source code is read from memory and thus there is no source file the
BASIC program may use the command <font size="3"><tt>include</tt></font> or <font size="3"><tt>import</tt></font> that includes
another source file after reading the code. If the program does so the reader
functions need to know the actual file name of the source code to find
the file to be included. To help this process the caller using this function
may set the file name calling <a href="#3.3.18.">scriba_SetFileName()</A>. However that file is never used
and need not even exist. It is used only to calculate the path of included files
that are specified using relative path.
<P>
The return value is zero (<font size="3"><tt>SCRIBA_ERROR_SUCCESS</tt></font>) or the error code returned by the
underlying layer that has detected the error.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.53."><H3>3.3.53. scriba_Run()</H3></A>

Call this function to execute a program. Note that you can call this function
many times. Repetitive execution of the same program will execute the
ScriptBasic code again and again with the global variables keeping their values.
<P>
If you want to reset the global variables you have to call <a href="#3.3.55.">scriba_ResetVariables()</A>.
<P>
There is no way to keep the value of the local variables.
<P>
The argument <font size="3"><tt>pszCommandLineArgument</tt></font> is the command part that is passed to the
BASIC program.
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_Run(pSbProgram pProgram,
               char *pszCommandLineArgument
  )@{
</PRE></FONT>
The return value is zero in case of success or the error code returned by the underlying
execution layers.
<P>
Note that you can not call BASIC subroutines or functions without initializations that
<font size="3"><tt>scriba_Run</tt></font> performs. You also can not access global variables. Therefore you either have
to call <font size="3"><tt>scriba_Run</tt></font> or its brother <a href="#3.3.54.">scriba_NoRun()</A> that performs the initializations without execution.
<P>
You also have to call <a href="#3.3.54.">scriba_NoRun()</A> if you want to execute a program with some global variables
having preset values that you want to set from the embedding C program. In that case you
have to call <a href="#3.3.54.">scriba_NoRun()</A> then one or more times <a href="#3.3.65.">scriba_SetVariable()</A> and finally <font size="3"><tt>Run</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.54."><H3>3.3.54. scriba_NoRun()</H3></A>

In case the embedding program want to set global variables and
execute subroutines without or before starting the main program it has to call this
function first. It does all the initializations that are done by
<a href="#3.3.53.">scriba_Run()</A> except that it does not actually execute the program.
<P>
After calling this function the main program may access global variables
and call BASIC functions.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_NoRun(pSbProgram pProgram
  )@{
</PRE></FONT>
See also <a href="#3.3.53.">scriba_Run()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.55."><H3>3.3.55. scriba_ResetVariables()</H3></A>

Call this function if you want to execute a program object that was already executed
but you do not want the global variables to keep their value they had when
the last execution of the BASIC code finished.
<P>
Global variables in ScriptBasic are guaranteed to be <font size="3"><tt>undef</tt></font> before they get any other
value and some programs depend on this.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_ResetVariables(pSbProgram pProgram
  )@{
</PRE></FONT>
See also <a href="#3.3.65.">scriba_SetVariable()</A>, <a href="#3.3.53.">scriba_Run()</A>, <a href="#3.3.54.">scriba_NoRun()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.56."><H3>3.3.56. scriba_Call()</H3></A>

This function can be used to call a function or subroutine. This function does not
get any arguments and does not provide any return value.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_Call(pSbProgram pProgram,
                unsigned long lEntryNode
  )@{
</PRE></FONT>
The return value is zero or the error code returned by the interpreter.
<P>
<B>Note on how to get the Entry Node value:</B>
<P>
The argument <font size="3"><tt>lEntryNode</tt></font> should be the node index of the subroutine or function that
we want to execute. This can be retrieved using the function <a href="#3.3.61.">scriba_LookupFunctionByName()</A> if the
name of the function or subroutine is know. Another method is that the BASIC program
stored this value in some global variables. BASIC programs can access this information
calling the BASIC function <font size="3"><tt>Address( f() )</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.57."><H3>3.3.57. scriba_CallArg()</H3></A>

This function can be used to call a function or subroutine with arguments passed by value.
Neither the return value of the SUB nor the modified argument variables are not accessible 
via this function. <font size="3"><tt>CallArg</tt></font> is a simple interface to call a ScriptBasic subroutine or
function with argument.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_CallArg(pSbProgram pProgram,
                   unsigned long lEntryNode,
                   char *pszFormat, ...
  )@{
</PRE></FONT>
Arguments
<P>
<UL>
<LI> <font size="3"><tt>pProgram</tt></font> is the class variable.
<LI> <font size="3"><tt>lEntryNode</tt></font> is the start node of the SUB. (See <a href="#3.3.56.">scriba_Call()</A> note on how to get the entry node value.)
<LI> <font size="3"><tt>pszFormat</tt></font> is a format string that defines the rest of the areguments
@end itemize
<P>
The format string is case insensitive. The characters <font size="3"><tt>u</tt></font>, <font size="3"><tt>i</tt></font>, <font size="3"><tt>r</tt></font>, <font size="3"><tt>b</tt></font> and <font size="3"><tt>s</tt></font> have meaning.
All other characters are ignored. The format characters define the type of the arguments
from left to right.
<P>
<UL>
<LI> <font size="3"><tt>u</tt></font> means to pass an <font size="3"><tt>undef</tt></font> to the SUB. This format character is exceptional that it does not
consume any function argument.
<LI> <font size="3"><tt>i</tt></font> means that the next argument has to be <font size="3"><tt>long</tt></font> and it is passed to the BASIC SUB as an integer.
<LI> <font size="3"><tt>r</tt></font> means that the next argument has to be <font size="3"><tt>double</tt></font> and it is passed to the BASIC SUB as a real.
<LI> <font size="3"><tt>s</tt></font> means that the next argument has to be <font size="3"><tt>char *</tt></font> and it is passed to the BASIC SUB as a string.
<LI> <font size="3"><tt>b</tt></font> means that the next two arguments has to be <font size="3"><tt>long cbBuffer</tt></font> and <font size="3"><tt>unsigned char *Buffer</tt></font>.
The <font size="3"><tt>cbBuffer</tt></font> defines the length of the <font size="3"><tt>Buffer</tt></font>.
@end itemize
<P>
Note that this SUB calling function is a simple interface and has no access to the modified values of the argument
after the call or the return value.
<P>
If you need any of the functionalities that are not implemented in this function call a more sophisticated
function.
<P>
Example:
<FONT SIZE="3" COLOR="BLUE"><PRE>
<P>
  iErrorCode = scriba_CallArg(&amp;MyProgram,lEntry,"i i s d",13,22,"My string.",54.12);
<P>
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.58."><H3>3.3.58. scriba_DestroySbArgs()</H3></A>

This function can be used to release the memory used by arguments created by the
function <a href="#3.3.59.">scriba_NewSbArgs()</A>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_DestroySbArgs(pSbProgram pProgram,
                          pSbData Args,
                          unsigned long cArgs
  )@{
</PRE></FONT>
<P>
Arguments:
<UL>
<LI> <font size="3"><tt>pProgram</tt></font> class variable
<LI> <font size="3"><tt>Args</tt></font> pointer returned by <a href="#3.3.59.">scriba_NewSbArgs()</A>
<LI> <font size="3"><tt>cArgs</tt></font> the number of arguments pointed by <font size="3"><tt>Args</tt></font>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.59."><H3>3.3.59. scriba_NewSbArgs()</H3></A>

Whenever you want to handle the variable values that are returned by the scriba subroutine
you have to call <a href="#3.3.60.">scriba_CallArgEx()</A>. This function needs the arguments passed in an array of <font size="3"><tt>SbDtata</tt></font> type.
<P>
This function is a usefuly tool to convert C variables to an array of <font size="3"><tt>SbData</tt></font>
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
pSbData scriba_NewSbArgs(pSbProgram pProgram,
                         char *pszFormat, ...
  )@{
</PRE></FONT>
The arguments passed are 
<P>
<UL>
<LI> <font size="3"><tt>pProgram</tt></font> is the class variable
<LI> <font size="3"><tt>pszFormat</tt></font> is the format string
@end itemize
<P>
The format string is case insensitive. The characters <font size="3"><tt>u</tt></font>, <font size="3"><tt>i</tt></font>, <font size="3"><tt>r</tt></font>, <font size="3"><tt>b</tt></font> and <font size="3"><tt>s</tt></font> have meaning.
All other characters are ignored. The format characters define the type of the arguments
from left to right.
<P>
<UL>
<LI> <font size="3"><tt>u</tt></font> means to pass an <font size="3"><tt>undef</tt></font> to the SUB. This format character is exceptional that it does not
consume any function argument.
<LI> <font size="3"><tt>i</tt></font> means that the next argument has to be <font size="3"><tt>long</tt></font> and it is passed to the BASIC SUB as an integer.
<LI> <font size="3"><tt>r</tt></font> means that the next argument has to be <font size="3"><tt>double</tt></font> and it is passed to the BASIC SUB as a real.
<LI> <font size="3"><tt>s</tt></font> means that the next argument has to be <font size="3"><tt>char *</tt></font> and it is passed to the BASIC SUB as a string.
<LI> <font size="3"><tt>b</tt></font> means that the next two arguments has to be <font size="3"><tt>long cbBuffer</tt></font> and <font size="3"><tt>unsigned char *Buffer</tt></font>.
The <font size="3"><tt>cbBuffer</tt></font> defines the leng of the <font size="3"><tt>Buffer</tt></font>.
@end itemize
<P>
Example:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
<P>
pSbData MyArgs;
<P>

  MyArgs = scriba_NewSbArgs(pProgram,"i i r s b",13,14,3.14,"string",2,"two character string");
  if( MyArgs == NULL )error("memory alloc");
<P>
  scriba_CallArgEx(pProgram,lEntry,NULL,5,MyArgs);
<P>
</PRE></FONT>
<P>
This example passes five arguments to the ScriptBasic subroutine. Note that the last one is only
two character string, the rest of the characters are ignored.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.60."><H3>3.3.60. scriba_CallArgEx()</H3></A>

This is the most sophisticated function of the ones that call a ScriptBasic subroutine.
This function is capable handling parameters to scriba subroutines, and returning the
modified argument variables and the return value.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_CallArgEx(pSbProgram pProgram,
                     unsigned long lEntryNode,
                     pSbData ReturnValue,
                     unsigned long cArgs,
                     pSbData Args
  )@{
</PRE></FONT>
The arguments:
<UL>
<LI> <font size="3"><tt>pProgram</tt></font> is the program object pointer.
<LI> <font size="3"><tt>lEntryNode</tt></font> is the entry node index where the BASIC subroutine or function starts
      (See <a href="#3.3.56.">scriba_Call()</A> note on how to get the entry node value.)
<LI> <font size="3"><tt>ReturnValue</tt></font> is the return value of the function or subroutine
<LI> <font size="3"><tt>cArgs</tt></font> is the number of argments passed to the function
<LI> <font size="3"><tt>Args</tt></font> argument data array
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.61."><H3>3.3.61. scriba_LookupFunctionByName()</H3></A>

This function should be used to get the entry point of a function
knowing the name of the function. The entry point should not be treated as a
numerical value rather as a handle and to pass it to functions like
<a href="#3.3.60.">scriba_CallArgEx()</A>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long scriba_LookupFunctionByName(pSbProgram pProgram,
                                 char *pszFunctionName
  )@{
</PRE></FONT>
The return value of the function is the entry node index of the function named or
zero if the function is not present in the program.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.62."><H3>3.3.62. scriba_LookupVariableByName()</H3></A>

This function can be used to get the serial number of a global variable
knowing the name of the variable.
<P>
Note that all variables belong to a name space. Therefore if you want to
retrieve the global variable <font size="3"><tt>foo</tt></font> you have to name it <font size="3"><tt>main::foo</tt></font>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long scriba_LookupVariableByName(pSbProgram pProgram,
                                 char *pszVariableName
  )@{
</PRE></FONT>
The return value is the serial number of the global avriable or zero if
there is no variable with that name.
<P>
Note that the second argument, the name of the global variable, is not
going under the usual name space manipulation. You have to specify the
variable name together with the name space. For example the variable <font size="3"><tt>a</tt></font> will
not be found, but the variable <font size="3"><tt>main::a</tt></font> will be.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.63."><H3>3.3.63. scriba_GetVariableType()</H3></A>

Get the type of the value that a variable is currently holding. This
value can be
<P>
<UL>
<LI> <font size="3"><tt>SBT_UNDEF</tt></font>
<LI> <font size="3"><tt>SBT_DOUBLE</tt></font>
<LI> <font size="3"><tt>SBT_LONG</tt></font>
<LI> <font size="3"><tt>SBT_STRING</tt></font>
@end itemize
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
long scriba_GetVariableType(pSbProgram pProgram,
                            long lSerial
  )@{
</PRE></FONT>
The argument <font size="3"><tt>lSerial</tt></font> should be the serial number of 
the variable as returned by <a href="#3.3.62.">scriba_LookupVariableByName()</A>.
<P>
If there is no variable for the specified serian mumber (<font size="3"><tt>lSerial</tt></font> is not positive
or larger than the number of variables) the function returns <font size="3"><tt>SBT_UNDEF</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.64."><H3>3.3.64. scriba_GetVariable()</H3></A>

This function retrieves the value of a variable.
A new <font size="3"><tt>SbData</tt></font> object is created and the pointer to it
is returned in <font size="3"><tt>pVariable</tt></font>. This memory space is automatically
reclaimed when the program object is destroyed or the function
<font size="3"><tt>DestroySbData</tt></font> can be called.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_GetVariable(pSbProgram pProgram,
                       long lSerial,
                       pSbData *pVariable
  )@{
</PRE></FONT>
The argument <font size="3"><tt>lSerial</tt></font> should be the serial number of the global variable
as returned by <a href="#3.3.62.">scriba_LookupVariableByName()</A>.
<P>
The funtion returns <font size="3"><tt>SCRIBA_ERROR_SUCCESS</tt></font> on success,
<P>
<font size="3"><tt>SCRIBA_ERROR_MEMORY_LOW</tt></font> if the data cannot be created or
<P>
<font size="3"><tt>SCRIBA_ERROR_FAIL</tt></font> if the parameter <font size="3"><tt>lSerial</tt></font> is invalid.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.65."><H3>3.3.65. scriba_SetVariable()</H3></A>

This function sets the value of a global BASIC variable. You can call this function after
executing the program before it is reexecuted or after successfull call to <a href="#3.3.54.">scriba_NoRun()</A>.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int scriba_SetVariable(pSbProgram pProgram,
                       long lSerial,
                       int type,
                       long lSetValue,
                       double dSetValue,
                       char *pszSetValue,
                       unsigned long size
  )@{
</PRE></FONT>
The argument <font size="3"><tt>lSerial</tt></font> should be the serial number of the global variable
as returned by <a href="#3.3.62.">scriba_LookupVariableByName()</A>.
<P>
The argument <font size="3"><tt>type</tt></font> should be one of the followings:
<P>
<UL>
<LI> <font size="3"><tt>SBT_UNDEF</tt></font>
<LI> <font size="3"><tt>SBT_DOUBLE</tt></font>
<LI> <font size="3"><tt>SBT_LONG</tt></font>
<LI> <font size="3"><tt>SBT_STRING</tt></font>
<LI> <font size="3"><tt>SBT_ZCHAR</tt></font>
@end itemize
<P>
The function uses one of the arguments <font size="3"><tt>lSetValue</tt></font>, <font size="3"><tt>dSetValue</tt></font> or <font size="3"><tt>pszSetValue</tt></font> and
the other two are ignored based on the value of the argument <font size="3"><tt>type</tt></font>.
<P>
If the value of the argument <font size="3"><tt>type</tt></font> is <font size="3"><tt>SBT_UNDEF</tt></font> all initialization arguments are ignored and the
global variable will get the value <font size="3"><tt>undef</tt></font>.
<P>
If the value of the argument <font size="3"><tt>type</tt></font> is <font size="3"><tt>SBT_DOUBLE</tt></font> the argument <font size="3"><tt>dSetValue</tt></font> will be used and the global
variable will be double holding the value.
<P>
If the value of the argument <font size="3"><tt>type</tt></font> is <font size="3"><tt>SBT_LONG</tt></font> the argument <font size="3"><tt>lSetValue</tt></font> will be used and the global
variable will be long holding the value.
<P>
If the value of the argument <font size="3"><tt>type</tt></font> is <font size="3"><tt>SBT_STRING</tt></font> the argument <font size="3"><tt>pszSetValue</tt></font> 
will be used and the global variable will be long holding the value. The length of the string
should in this case be specified by the variable <font size="3"><tt>size</tt></font>.
<P>
If the value of the argument <font size="3"><tt>type</tt></font> is <font size="3"><tt>SBT_ZCHAR</tt></font> the argument <font size="3"><tt>pszSetValue</tt></font> 
will be used and the global variable will be long holding the value. The length of the string
is automatically calculated and the value passed in the variable <font size="3"><tt>size</tt></font> is ignored. In this case the
string <font size="3"><tt>pszSetValue</tt></font> should be zero character terminated.
<P>
The funtion returns <font size="3"><tt>SCRIBA_ERROR_SUCCESS</tt></font> on success,
<P>
<font size="3"><tt>SCRIBA_ERROR_MEMORY_LOW</tt></font> if the data cannot be created or
<P>
<font size="3"><tt>SCRIBA_ERROR_FAIL</tt></font> if the parameter <font size="3"><tt>lSerial</tt></font> is invalid. <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.66."><H3>3.3.66. scriba_InitStaticModules()</H3></A>

This function calls the initialization functions of the modules that are statically linked
into the interpreter. This is essential to call this fucntion from the embedding <font size="3"><tt>main()</tt></font> program
in a variation that has one or more external modules staticallyl linked. If this function is not
called the module initialization will not be called, because the module is never actually loaded and
thus the operating system does not call the <font size="3"><tt>DllMain</tt></font> or <font size="3"><tt>_init</tt></font> function.
<P>
The function has to be called before the first interpreter thread starts. In case of a single
thread variation this means that the function has to be called before the BASIC program starts.
<P>
The function does not take any argument and does not return any value.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_InitStaticModules(void
  )@{
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="3.3.67."><H3>3.3.67. scriba_FinishStaticModules()</H3></A>

This function calls the finalization functions of the modules that are statically linked
to the interpreter. Such a function for a dynamically loaded module is started by the operating
system. Because the sttaically linked modules are not loaded the <font size="3"><tt>_fini</tt></font> function is not called
by the UNIX loader and similarly the function <font size="3"><tt>DllMain</tt></font> is not called by Windows NT. Because some
modules depend on the execution of this function this function has to be called after the last
interpreter thread has finished.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void scriba_FinishStaticModules(void
  )@{
</PRE></FONT>
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4."><H1>4. Extension Modules</H1></A>

Extension modules are written usually using the language C and implement functions that can not be efficiently implemented in BASIC. These functions can be called from the BASIC programs just as if they were written in BASIC.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.1."><H2>4.1. How Extension Modules are Used</H2></A>

To write external modules it is a good practice to learn first how ScriptBasic uses the modules.
<P>
External functions and external commands in ScriptBasic are declared using the declare sub or declare command statements. An example of such a statement is
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
declare sub alma alias "trial" lib "ext_tial"
</PRE></FONT>
or
<FONT SIZE="3" COLOR="BLUE"><PRE>
declare command iff alias "iff" lib "ext_tial"
</PRE></FONT>
<P>
Following this declaration the function or the command can be used just as it were implemented in BASIC.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
call alma(1,2,3)
</PRE></FONT>
<P>
The difference between external functions and external commands is the way ScriptBasic handles the arguments passed to them. Both external functions and external commands are implemented as C functions in the extension module compiled into a DLL or shareable object. Both of them look like user defined functions in the BASIC source code.
<P>
The difference is that external functions are called after the actual arguments are evaluated, while external commands are called without evaluating the arguments. Because of this external functions and external commands are implemented in C functions that have different prototypes. There is a prototype for external functions and a different one for external commands. 
<P>
When ScriptBasic compiles this line the function or subroutine <font size="3"><tt>alma</tt></font> is defined just as a normal function or subroutine defined using the instructions of the basic language. Note that there are no differences other than syntax between subroutines and functions in ScriptBasic. When the program calls the function <font size="3"><tt>alma</tt></font> the ScriptBasic run-time system performs a function call to the basic function alma. In other words there is no difference from the caller point of view between the line above and the line:
<FONT SIZE="3" COLOR="BLUE"><PRE>
Sub alma(a,b)
End sub
</PRE></FONT>
<P>
The function call can be performed in two different ways. One way is when the function appears in an expression. The other way is when the function is called using the <font size="3"><tt>call</tt></font> statement. There is no difference between the two calling possibilities from the internal operation point of view of the interpreter. This is because <font size="3"><tt>CALL</tt></font> statement is implemented in a very simple way to simply evaluate the expression after the call statement and drop the result. 
<P>
The calling code does not evaluate the expressions passed to the function as arguments. This is usually the task of the functions. The functions get the node pointer to the expression list where the actual values for the arguments are and they can evaluate them.
<P>
The two different declarations <font size="3"><tt>declare sub</tt></font> and <font size="3"><tt>declare command</tt></font> differ in the way ScriptBasic interpreter handles the arguments. When an external function is declared using the command <font size="3"><tt>declare sub</tt></font> the arguments are evaluated by the interpreter before the function implemented in the external module is called. When an external command is declared using the command <font size="3"><tt>declare command</tt></font> the arguments are <I>NOT</I> evaluated by the ScriptBasic interpreter before calling the function implemented in the external module. In the latter case the external function has to decide if it wants certain arguments to be evaluated and can call the ScriptBasic function <font size="3"><tt>execute_Evaluate</tt></font> via the extension call-back table to evaluate the arguments. Also the prototype of a function declared using the statement <font size="3"><tt>declare command</tt></font> is different from the prototype of a function declared using the command <font size="3"><tt>declare sub</tt></font>.
<P>
When a function is implemented externally ScriptBasic sees a <font size="3"><tt>declare sub</tt></font> statement instead of a <font size="3"><tt>function</tt></font> or <font size="3"><tt>sub</tt></font> statement and starts to execute this statement calling the code implemented in the file `<font size="3"><tt>external.c</tt></font>' in the source directory `<font size="3"><tt>commands</tt></font>'.
<P>
The name of the example function is <font size="3"><tt>alma</tt></font> as declared in the statement above. However this is only a symbolic name that exists only during syntax analysis and is not available when the code is executed. The alias for the function is <font size="3"><tt>trial</tt></font>. This is the name of the function as it is implemented in the external module. When the interpreter executes this line the function name <font size="3"><tt>trial</tt></font> is used in the system call to locate the entry point. The module that contains the function is <font size="3"><tt>ext_trial</tt></font>. The actual file name is `<font size="3"><tt>ext_trial.dll</tt></font>' or `<font size="3"><tt>ext_trial.so</tt></font>' or some other name containing the given name and an extension specific to the operating system. During module load ScriptBasic automatically appends the appropriate extension as defined in the configuration file of ScriptBasic. (For further information on ScriptBasic configuration file syntax and location see the ScriptBasic Users' Guide!) ScriptBasic searches the module in the directories defined in the configuration file and tries to load it using absolute file name. This way the system specific search paths are not taken into account.
<P>
When function implemented in an external module is first called the interpreter checks if the module is loaded or not. If the module is not loaded the interpreter loads the module and calls module initialization functions. If the module was already loaded it locates the entry point of the function and calls the function.
<P>
During module load ScriptBasic appends the appropriate dynamic load library extension and tries to load the module from the directories defined in the configuration file. It takes the directories in the order they are specified in the configuration file and in case it can load the module from a directory listed it stops trying.
<P>

When the module is loaded ScriptBasic locates the function <font size="3"><tt>versmodu</tt></font> and calls it. The task of this function is to negotiate the interface version between the external module and ScriptBasic. The current interface version is defined in the file `<font size="3"><tt>basext.c</tt></font>' with the C macro <font size="3"><tt>INTERFACE_VERSION</tt></font>. ScriptBasic calls this function to tell the module what version ScriptBasic supports. The function can decide if the module can work with the indicated version and can answer: <I>yes it is OK, no it is not OK or yes, but I can support only version X.</I> This is a negotiation process that finally result some agreement or the module is abandoned if no agreement can be reached.
<P>
The function <font size="3"><tt>versmodu</tt></font> gets three arguments:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int versmodu(int Version, char *pszVariation, void **ppModuleInternal)
</PRE></FONT>
<P>
The first argument is the version of the interface. The second argument is the ZCHAR terminated 8-character string of the variation. This is STANDARD for the standard, stand alone, command line version of ScriptBasic. The <font size="3"><tt>ppModuleInternal</tt></font> pointer points to the module pointer initialized to <font size="3"><tt>NULL</tt></font>. This pointer is hardly ever used in this function, but its address is passed as a third argument in case some application needs it. The role of this pointer will be discussed later.
<P>
The function should check the parameters passed and return either zero in case it can not accept the interface or the highest interface it can handle. If this is the same as the version passed in the first argument the module should be accepted. If this is smaller than the interface version offered by ScriptBasic the interpreter can decide if it can support the older interface required by the module.
<P>
If the function <font size="3"><tt>versmodu</tt></font> returns a version larger than the version offered the interpreter will interpret this as a negotiation failure and will treat the module as not loaded.
<P>
If there is no function named <font size="3"><tt>versmodu</tt></font> in the library ScriptBasic crosses the fingers and hopes the best and assumes that the module will be able to work with the interface ScriptBasic offers. (should we change it to be configurable to disallow such modules?)
<P>
After the successful version negotiation the interpreter calls the function named <font size="3"><tt>bootmodu</tt></font>. This function gets four arguments.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
<P>
int bootmodu(pSupportTable pSt,
             void **ppModuleInternal, 
             pFixSizeMemoryObject pParameters,
             pFixSizeMemoryObject *pReturnValue)
</PRE></FONT>
<P>
The first parameter is a pointer to the interface structure. This interface structure can and should be used to communicate with ScriptBasic. The second parameter points to the module pointer. The last two parameters are NULL for this function. The reason to pass two NULL pointers is that this is the prototype of each function callable by ScriptBasic implemented in the module. The last two parameters point to the parameters of the function and to the left value where the function value is to be returned. <font size="3"><tt>bootmodu</tt></font> actually does not get any parameter and should not pass any value back.
<P>
This function can be used to initialize the module, to allocate memory for the common storage if the functions implemented in the module keep some state information. If there is no function named <font size="3"><tt>bootmodu</tt></font> in the library file ScriptBasic assumes that the module does not need initialization. If the function <font size="3"><tt>bootmodu</tt></font> exists it should return zero indicating success or an error code. If an error code is returned the module is treated as failed. And an error is raised. (Errors can be captured using the BASIC <font size="3"><tt>ON ERROR GOTO</tt></font> command.
<P>
When this function returns the ScriptBasic interpreter evaluates the arguments and performs a call to the function named trial in our example.
<P>
When the program has finished the interpreter tries to locate the function <font size="3"><tt>finimodu</tt></font> in the module. This function may exist and should have the same prototype as any other function (except <font size="3"><tt>versmodu</tt></font>):
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int finimodu(pSupportTable pSt,
             void **ppModuleInternal,
             pFixSizeMemoryObject pParameters,
             pFixSizeMemoryObject *pReturnValue)
</PRE></FONT>
<P>
This function can be used to perform clean-up tasks. The interpreter may call the <font size="3"><tt>finimodu</tt></font> functions of different modules in different threads asynchronously. (However it does not currently.)
<P>
Note that there is no need to release the allocated memory in case the module allocates memory using the memory allocation methods provided by the interface. Other resources may need release; for example files may need closing.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.2."><H2>4.2. A Simple Sample Module</H2></A>

After you have got a slight overview how ScriptBasic handles the modules get a jump-start looking at the simplest sample module <font size="3"><tt>trial.c</tt></font>!
<P>
This module was the very first module the developers wrote to test the module handling functionality of ScriptBasic. This does almost nothing, but prints out some trace messages so that you can see how the different functions are called in the module. There is only one function in this module that the basic code can call. This is trial. This function increments a long value and returns the actual value of this state variable.
<P>
Here is the whole code:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
#include &lt;stdio.h&gt;
<P>
#include "../../basext.h"
<P>
besVERSION_NEGOTIATE
<P>
  printf("The function bootmodu was started and the requested version is %d\n",Version);
  printf("The variation is: %s\n",pszVariation);
  printf("We are returning accepted version %d\n",(int)INTERFACE_VERSION);
<P>
  return (int)INTERFACE_VERSION;
<P>
besEND
<P>
besSUB_START
  long *pL;
<P>
  besMODULEPOINTER = besALLOC(sizeof(long));
  if( besMODULEPOINTER == NULL )return 0;
  pL = (long *)besMODULEPOINTER;
  *pL = 0L;
<P>
  printf("The function bootmodu was started.\n");
<P>
besEND
<P>

besSUB_FINISH
  printf("The function finimodu was started.\n");
besEND
<P>
besFUNCTION(trial)
<P>
  long *pL;
<P>
  printf("Function trial was started...\n");
  pL = (long *)besMODULEPOINTER;
  (*pL)++;
  besRETURNVALUE = besNEWMORTALLONG;
  LONGVALUE(besRETURNVALUE) = *pL;
<P>
  printf("Module directory is %s\n",besCONFIG("module"));
  printf("dll extension is %s\n",besCONFIG("dll"));
  printf("include directory is %s\n",besCONFIG("include"));
<P>
besEND
<P>
besCOMMAND(iff)
  NODE nItem;
  VARIABLE Op1;
  long ConditionValue;
<P>

  USE_CALLER_MORTALS;
<P>
  /* evaluate the parameter */
  nItem = besPARAMETERLIST;
  if( ! nItem ){
    RESULT = NULL;
    RETURN;
    }
  Op1 = besEVALUATEEXPRESSION(CAR(nItem));
  ASSERTOKE;
<P>
  if( Op1 == NULL )ConditionValue = 0;
  else{
    Op1 = besCONVERT2LONG(Op1);
    ConditionValue = LONGVALUE(Op1);
    }
<P>
  if( ! ConditionValue )
    nItem = CDR(nItem);
<P>
  if( ! nItem ){
    RESULT = NULL;
    RETURN;
    }
  nItem = CDR(nItem);
<P>
  RESULT = besEVALUATEEXPRESSION(CAR(nItem));
  ASSERTOKE;
  
  RETURN;
besEND_COMMAND
</PRE></FONT>
<P>

<P>
As you can see there is a lot of code hidden behind the macros. You can not see <font size="3"><tt>versmodu</tt></font>, <font size="3"><tt>bootmodu</tt></font> or <font size="3"><tt>finimodu</tt></font>, because they are implemented using the macro <font size="3"><tt>besVERSION_NEGOTIATE</tt></font>, <font size="3"><tt>besSUB_START</tt></font> and <font size="3"><tt>bes_SUB_FINISH</tt></font>. These macros are provided in the header file `<font size="3"><tt>basext.h</tt></font>', along with other type definitions and include statements that are needed to compile a module. To have a deeper understanding feel free to have a look at the file `<font size="3"><tt>basext.c</tt></font>' containing the source for <font size="3"><tt>basext.h</tt></font>.
<P>
All the macros defined in the header file for the extensions start with the three letters <font size="3"><tt>bes</tt></font>. These stand for <font size="3"><tt>b</tt></font>asic <font size="3"><tt>e</tt></font>xtension <font size="3"><tt>s</tt></font>upport.
<P>
The version negotiation function prototype and function start is created using the macro <font size="3"><tt>besVERSION_NEGOTIATE</tt></font>. This macro generates the function head with the parameters named <font size="3"><tt>Version</tt></font>, <font size="3"><tt>pszVariation</tt></font> and <font size="3"><tt>ppModuleInternal</tt></font>. The accepted version is returned using the macro <font size="3"><tt>INTERFACE_VERSION</tt></font>. The reason to use this macro is to ease maintainability.
<P>
The current version of the interface is 10 (or more). Later interfaces may probably support more callback interface functions, but it is unlikely that the interfaces become incompatible on the source level. When the module is recompiled in an environment that uses a newer interface it will automatically return the interface version that it really supports. If the interfaces become incompatible in source level the compilation phase will most probably fail.
<P>
The <font size="3"><tt>bootmodu</tt></font> function is created using the macro <font size="3"><tt>besSUB_START</tt></font>. In this example this allocates a state variable, which is a long. The memory allocation is performed using a callback function and with the aid of the macro <font size="3"><tt>besALLOC</tt></font>.
<P>
Here we can stop a bit and examine, how the callback functions work. The ScriptBasic interpreter has several functions that are available for the extensions. To access these functions the module should know the entry point (address) of the functions. To get the entry points ScriptBasic creates a table of the callback functions. A pointer to this table is passed as the first argument to each module function except the version negotiation function <font size="3"><tt>versmodu</tt></font>. In C syntax this table is a <font size="3"><tt>struct</tt></font> named <font size="3"><tt>SupportTable</tt></font>.
<P>
There are numerous functions that an extension can and should use to communicate with ScriptBasic. One of the most important functions is memory allocation. The field of the <font size="3"><tt>SupportTable</tt></font> named <font size="3"><tt>Alloc</tt></font> is initialized to point to the function <font size="3"><tt>alloc_Alloc</tt></font> defined in the file `<font size="3"><tt>myalloc.c</tt></font>'. This allocation function needs the size of the needed memory block and a pointer to a so-called memory segment. The memory segment pointer to be used is available via the <font size="3"><tt>SupportTable</tt></font>. The first member of the table is a pointer to another table containing the current interpreter execution environment. This environment is also a &amp;code{struct} and contains the memory segment pointer.
<P>
This is a bit complicated and you can get confused. To ease coding use the macros available. These will hide all these nifty details. However know that these macros assume that you use them together. In other words <font size="3"><tt>besALLOC</tt></font> can only be used in a function when the function head was created using the macro <font size="3"><tt>besFUNCTION</tt></font> (or <font size="3"><tt>besSUB_START</tt></font> or <font size="3"><tt>besSUB_FINISH</tt></font> in case of <font size="3"><tt>bootmodu</tt></font> and <font size="3"><tt>finimodu</tt></font>). This is because the macros assume certain variable names in the arguments.
<P>
The function <font size="3"><tt>finimodu</tt></font> is created using the macro <font size="3"><tt>besSUB_FINISH</tt></font>. This function in this example does nothing but prints a test message. There is no need to release the memory allocated using <font size="3"><tt>besALLOC</tt></font>, because the memory is administered to belong to the segment of the interpreter execution environment and is released by the interpreter before the exits.
<P>
The real function of the module is named trial and is defined using the macro <font size="3"><tt>besFUNCTION</tt></font>. It gets the state variable via the module pointer. The module pointer is always passed to the module functions as the second argument. The functions can access it using the macro <font size="3"><tt>besMODULEPOINTER</tt></font>. Using this macro it looks like a local variable.
<P>

To return the counter value the function needs a basic variable. This variable should hold a long value and should be mortal. This is created using the macro <font size="3"><tt>besNEWMORTALLONG</tt></font>. The variable is actually a <font size="3"><tt>struct</tt></font> and the field containing the long value can be accessed using the macro <font size="3"><tt>LONGVALUE</tt></font>.
<P>

<P>
You can notice that this macro does not start with the letters <font size="3"><tt>bes</tt></font>. The reason is that this macro comes from a different header file `<font size="3"><tt>command.h</tt></font>'. This header file is included by `<font size="3"><tt>basext.h</tt></font>' and the definitions in that file are mainly for implementing internal commands linked statically. However some of the macros can be used for dynamic modules as well.
<P>
The function trial finally writes out some configuration data. On one hand this is another example of a callback function used via a macro named <font size="3"><tt>besCONFIG</tt></font>. But this is more important than that. This shows you that the modules can access any configuration data. 
<P>
There is no need for any module to process separate configuration files. ScriptBasic reads the configuration file and stores each key and value pair it finds. It stores even those that do not mean anything for ScriptBasic itself, because they may be meaningful and needed by modules. The example module trial does not have its own data, therefore we print out the configuration data that ScriptBasic surely has.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.3."><H2>4.3. Compiling a Module</H2></A>

Compiling a module is easy and straightforward. Just do it as you would do for any dynamic load library. On Linux you have to compile the source code to object file, saying
<FONT SIZE="3" COLOR="BLUE"><PRE>
cc -c -o trial.o trial.c
ld -d -warn-section-align -sort-comon -shared -o trial.so trial.o
</PRE></FONT>
assuming that the name of the file to compile is `<font size="3"><tt>trial.c</tt></font>'. On other Unix operating systems you have to issue similar commands.
<P>
On Windows NT you can use Visual C++ and create an empty project using the work space wizard to create a new dll file. You have to add your source code to the project, select release version and compile the program.
<P>
Note that Windows NT dll files do not automatically export each non-static function of a program. They have to be declared in a DEF file or the functions should be denoted with a special type casting keyword. If you use the predefined macros available including the file `<font size="3"><tt>basext.h</tt></font>' your functions will be exported without creating a def file.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.4."><H2>4.4. Installing a Module</H2></A>

A module is usually composed of two files. One file is the binary library module with the extension <font size="3"><tt>.dll</tt></font> under Windows NT or <font size="3"><tt>.so</tt></font> under Unix. The other file is an include file, which contains the declare sub statement for each external function.
<P>
To install a module you have to copy or move the module binary to one of the directories specified in the configuration file as ScriptBasic module directory and you have to copy or move the include file into one of the directories specified in the configuration file as ScriptBasic include directory.
<P>
The basic program that uses the module includes the include file and it is ready to call the functions declared in that file. Currently there are no install programs available that place the file at the appropriate locations.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5."><H2>4.5. Module Support Functions</H2></A>

Module support functions and macros are to ease the life of the extension programmers. They are defined in the file `<font size="3"><tt>basext.c</tt></font>' and in the file `<font size="3"><tt>basext.h</tt></font>' generated from `<font size="3"><tt>basext.c</tt></font>' using the tool `<font size="3"><tt>headerer.pl</tt></font>'.
<P>
It is highly recommended that the extensions use these functions and that the extensions use the macros to call the functions the way the documentation suggests. The reason for this is to create readable code and to provide maintainability.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.1."><H3>4.5.1. Basic Extension Support functions, structures and macros</H3></A>
<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.2."><H3>4.5.2. besALLOC(X)</H3></A>

Use this macro to allocate memory in an extension like you would use
<font size="3"><tt>malloc</tt></font> in a normal, old fashioned C program. The argument is the size of the memory in
byte count to be allocated. The result is the pointer to the allocated memory or <font size="3"><tt>NULL</tt></font> if there
is not enough memory available.
<P>
The allocated memory is assigned to the memory segment of the execution thread and thus this memory
is released automatically when the module is unloaded from the interpreter. In other words if
a module uses <font size="3"><tt>besALLOC</tt></font> to allocate memory there is no need to call <a href="#4.5.4.">besFREE(X)</A>.
<P>
Modules written for multi-thread variations of ScriptBasic should also be aware of the fact that
the memory allocated by this macro is released whent he calling interpreter thread finishes.
<P>
This macro calls the function <a href="#2.8.1.7.">alloc_Alloc()</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.3."><H3>4.5.3. besPROCALLOC(X)</H3></A>

Use this macro in multi-thread supporting modules to allocate memory that is
not freed when the actual interpreter finishes but stays in memory so long
as long the process is alive.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.4."><H3>4.5.4. besFREE(X)</H3></A>

Use this macro to release memory that was allocated by <a href="#4.5.2.">besALLOC(X)</A>.
<P>
Altough all memory allocated by <a href="#4.5.2.">besALLOC()</A> is automatically released when the
interpreter thread calling <a href="#4.5.2.">besALLOC()</A> finishes it is advised to release all
memory chunks, especially large onces when they are not needed anymore.
<P>
This macro also <font size="3"><tt>NULL</tt></font>ifies the argument.
<P>
This macro calls the function <a href="#2.8.1.8.">alloc_Free()</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.5."><H3>4.5.5. besPROCFREE(X)</H3></A>

This is the counterpart of <a href="#4.5.3.">besPROCALLOC</A> releasing memory allocated
for process life time.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.6."><H3>4.5.6. besPROCMEMORYSEGMENT</H3></A>

Use this macro in case you need to pass the process level memory
segment to a function.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.7."><H3>4.5.7. besNEWMORTALSTRING(X)</H3></A>

Create a new mortal string and return a pointer to it. The argument should be the
number of characters in the string.
This macro calls the function <a href="#2.9.1.31.">memory_NewMortalString()</A>.
<P>
See also 
<UL>
<LI> <a href="#4.5.7.">besNEWMORTALSTRING</A>
<LI> <a href="#4.5.8.">besNEWMORTALLONG</A>
<LI> <a href="#4.5.9.">besNEWMORTALREF</A>
<LI> <a href="#4.5.10.">besNEWMORTALDOUBLE</A>
<LI> <a href="#4.5.11.">besNEWMORTALARRAY</A>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.8."><H3>4.5.8. besNEWMORTALLONG</H3></A>

Create a new mortal <font size="3"><tt>long</tt></font> and return the pointer to it.
This macro calls the function <a href="#2.9.1.33.">memory_NewMortalLong()</A>.
<P>
See also 
<UL>
<LI> <a href="#4.5.7.">besNEWMORTALSTRING</A>
<LI> <a href="#4.5.8.">besNEWMORTALLONG</A>
<LI> <a href="#4.5.9.">besNEWMORTALREF</A>
<LI> <a href="#4.5.10.">besNEWMORTALDOUBLE</A>
<LI> <a href="#4.5.11.">besNEWMORTALARRAY</A>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.9."><H3>4.5.9. besNEWMORTALREF</H3></A>

Create a new mortal reference and return the pointer to it.
This macro calls the function <a href="#2.9.1.34.">memory_NewMortalRef()</A>.
<P>
See also 
<UL>
<LI> <a href="#4.5.7.">besNEWMORTALSTRING</A>
<LI> <a href="#4.5.8.">besNEWMORTALLONG</A>
<LI> <a href="#4.5.9.">besNEWMORTALREF</A>
<LI> <a href="#4.5.10.">besNEWMORTALDOUBLE</A>
<LI> <a href="#4.5.11.">besNEWMORTALARRAY</A>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.10."><H3>4.5.10. besNEWMORTALDOUBLE</H3></A>

Create a new mortal <font size="3"><tt>double</tt></font> and return the pointer to it.
This macro calls the function <a href="#2.9.1.35.">memory_NewMortalDouble()</A>.
<P>
See also 
<UL>
<LI> <a href="#4.5.7.">besNEWMORTALSTRING</A>
<LI> <a href="#4.5.8.">besNEWMORTALLONG</A>
<LI> <a href="#4.5.9.">besNEWMORTALREF</A>
<LI> <a href="#4.5.10.">besNEWMORTALDOUBLE</A>
<LI> <a href="#4.5.11.">besNEWMORTALARRAY</A>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.11."><H3>4.5.11. besNEWMORTALARRAY(X,Y)</H3></A>

Create a new mortal array and return the pointer to it. The arguments define the array
low index and the array high index. This macro calls the function <a href="#2.9.1.36.">memory_NewMortalArray()</A>.
<P>
See also 
<UL>
<LI> <a href="#4.5.7.">besNEWMORTALSTRING</A>
<LI> <a href="#4.5.8.">besNEWMORTALLONG</A>
<LI> <a href="#4.5.9.">besNEWMORTALREF</A>
<LI> <a href="#4.5.10.">besNEWMORTALDOUBLE</A>
<LI> <a href="#4.5.11.">besNEWMORTALARRAY</A>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.12."><H3>4.5.12. besNEWSTRING(X)</H3></A>

Create a new string and return the pointer to it. The argument defines the number
of bytes in the string. This macro calls the function <a href="#2.9.1.7.">memory_NewString()</A>.
<P>
See also 
<UL>
<LI> <a href="#4.5.12.">besNEWSTRING</A>
<LI> <a href="#4.5.13.">besNEWLONG</A>
<LI> <a href="#4.5.14.">besNEWREF</A>
<LI> <a href="#4.5.15.">besNEWDOUBLE</A>
<LI> <a href="#4.5.16.">besNEWARRAY</A>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.13."><H3>4.5.13. besNEWLONG</H3></A>

Create a new <font size="3"><tt>long</tt></font> and return the pointer to it. This macro calls the function
<a href="#2.9.1.16.">memory_NewLong()</A>.
<P>
See also 
<UL>
<LI> <a href="#4.5.12.">besNEWSTRING</A>
<LI> <a href="#4.5.13.">besNEWLONG</A>
<LI> <a href="#4.5.14.">besNEWREF</A>
<LI> <a href="#4.5.15.">besNEWDOUBLE</A>
<LI> <a href="#4.5.16.">besNEWARRAY</A>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.14."><H3>4.5.14. besNEWREF</H3></A>

Create a new reference variable and return the pointer to it. This macro calls the function
<a href="#2.9.1.10.">memory_NewRef()</A>.
<P>
See also 
<UL>
<LI> <a href="#4.5.12.">besNEWSTRING</A>
<LI> <a href="#4.5.13.">besNEWLONG</A>
<LI> <a href="#4.5.14.">besNEWREF</A>
<LI> <a href="#4.5.15.">besNEWDOUBLE</A>
<LI> <a href="#4.5.16.">besNEWARRAY</A>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.15."><H3>4.5.15. besNEWDOUBLE</H3></A>

Create a new <font size="3"><tt>double</tt></font> and return the pointer to it. This macro calls the function
<a href="#2.9.1.17.">memory_NewDouble()</A>.
<P>
See also 
<UL>
<LI> <a href="#4.5.12.">besNEWSTRING</A>
<LI> <a href="#4.5.13.">besNEWLONG</A>
<LI> <a href="#4.5.14.">besNEWREF</A>
<LI> <a href="#4.5.15.">besNEWDOUBLE</A>
<LI> <a href="#4.5.16.">besNEWARRAY</A>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.16."><H3>4.5.16. besNEWARRAY(X,Y)</H3></A>

Create a new array and return the pointer to it. The arguments define the array
low index and the array high index. This macro calls the function <a href="#2.9.1.19.">memory_NewArray()</A>.
<P>
See also 
<UL>
<LI> <a href="#4.5.12.">besNEWSTRING</A>
<LI> <a href="#4.5.13.">besNEWLONG</A>
<LI> <a href="#4.5.14.">besNEWREF</A>
<LI> <a href="#4.5.15.">besNEWDOUBLE</A>
<LI> <a href="#4.5.16.">besNEWARRAY</A>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.17."><H3>4.5.17. besRELEASE(X)</H3></A>

Use this macro to release a non-mortal variable. This macro calls the function
<a href="#2.9.1.6.">memory_ReleaseVariable()</A> with the appropriate memory segment arguments.
<P>
See also 
<UL>
<LI> <a href="#4.5.12.">besNEWSTRING</A>
<LI> <a href="#4.5.13.">besNEWLONG</A>
<LI> <a href="#4.5.14.">besNEWREF</A>
<LI> <a href="#4.5.15.">besNEWDOUBLE</A>
<LI> <a href="#4.5.16.">besNEWARRAY</A>
@end itemize<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.18."><H3>4.5.18. besSETREF(VAR,VAL)</H3></A>

Use this macro in external modules to set the value of a variable to a reference to another variable.
The argument <font size="3"><tt>VAR</tt></font> is the variable and the argument <font size="3"><tt>VAL</tt></font> is the variable to be referenced.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.19."><H3>4.5.19. besCONFIG(X)</H3></A>

Get a configuration value that is supposed to be a string. This macro uses the
configuration of the callign interpreter thread and it calls the function
<a href="#2.7.1.7.">cft_GetString</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.20."><H3>4.5.20. besCONFIGFINDNODE(X,Y,Z)</H3></A>
This macro calls the function <a href="#2.7.1.5.">cft_FindNode</A>. Use this macro for sophisticated
configuration handling that needs configuration key enumeration.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.21."><H3>4.5.21. besCONFIGEX(CT,CS,NS,CSS,LS,DS,IS)</H3></A>

This macro calls the function <a href="#2.7.1.6.">cft_GetEx</A>. Use this macro to retrieve
configuration information that is not a string or the type is not known.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.22."><H3>4.5.22. besCONFIGENUMFIRST(X,Y)</H3></A>

This macro calls the function <a href="#2.7.1.8.">cft_EnumFirst</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.23."><H3>4.5.23. besCONFIGENUMNEXT(X,Y)</H3></A>

This macro calls the function <a href="#2.7.1.9.">cft_EnumNext</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.24."><H3>4.5.24. besCONFIGGETKEY(X,Y)</H3></A>

This macro calls the function <a href="#2.7.1.10.">cft_GetKey</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.25."><H3>4.5.25. besNEWSYMBOLTABLE</H3></A>

This macro allocates a new symbol table and returns the handle pointer to it. This
macro calls the function <a href="#2.20.1.">sym_NewSymbolTable</A>. The allocation function and the memory
segment used to allocate the symbol table is the default one that is used by the interpreter.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.26."><H3>4.5.26. besFREESYMBOLTABLE(X)</H3></A>

This macro releases a symbol table calling the function <a href="#2.20.2.">sym_FreeSymbolTable</A>.
The allocation function and the memory segment used to allocate the symbol table
is the default one that is used by the interpreter.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.27."><H3>4.5.27. besTRAVERSESYMBOLTABLE(X,Y,Z)</H3></A>

This macro calls the function <a href="#2.20.3.">sym_TraverseSymbolTable</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.28."><H3>4.5.28. besLOOKUPSYMBOL(X,Y,Z)</H3></A>

This macro calls the function <a href="#2.20.4.">sym_LookupSymbol</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.29."><H3>4.5.29. besDeleteSymbol(X,Y,Z)</H3></A>

This macro calls the function <a href="#2.20.5.">sym_DeleteSymbol</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.30."><H3>4.5.30. besLOADLIBRARY(X)</H3></A>

This macro calls the function <a href="#2.15.1.">dynlolib_LoadLibrary()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.31."><H3>4.5.31. besFREELIBRARY(X)</H3></A>

This macro calls the function <a href="#2.15.2.">dynlolib_FreeLibrary()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.32."><H3>4.5.32. besGETFUNCTIONBYNAME(X)</H3></A>

This macro calls the function <a href="#2.15.3.">dynlolib_GetFunctionByName()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.33."><H3>4.5.33. besFOPEN</H3></A>

This macro calls the function <a href="#2.16.1.">file_fopen</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.34."><H3>4.5.34. besFCLOSE</H3></A>

This macro calls the function <a href="#2.16.2.">file_fclose</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.35."><H3>4.5.35. besSIZE</H3></A>

This macro calls the function <a href="#2.16.3.">file_size</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.36."><H3>4.5.36. besTIME_ACCESSED</H3></A>

This macro calls the function <a href="#2.16.4.">file_time_accessed</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.37."><H3>4.5.37. besTIME_MODIFIED</H3></A>

This macro calls the function <a href="#2.16.5.">file_time_modified</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.38."><H3>4.5.38. besTIME_CREATED</H3></A>

This macro calls the function <a href="#2.16.6.">file_time_created</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.39."><H3>4.5.39. besISDIR</H3></A>

This macro calls the function <a href="#2.16.7.">file_isdir</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.40."><H3>4.5.40. besISREG</H3></A>

This macro calls the function <a href="#2.16.8.">file_isreg</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.41."><H3>4.5.41. besEXISTS</H3></A>

This macro calls the function <a href="#">file_fileexists</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.42."><H3>4.5.42. besTRUNCATE</H3></A>

This macro calls the function <a href="#2.16.10.">file_truncate</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.43."><H3>4.5.43. besFGETC</H3></A>

This macro calls the function <a href="#2.16.11.">file_fgetc</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.44."><H3>4.5.44. besFREAD</H3></A>

This macro calls the function <a href="#2.16.13.">file_fread</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.45."><H3>4.5.45. besFWRITE</H3></A>

This macro calls the function <a href="#2.16.14.">file_fwrite</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.46."><H3>4.5.46. besSETMODE</H3></A>

This macro calls the function <a href="#2.16.16.">file_setmode</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.47."><H3>4.5.47. besBINMODE</H3></A>

This macro calls the function <a href="#2.16.17.">file_binmode</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.48."><H3>4.5.48. besTEXTMODE</H3></A>

This macro calls the function <a href="#2.16.18.">file_textmode</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.49."><H3>4.5.49. besFERROR</H3></A>

This macro calls the function <a href="#2.16.12.">file_ferror</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.50."><H3>4.5.50. besFPUTC</H3></A>

This macro calls the function <a href="#2.16.15.">file_fputc</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.51."><H3>4.5.51. besFLOCK</H3></A>

This macro calls the function <a href="#2.16.19.">file_flock</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.52."><H3>4.5.52. besLOCK</H3></A>

This macro calls the function <a href="#2.16.20.">file_lock</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.53."><H3>4.5.53. besFEOF</H3></A>

This macro calls the function <a href="#2.16.21.">file_feof</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.54."><H3>4.5.54. besMKDIR</H3></A>

This macro calls the function <a href="#2.16.22.">file_mkdir</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.55."><H3>4.5.55. besRMDIR</H3></A>

This macro calls the function <a href="#2.16.23.">file_rmdir</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.56."><H3>4.5.56. besREMOVE</H3></A>

This macro calls the function <a href="#2.16.24.">file_remove</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.57."><H3>4.5.57. besDELTREE</H3></A>

This macro calls the function <a href="#2.16.25.">file_deltree</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.58."><H3>4.5.58. besMAKEDIRECTORY</H3></A>

This macro calls the function <a href="#2.16.26.">file_MakeDirectory</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.59."><H3>4.5.59. besOPENDIR</H3></A>

This macro calls the function <a href="#2.16.27.">file_opendir</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.60."><H3>4.5.60. besREADDIR</H3></A>

This macro calls the function <a href="#2.16.28.">file_readdir</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.61."><H3>4.5.61. besCLOSEDIR</H3></A>

This macro calls the function <a href="#2.16.29.">file_closedir</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.62."><H3>4.5.62. besOPTION(X)</H3></A>
Get the <font size="3"><tt>long</tt></font> value of the option <font size="3"><tt>X</tt></font>. This macro calls the function
<a href="#2.18.3.">options_Get</A>. The macro uses the default execution context.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.63."><H3>4.5.63. besSETOPTION(x,y)</H3></A>
Set the <font size="3"><tt>y</tt></font> <font size="3"><tt>long</tt></font> value of the option <font size="3"><tt>x</tt></font>. This macro calls the function
<a href="#2.18.2.">options_Set</A>. The macro uses the default execution context.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.64."><H3>4.5.64. besRESETOPTION(X)</H3></A>
Reset the option <font size="3"><tt>X</tt></font>. This macro calls the function <a href="#2.18.1.">options_Reset</A>.
The macro uses the default execution context.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.65."><H3>4.5.65. besCONVERT2STRING(x)</H3></A>

Use this macro to convert a mortal <font size="3"><tt>VARIABLE</tt></font> to string. The macro calls the
function <a href="#2.6.4.16.">execute_Convert2String</A> and uses the global mortal list.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.66."><H3>4.5.66. besCONVERT2LONG(x)</H3></A>
Use this macro to convert a mortal <font size="3"><tt>VARIABLE</tt></font> to <font size="3"><tt>long</tt></font>. The macro calls the
function <a href="#2.6.4.17.">execute_Convert2Long</A> and uses the global mortal list.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.67."><H3>4.5.67. besGETLONGVALUE(x)</H3></A>
Use this macro to get the long value of a variable. This macro is not the same as <font size="3"><tt>LONGVALUE</tt></font>.
The macro <font size="3"><tt>LONGVALUE</tt></font> simply accesses the long value of a variable and thus can also be used
as a left value assigning value to. On the other hand <font size="3"><tt>besGETLONGVALUE</tt></font> is a function call that
returns a long value when the argumentum variable is <font size="3"><tt>NULL</tt></font>, <font size="3"><tt>double</tt></font>, string or some other value.
In such situation using <font size="3"><tt>LONGVALUE</tt></font> would be erroneous.
<P>
The macro <font size="3"><tt>LONGVALUE</tt></font> should be used to access the long value of a variable that is known to
hold a long value or when the long value of a variable is to be set.
<P>
The macro <font size="3"><tt>besGETLONGVALUE</tt></font> has to be used in a situation when we want to use a variable
for its value being long. It is faster and consumes less memory than converting the variable to
long allocating a new mortal just to access the long value of the new mortal using <font size="3"><tt>LONGVALUE</tt></font>.
<P>
The same statements hold for <font size="3"><tt>DOUBLEVALUE</tt></font> and <a href="#4.5.69.">besGETDOUBLEVALUE</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.68."><H3>4.5.68. besCONVERT2DOUBLE(x)</H3></A>
Use this macro to convert a mortal <font size="3"><tt>VARIABLE</tt></font> to <font size="3"><tt>double</tt></font>. The macro calls the
function <a href="#2.6.4.19.">execute_Convert2Double</A> and uses the global mortal list.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.69."><H3>4.5.69. besGETDOUBLEVALUE(x)</H3></A>
Use this macro to get the double value of a variable.
<P>
For comparision of <font size="3"><tt>DOUBLEVALUE</tt></font> and this macro see the explanation in <a href="#4.5.67.">besGETLONGVALUE</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.70."><H3>4.5.70. besISSTRINGINTEGER(x)</H3></A>

Use this macro to decide if a string contains caharacters copnvertible to an
integer value. This macro calls the function <a href="#2.6.4.26.">execute_IsStringInteger</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.71."><H3>4.5.71. besCONVERT2ZCHAR(x)</H3></A>

Use this macro to convert a <font size="3"><tt>VARIABLE</tt></font> that is already STRING type to zero character
terminated string. This is needed many times when a BASIC string has to be passed to
operating system functions.
<P>
The macro argument <font size="3"><tt>x</tt></font> is converted to zero character terminated string and the
result will be pointed by <font size="3"><tt>y</tt></font>. <font size="3"><tt>y</tt></font> has to be a <font size="3"><tt>(char *)</tt></font> C variable.
<P>
If there is not enough memory the macro returns from the function with the error code
<font size="3"><tt>COMMAND_ERROR_MEMORY_LOW</tt></font> thus there is no need to check the value of the variable <font size="3"><tt>y</tt></font>
if it is <font size="3"><tt>NULL</tt></font>.
<P>
The memory allocated to store the ZCHAR string should be released by the macro <a href="#4.5.4.">besFREE</A>.
<P>
Note that the macro does not check wheter the string already contains a zero character or not.
It simply allocates a buffer that has length n+1 bytes to store the n bytes of the original
BASIC string and an extra zero character.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.72."><H3>4.5.72. besREINITINTERFACE</H3></A>

This macro calls the function <a href="#2.17.1.">modu_Init</A> to reset the module interface to
point to the original functions.
<P>
External modules are allowed to alter the support function table implementing their
own functions and thus altering the behavior of other extensions. These extensions
usually set some of the entries of the support function table to point to functions
implemented in the external module. However these functions are available only so long
as long the extension is in memory. When the extension is exiting the pointers should
be restored. Otherwise it may happen that the extension is already unloaded and the function
is used by another module exiting later.
<P>
Because there is no guaranteed order of extension module unload the modules should call
this function to restore the support function table and should not rely on altered
function calls during module exit code is executed.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.73."><H3>4.5.73. besLOADMODULE(x,y)</H3></A>

This macro calls the function <a href="#2.17.5.">modu_LoadModule</A>. The execution
environment (<font size="3"><tt>ExecuteObject</tt></font>) used by the macro while calling the
function is the default execution environment.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.74."><H3>4.5.74. besGETMODULEFUNCTIONBYNAME</H3></A>

This macro calls the function <a href="#2.17.6.">modu_GetFunctionByName</A>. The execution
environment (<font size="3"><tt>ExecuteObject</tt></font>) used by the macro while calling the
function is the default execution environment.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.75."><H3>4.5.75. besUNLOADALLMODULES</H3></A>

This macro calls the function <a href="#2.17.7.">modu_UnloadAllModules</A>. This will unload all modules that are
not active. Because this macro is called by an extension that is a module itself the calling module
will not be unloaded.
<P>
A module is active if there is a function called in the module and the module did not return from the
function call yet. Typically there can be only one active module at a time unless some
modules call each other in tricky ways through the ScriptBasic module calling functions. Therefore
calling this macro practically unloads all modules but the very one using this macro.
<P>
See also <a href="#4.5.76.">besUNLOADMODULE</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.76."><H3>4.5.76. besUNLOADMODULE(x)</H3></A>

This macro calls the function <a href="#2.17.8.">modu_UnloadModule</A> to unload the named
module. Note that the module name <font size="3"><tt>x</tt></font> should be the same
string that was used to load the module and it can not be the actual module or
any other module that is active.
<P>
See also <a href="#4.5.75.">besUNLOADALLMODULES</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.77."><H3>4.5.77. besSLEEP(x)</H3></A>

This macro calls <a href="#2.16.30.">file_sleep</A> to sleep <font size="3"><tt>x</tt></font> number of seconds.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.78."><H3>4.5.78. besCURDIR(x,y)</H3></A>

This function calls <a href="#2.16.31.">file_curdir</A> to get the current working directory.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.79."><H3>4.5.79. besCHDIR(x)</H3></A>

This function calls <a href="#2.16.32.">file_chdir</A> to set the current working directory.
Be careful changing the working directory because it may prevent the extension
module being used in multi-thread variation of ScriptBasic.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.80."><H3>4.5.80. besCHOWN(x,y)</H3></A>

This macro calls the function <a href="#2.16.33.">file_chown</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.81."><H3>4.5.81. besSETCREATETIME(x,y)</H3></A>

This macro calls the function <a href="#2.16.35.">file_SetCreateTime</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.82."><H3>4.5.82. besSETMODIFYTIME(x,y)</H3></A>

This macro calls the function <a href="#2.16.36.">file_SetModifyTime</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.83."><H3>4.5.83. besSETACCESSTIME(x,y)</H3></A>

This macro calls the function <a href="#2.16.37.">file_SetAccessTime</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.84."><H3>4.5.84. besGETHOSTNAME(x,y)</H3></A>

This macro calls the function <a href="#2.16.38.">file_GetHostName</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.85."><H3>4.5.85. besGETHOST(x,y)</H3></A>

This macro calls the function <a href="#2.16.39.">file_GetHost</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.86."><H3>4.5.86. besTCPCONNECT(x,y)</H3></A>

This macro calls the function <a href="#2.16.40.">file_TcpConnect</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.87."><H3>4.5.87. besTCPSEND(x,y,z)</H3></A>

This macro calls the function <a href="#2.16.41.">file_TcpSend</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.88."><H3>4.5.88. besTCPRECV(x,y,z)</H3></A>

This macro calls the function <a href="#2.16.42.">file_TcpRecv</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.89."><H3>4.5.89. besTCPCLOSE(y)</H3></A>

This macro calls the function <a href="#2.16.43.">file_TcpClose</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.90."><H3>4.5.90. besKILLPROC(x)</H3></A>

This macro calls the function <a href="#2.16.44.">file_KillProc</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.91."><H3>4.5.91. besGETOWNER(x,y,z)</H3></A>

This macro calls the function <a href="#2.16.34.">file_GetOwner</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.92."><H3>4.5.92. besCRYPT(x,y,z)</H3></A>

This macro calls the function <a href="#2.16.45.">file_fcrypt</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.93."><H3>4.5.93. besMD5INIT(C)</H3></A>

This macro calls the function <font size="3"><tt>MD5Init</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.94."><H3>4.5.94. besMD5UPDATE(C,I,L)</H3></A>

This macro calls the function <font size="3"><tt>MD5Update</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.95."><H3>4.5.95. besMD5FINAL(D,C)</H3></A>

This macro calls the function <font size="3"><tt>MD5Final</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.96."><H3>4.5.96. besCREATEPROCESS(X)</H3></A>

This macro calls the function <a href="#2.16.46.">file_CreateProcess</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.97."><H3>4.5.97. besCOPYCOMMANDTABLE(X)</H3></A>

This macro calls the function <a href="#2.6.4.2.">execute_CopyCommandTable</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.98."><H3>4.5.98. besGETCOMMANDBYNAME(X,Y)</H3></A>

This macro calls the function <a href="#2.6.4.1.">execute_GetCommandByName</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.99."><H3>4.5.99. besEVALUATEEXPRESSION(X)</H3></A>

This macro evaluates an expression and returns the result <font size="3"><tt>VARIABLE</tt></font>.
This should usually be used only in extension <a href="#4.5.190.">besCOMMAND</A> commands
and not in <a href="#4.5.188.">besFUNCTION</A>. The result is duplicated and mortalized
and therefore the command is free to modify the
<font size="3"><tt>VARIABLE</tt></font>. <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.100."><H3>4.5.100. _besEVALUATEEXPRESSION(X)</H3></A>

This macro evaluates an expression and returns the result <font size="3"><tt>VARIABLE</tt></font>.
This should usually be used only in extension <a href="#4.5.190.">besCOMMAND</A> commands
and not in <a href="#4.5.188.">besFUNCTION</A>. The result is <B>NOT</B> duplicated and <B>NOT</B>
mortalized and therefore the command modifying the <font size="3"><tt>VARIABLE</tt></font> may happen
to modify a BASIC variable.
<P>
This should not be done! There are other ways to modify the value of a
variable.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.101."><H3>4.5.101. _besEVALUATEEXPRESSION_A(X)</H3></A>

This macro evaluates an expression and returns the result <font size="3"><tt>VARIABLE</tt></font>.
This macro is the same as <a href="#4.5.100.">_besEVALUATEEXPRESSION</A> except that this
macro may result a whole array.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.102."><H3>4.5.102. besEVALUATELEFTVALUE(X)</H3></A>

This macro evaluates a left value. This left-value is a pointer to a <font size="3"><tt>VARIABLE</tt></font>.
If this is not <font size="3"><tt>NULL</tt></font> it has to be released first using the macro <a href="#4.5.17.">besRELEASE</A>
and a new immortal value may be assigned to it afterwards.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.103."><H3>4.5.103. besEVALUATELEFTVALUE_A(X)</H3></A>

This macro evaluates a left value. This macro is the same as <a href="#4.5.102.">besEVALUATELEFTVALUE</A>
except that this macro may result a whole array.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.104."><H3>4.5.104. besIMMORTALIZE(x)</H3></A>

This macro calls the function <a href="#2.9.1.23.">memory_Immortalize()</A>. Use this macro
to immortalize a mortal variable before assigning it to a BASIC variable.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.105."><H3>4.5.105. besDEREFERENCE(X)</H3></A>

This macro calls <a href="#2.6.4.23.">execute_DereferenceS</A>. <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.106."><H3>4.5.106. besMatchIndex(X)</H3></A>

This macro calls <a href="#2.19.1.">match_index</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.107."><H3>4.5.107. besMatchIniSets(X)</H3></A>

This macro calls <a href="#">match_InitSets</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.108."><H3>4.5.108. besMatchModifySet(X,Y,Z,W,Q)</H3></A>

This macro calls <a href="#">match_ModifySet</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.109."><H3>4.5.109. besMatchMatch(P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12)</H3></A>

This macro calls <a href="#">match_match</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.110."><H3>4.5.110. besMatchCount(X,Y)</H3></A>

This macro calls <a href="#">match_count</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.111."><H3>4.5.111. besMatchParameter(P1,P2,P3,P4,P5,P6,P7)</H3></A>

This macro calls <a href="#">match_parameter</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.112."><H3>4.5.112. besMatchSize(P1,P2,P3,P4,P5)</H3></A>

This macro calls <a href="#">match_size()</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.113."><H3>4.5.113. besCreateThread(X,Y,Z)</H3></A>

This macro calls <a href="#2.14.1.">thread_CreateThread</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.114."><H3>4.5.114. besExitThread</H3></A>

This macro calls <a href="#2.14.2.">thread_ExitThread</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.115."><H3>4.5.115. besInitMutex(X)</H3></A>

This macro calls <a href="#2.14.3.">thread_InitMutex</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.116."><H3>4.5.116. besFinishMutex(X)</H3></A>

This macro calls <a href="#2.14.4.">thread_FinishMutex</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.117."><H3>4.5.117. besLockMutex(X)</H3></A>

This macro calls <a href="#2.14.5.">thread_LockMutex</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.118."><H3>4.5.118. besUnlockMutex(X)</H3></A>

This macro calls <a href="#2.14.6.">thread_UnlockMutex</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.119."><H3>4.5.119. besInitSharedLock(X)</H3></A>

This macro calls <a href="#2.14.8.">thread_InitLock</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.120."><H3>4.5.120. besFinishSharedLock(X)</H3></A>

This macro calls <a href="#2.14.9.">thread_FinishLock</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.121."><H3>4.5.121. besLockSharedRead(X)</H3></A>

This macro calls <a href="#2.14.10.">thread_LockRead</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.122."><H3>4.5.122. besLockSharedWrite(X)</H3></A>

This macro calls <a href="#2.14.11.">thread_LockWrite</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.123."><H3>4.5.123. besUnlockSharedRead(X)</H3></A>

This macro calls <a href="#2.14.12.">thread_UnlockRead</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.124."><H3>4.5.124. besUnlockSharedWrite(X)</H3></A>

This macro calls <a href="#2.14.13.">thread_UnlockWrite</A>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.125."><H3>4.5.125. besScribaNew(F0,F1)</H3></A>

This macro calls <a href="#3.3.1.">scriba_new</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.126."><H3>4.5.126. besScribaDestroy(F0)</H3></A>

This macro calls <a href="#3.3.2.">scriba_destroy</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.127."><H3>4.5.127. besScribaNewSbData(F0)</H3></A>

This macro calls <a href="#3.3.3.">scriba_NewSbData</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.128."><H3>4.5.128. besScribaNewSbLong(F0,F1)</H3></A>

This macro calls <a href="#3.3.6.">scriba_NewSbLong</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.129."><H3>4.5.129. besScribaNewSbDouble(F0,F1)</H3></A>

This macro calls <a href="#3.3.7.">scriba_NewSbDouble</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.130."><H3>4.5.130. besScribaNewSbUndef(F0)</H3></A>

This macro calls <a href="#3.3.8.">scriba_NewSbUndef</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.131."><H3>4.5.131. besScribaNewSbString(F0,F1)</H3></A>

This macro calls <a href="#3.3.9.">scriba_NewSbString</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.132."><H3>4.5.132. besScribaNewSbBytes(F0,F1,F2)</H3></A>

This macro calls <a href="#3.3.10.">scriba_NewSbBytes</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.133."><H3>4.5.133. besScribaDestroySbData(F0,F1)</H3></A>

This macro calls <a href="#3.3.11.">scriba_DestroySbData</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.134."><H3>4.5.134. besScribaPurgeReaderMemory(F0)</H3></A>

This macro calls <a href="#3.3.12.">scriba_PurgeReaderMemory</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.135."><H3>4.5.135. besScribaPurgeLexerMemory(F0)</H3></A>

This macro calls <a href="#3.3.13.">scriba_PurgeLexerMemory</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.136."><H3>4.5.136. besScribaPurgeSyntaxerMemory(F0)</H3></A>

This macro calls <a href="#3.3.14.">scriba_PurgeSyntaxerMemory</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.137."><H3>4.5.137. besScribaPurgeBuilderMemory(F0)</H3></A>

This macro calls <a href="#3.3.15.">scriba_PurgeBuilderMemory</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.138."><H3>4.5.138. besScribaPurgeExecuteMemory(F0)</H3></A>

This macro calls <a href="#3.3.17.">scriba_PurgeExecuteMemory</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.139."><H3>4.5.139. besScribaSetFileName(F0,F1)</H3></A>

This macro calls <a href="#3.3.18.">scriba_SetFileName</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.140."><H3>4.5.140. besScribaLoadConfiguration(F0,F1)</H3></A>

This macro calls <a href="#3.3.20.">scriba_LoadConfiguration</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.141."><H3>4.5.141. besScribaInheritConfiguration(F0,F1)</H3></A>

This macro calls <a href="#3.3.22.">scriba_InheritConfiguration</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.142."><H3>4.5.142. besScribaSetCgiFlag(F0)</H3></A>

This macro calls <a href="#3.3.28.">scriba_SetCgiFlag</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.143."><H3>4.5.143. besScribaSetReportFunction(F0,F1)</H3></A>

This macro calls <a href="#3.3.29.">scriba_SetReportFunction</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.144."><H3>4.5.144. besScribaSetReportPointer(F0,F1)</H3></A>

This macro calls <a href="#3.3.30.">scriba_SetReportPointer</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.145."><H3>4.5.145. besScribaSetStdin(F0,F1)</H3></A>

This macro calls <a href="#3.3.31.">scriba_SetStdin</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.146."><H3>4.5.146. besScribaSetStdout(F0,F1)</H3></A>

This macro calls <a href="#3.3.32.">scriba_SetStdout</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.147."><H3>4.5.147. besScribaSetEmbedPointer(F0,F1)</H3></A>

This macro calls <a href="#3.3.33.">scriba_SetEmbedPointer</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.148."><H3>4.5.148. besScribaSetEnvironment(F0,F1)</H3></A>

This macro calls <a href="#3.3.34.">scriba_SetEnvironment</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.149."><H3>4.5.149. besScribaLoadBinaryProgram(F0)</H3></A>

This macro calls <a href="#3.3.36.">scriba_LoadBinaryProgram</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.150."><H3>4.5.150. besScribaInheritBinaryProgram(F0,F1)</H3></A>

This macro calls <a href="#3.3.37.">scriba_InheritBinaryProgram</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.151."><H3>4.5.151. besScribaReadSource(F0)</H3></A>

This macro calls <a href="#3.3.39.">scriba_ReadSource</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.152."><H3>4.5.152. besScribaDoLexicalAnalysis(F0)</H3></A>

This macro calls <a href="#3.3.40.">scriba_DoLexicalAnalysis</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.153."><H3>4.5.153. besScribaDoSyntaxAnalysis(F0)</H3></A>

This macro calls <a href="#3.3.41.">scriba_DoSyntaxAnalysis</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.154."><H3>4.5.154. besScribaBuildCode(F0)</H3></A>

This macro calls <a href="#3.3.42.">scriba_BuildCode</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.155."><H3>4.5.155. besScribaIsFileBinaryFormat(F0)</H3></A>

This macro calls <a href="#3.3.43.">scriba_IsFileBinaryFormat</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.156."><H3>4.5.156. besScribaGetCacheFileName(F0)</H3></A>

This macro calls <a href="#3.3.44.">scriba_GetCacheFileName</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.157."><H3>4.5.157. besScribaUseCacheFile(F0)</H3></A>

This macro calls <a href="#3.3.45.">scriba_UseCacheFile</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.158."><H3>4.5.158. besScribaSaveCacheFile(F0)</H3></A>

This macro calls <a href="#3.3.46.">scriba_SaveCacheFile</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.159."><H3>4.5.159. besScribaRunExternalPreprocessor(F0,F1)</H3></A>

This macro calls <a href="#3.3.47.">scriba_RunExternalPreprocessor</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.160."><H3>4.5.160. besScribaSaveCode(F0,F1)</H3></A>

This macro calls <a href="#3.3.48.">scriba_SaveCode</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.161."><H3>4.5.161. besScribaSaveCCode(F0,F1)</H3></A>

This macro calls <a href="#3.3.49.">scriba_SaveCCode</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.162."><H3>4.5.162. besScribaLoadSourceProgram(F0)</H3></A>

This macro calls <a href="#3.3.51.">scriba_LoadSourceProgram</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.163."><H3>4.5.163. besScribaRun(F0,F1)</H3></A>

This macro calls <a href="#3.3.53.">scriba_Run</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.164."><H3>4.5.164. besScribaNoRun(F0)</H3></A>

This macro calls <a href="#3.3.54.">scriba_NoRun</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.165."><H3>4.5.165. besScribaResetVariables(F0)</H3></A>

This macro calls <a href="#3.3.55.">scriba_ResetVariables</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.166."><H3>4.5.166. besScribaCall(F0,F1)</H3></A>

This macro calls <a href="#3.3.56.">scriba_Call</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.167."><H3>4.5.167. besScribaCallArg(F0,F1,F2,F3)</H3></A>

This macro calls <a href="#3.3.57.">scriba_CallArg</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.168."><H3>4.5.168. besScribaDestroySbArgs(F0,F1,F2)</H3></A>

This macro calls <a href="#3.3.58.">scriba_DestroySbArgs</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.169."><H3>4.5.169. besScribaNewSbArgs(F0,F1,F2)</H3></A>

This macro calls <a href="#3.3.59.">scriba_NewSbArgs</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.170."><H3>4.5.170. besScribaCallArgEx(F0,F1,F2,F3,F4)</H3></A>

This macro calls <a href="#3.3.60.">scriba_CallArgEx</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.171."><H3>4.5.171. besScribaLookupFunctionByName(F0,F1)</H3></A>

This macro calls <a href="#3.3.61.">scriba_LookupFunctionByName</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.172."><H3>4.5.172. besScribaLookupVariableByName(F0,F1)</H3></A>

This macro calls <a href="#3.3.62.">scriba_LookupVariableByName</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.173."><H3>4.5.173. besScribaGetVariableType(F0,F1)</H3></A>

This macro calls <a href="#3.3.63.">scriba_GetVariableType</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.174."><H3>4.5.174. besScribaGetVariable(F0,F1,F2)</H3></A>

This macro calls <a href="#3.3.64.">scriba_GetVariable</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.175."><H3>4.5.175. besScribaSetVariable(F0,F1,F2,F3,F4,F5,F6)</H3></A>

This macro calls <a href="#3.3.65.">scriba_SetVariable</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.176."><H3>4.5.176. besLogState(X)</H3></A>

This macro calls <a href="#2.11.1.">log_state</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.177."><H3>4.5.177. besLogInit(F0,F1,F2,F3,F4,F5)</H3></A>

This macro calls <a href="#2.11.2.">log_init</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.178."><H3>4.5.178. besLogPrintf(pLOG,FORMAT, ...)</H3></A>

This macro calls <a href="#2.11.3.">log_printf</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.179."><H3>4.5.179. besLogShutdown(pLOG)</H3></A>

This macro calls <a href="#2.11.4.">log_shutdown</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.180."><H3>4.5.180. besHandleGetHandle(X,Y)</H3></A>

This macro calls <a href="#2.13.1.">handle_GetHandle</A>. The memory segment used by the
macro is the default.
<P>
Example:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
  void *H;
  int i;
    ....
  i = besHandleGetPointer(H,pointer);
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.181."><H3>4.5.181. besHandleGetPointer(X,Y)</H3></A>

This macro calls <a href="#2.13.2.">handle_GetPointer</A>. The memory segment used by the
macro is the default.
<P>
Example:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
  void *H,*pointer;
    ....
  pointer = besHandleGetPointer(H,handle);
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.182."><H3>4.5.182. besHandleFreeHandle(X,Y)</H3></A>

This macro calls <a href="#2.13.3.">handle_FreeHandle</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.183."><H3>4.5.183. besHandleDestroyHandleArray(X)</H3></A>

This macro calls <a href="#2.13.4.">handle_DestroyHandleArray</A>
<P>

Use this macro to declare and process the arguments of a besFUNCTION. The
macro should be placed right after the variable declaration and before
any other code, because it declares the variable <font size="3"><tt>iError</tt></font>.
<P>
The macro calls the function <a href="#4.5.269.">basext_GetArgsF</A> and returns with error in case
some error has happened during the parsing of the arguments.
<P>
Example:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
besARGUMENTS("llzz")
&amp;my_first_long , &amp;my_second_long, &amp;my_string1 , &amp;my_string2
besARGEND
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.184."><H3>4.5.184. besINIT_SEGMENT(MAF,MRF)</H3></A>
This macro calls the function <a href="#2.8.1.2.">alloc_InitSegment</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.185."><H3>4.5.185. besSEGMENT_LIMIT(PMS,L)</H3></A>
This macro calls the function <a href="#2.8.1.4.">alloc_SegmentLimit</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.186."><H3>4.5.186. besFREE_SEGMENT(PMS)</H3></A>
This macro calls the function <a href="#2.8.1.5.">alloc_FreeSegment</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.187."><H3>4.5.187. besFINISH_SEGMENT(PMS)</H3></A>
This macro calls the function <a href="#2.8.1.6.">alloc_FinishSegment</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.188."><H3>4.5.188. besFUNCTION(X)</H3></A>

Use this macro to start an extension module interface function. The macro argument <font size="3"><tt>X</tt></font>
is the name of the function as it is used in the BASIC statement
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
declare sub ::Function alias "X" lib "module"
</PRE></FONT>
<P>
This macro handles all system dependant function decoration declarations and
declares the argument variables. Altough it is possible to name the argument
variables in a different way it is strongly recommended that the programmer
writing external module uses this macro and thus uses the argument names, because
the <font size="3"><tt>besXXX</tt></font> macros rely on these variable names.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.189."><H3>4.5.189. besASSERT_FUNCTION</H3></A>

Use this macro to check inside a besFUNCTION that the function was called
as a sub and not command. If the include file declares the function as
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
declare command XXX alias "xxx" lib "library"
</PRE></FONT>
<P>
instead of
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
declare sub XXX alias "xxx" lib "library"
</PRE></FONT>
<P>
then you can not execute the rest of the code safely. This macro returns
with the error code <font size="3"><tt>COMMAND_ERROR_BAD_CALL</tt></font> if the function was
declared the wrong way.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.190."><H3>4.5.190. besCOMMAND(X)</H3></A>

Use this macro to start an extension module interface command. The macro argument <font size="3"><tt>X</tt></font>
is the name of the command as it is used in the BASIC statement
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
declare command ::Function alias "X" lib "module"
</PRE></FONT>
<P>
This macro handles all system dependant function decoration declarations and
declares the argument variables. Altough it is possible to name the argument
variables in a different way it is strongly recommended that the programmer
writing external module uses this macro and thus uses the argument names, because
the <font size="3"><tt>besXXX</tt></font> macros rely on these variable names.
<P>
In addition to the arguments this macro also declares some mandatory local variables
thatshould be used in most of the module implemented commands and are used by some
macros.
<P>
Note that interface functions get their arguments already evaluated while interface
commands may decide if an argument is evaluated or not, or even evaluated multiple
times.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.191."><H3>4.5.191. besASSERT_COMMAND</H3></A>

Use this macro to check inside a besCOMMAND that the command was called
as a command. If the include file declares the function as
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
declare sub XXX alias "xxx" lib "library"
</PRE></FONT>
<P>
instead of
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
declare command XXX alias "xxx" lib "library"
</PRE></FONT>
<P>
then you can not execute the rest of the code safely. This macro returns
with the error code <font size="3"><tt>COMMAND_ERROR_BAD_CALL</tt></font> if the function was
declared the wrong way.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.192."><H3>4.5.192. besEND_COMMAND</H3></A>

Use this macro to finish an extension module command.
<P>
Note that this macro uses the macro <font size="3"><tt>FINISH</tt></font> that is empty by default. However a command
may decide to perform some action after the mortals are released. To do so the macro
<font size="3"><tt>FINISH</tt></font> can be redefined.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.193."><H3>4.5.193. besARGNR</H3></A>

This macro returns the number of arguments passed to the extension module interface function.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.194."><H3>4.5.194. besARGUMENT(X)</H3></A>
To access the function arguments the module can use the macro. The argument is the
ordinal number of the argument starting from 1. You can overindex the arguments. In
that case the macro value is <font size="3"><tt>NULL</tt></font>.
<P>
Note that this macro can only be used in interface functions and not in interface commands.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.195."><H3>4.5.195. besPARAMETERLIST</H3></A>

Get the ordinal number of the node, where the parameter list starts for the
extenal module interface command. This macro should not be used in interface
functions only in interface commands.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.196."><H3>4.5.196. besLEFTVALUE(X,Y)</H3></A>

Use this macro to evaluate an argument as left value in an interface command.
This macro should not be used in interface functions.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.197."><H3>4.5.197. besVERSION_NEGOTIATE</H3></A>

Use this macro to start the module interface version negotiation function. The simplest
example is:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
besVERSION_NEGOTIATE
  return (int)INTERFACE_VERSION;
besEND
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.198."><H3>4.5.198. besSUB_START</H3></A>

Use this macro to start the module initialization function.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
besSUB_START
  ....
besEND
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.199."><H3>4.5.199. besSUB_FINISH</H3></A>

Use this macro to start the module finalization function.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
besSUB_FINISH
  ....
besEND
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.200."><H3>4.5.200. besSUB_ERRMSG</H3></A>
Use this macro to start the error message function of an external module.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
besSUB_ERRMSG
  ....
besEND
</PRE></FONT><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.201."><H3>4.5.201. besSUB_PROCESS_START</H3></A>

Use this macro to start the function that will be invoked when the module is loaded by the
operating system. This is <font size="3"><tt>_init</tt></font> under UNIX and <font size="3"><tt>DllMain</tt></font> under Windows NT. Using this
macro the programmer can hide the OS dependant code.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.202."><H3>4.5.202. besSUB_PROCESS_FINISH</H3></A>

Use this macro to start the function that will be invoked when the module is unloaded by the
operating system. This is <font size="3"><tt>_fini</tt></font> under UNIX and <font size="3"><tt>DllMain</tt></font> under Windows NT. Using this
macro the programmer can hide the OS dependant code.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.203."><H3>4.5.203. besSUB_KEEP</H3></A>

Use this macro to start the module kepper function. This function should return 1 when the
module wants to remain in memory and 0 when the module can be unloaded.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.204."><H3>4.5.204. besSUB_SHUTDOWN</H3></A>

Use this macro to start a module shutdown function.
<P>
This shutdown function is called before a module is unloaded from the process 
space. The function is similar to <a href="#4.5.199.">besSUB_FINISH</A>. That function is called when
the interpreter finishes. When there are many interpreter threads in a single process
that uses the module the function <a href="#4.5.199.">besSUB_FINISH</A> is called each time an
interpreter finishes. The function <a href="#4.5.204.">besSUB_SHUTDOWN</A> is called only once, before the
interpreter unloads the extesion from memory.
<P>
The difference between <font size="3"><tt>besSUB_SHUTDOWN</tt></font> and <a href="#4.5.202.">besSUB_PROCESS_FINISH</A> is that <font size="3"><tt>besSUB_SHUTDOWN</tt></font>
is called by the interpreter, <a href="#4.5.202.">besSUB_PROCESS_FINISH</A> is called by the operating system.
<font size="3"><tt>besSUB_SHUTDOWN</tt></font> can access the support functions because it gets the <font size="3"><tt>pSt</tt></font> argument,
<a href="#4.5.202.">besSUB_PROCESS_FINISH</A> can not access these functions.
<P>
When a single thread interpreter finishes it first calls the function <a href="#4.5.199.">besSUB_FINISH</A> to unload
the module and after that it calls <font size="3"><tt>besSUB_SHUTDOWN</tt></font>.
<P>
This is not an error if a module does not implement these functions.
<P>
The function should return <font size="3"><tt>COMMAND_ERROR_SUCCESS</tt></font> if the module has no remaining activity and
is ready to be unloaded.
<P>
The function should return <font size="3"><tt>COMMAND_ERROR_STAYS_IN_MEMORY</tt></font> if there are unstopped threads
that use the module code. In this case unloading the module would cause segmentation
fault that would interfere with the still running shutdown procedures. In that case the module
is not unloaded by the program, but only when the process finishes by the operating system.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.205."><H3>4.5.205. besSUB_AUTO</H3></A>

Use this macro to start the external module autoloader function.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.206."><H3>4.5.206. besEND</H3></A>

Use this macro to close an extension module interface function.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.207."><H3>4.5.207. besRETURNVALUE</H3></A>
Use this macro to access the extension function or command return value pointer. Assign allocated
mortal variable to this pointer.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.208."><H3>4.5.208. besMODULEPOINTER</H3></A>
Use this macro to access the extension module pointer.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.209."><H3>4.5.209. besALLOC_RETURN_STRING(X)</H3></A>

Use this macro to allocate a string as a return value. If there is not enough space to store the
result the macro returns from the function with the error code <font size="3"><tt>COMMAND_ERROR_MEMORY_LOW</tt></font>.
<P>
The argument should be the number of bytes of the return value. After using this macro the
macro <font size="3"><tt>STRINGVALUE(besRETURNVALUE)</tt></font> can be used to access the byte-buffer of the return
value. Usually the program uses <font size="3"><tt>memcpy</tt></font> to copy the bytes there.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.210."><H3>4.5.210. besALLOC_RETURN_POINTER</H3></A>

Use this macro to allocate a string as a return value to return a pointer. If there is not enough space to store the
result the macro returns from the function with the error code <font size="3"><tt>COMMAND_ERROR_MEMORY_LOW</tt></font>.
<P>
After using this macro the macro <font size="3"><tt>STRINGVALUE(besRETURNVALUE)</tt></font> can be used to access the byte-buffer of the return
value. Usually the program uses <font size="3"><tt>memcpy</tt></font> to copy the bytes there.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.211."><H3>4.5.211. besALLOC_RETURN_LONG</H3></A>

Use this macro to allocate a <font size="3"><tt>long</tt></font> as a return value. If there is not enough space to store the
result the macro returns from the function with the error code <font size="3"><tt>COMMAND_ERROR_MEMORY_LOW</tt></font>.
<P>
After using this macro the
macro <font size="3"><tt>LONGVALUE(besRETURNVALUE)</tt></font> can be used to access the long value of the return
value.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.212."><H3>4.5.212. besALLOC_RETURN_DOUBLE</H3></A>

Use this macro to allocate a <font size="3"><tt>double</tt></font> as a return value. If there is not enough space to store the
result the macro returns from the function with the error code <font size="3"><tt>COMMAND_ERROR_MEMORY_LOW</tt></font>.
<P>
After using this macro the
macro <font size="3"><tt>DOUBLEVALUE(besRETURNVALUE)</tt></font> can be used to access the double value of the return
value.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.213."><H3>4.5.213. besRETURN_STRING(X)</H3></A>

Use this program to return a string value. The argument of the macro should be a zero terminated
string. 
<P>
The macro allocates the return string, copies the content of the string to the allocated space and
returns from the function using the macro with no error (COMMAND_ERROR_SUCCESS).
<P>
If the return value can not be allocated the macro returns with COMMAND_ERROR_MEMORY_LOW.
<P>
If the argument is <font size="3"><tt>NULL</tt></font> the macro will return the BASIC value <font size="3"><tt>undef</tt></font>.
<P>
The macro evaluates its argument twice.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.214."><H3>4.5.214. besSET_RETURN_STRING(X)</H3></A>

Use this program to return a string value. The argument of the macro should be a zero terminated
string. 
<P>
The macro allocates the return string, copies the content of the string to the allocated space.
This macro does NOT return from the function that uses it. It allows the function to execute
some extra code before returning from the function, for example to release the string
variable passed as argument to this macro.
<P>
If the return value can not be allocated the macro returns with COMMAND_ERROR_MEMORY_LOW.
<P>
If the argument is <font size="3"><tt>NULL</tt></font> the macro will set the return value to be <font size="3"><tt>NULL</tt></font> (BASIC value <font size="3"><tt>undef</tt></font>).
<P>
The macro evaluates its argument twice.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.215."><H3>4.5.215. besRETURN_MEM(X,Y)</H3></A>

Use this program to return a binary string value. The arguments of the macro should be a pointer
to the binary string and the <font size="3"><tt>long</tt></font> length of the binary string. 
<P>
The macro allocates the return string, copies the content of the string to the allocated space and
returns from the function using the macro with no error (COMMAND_ERROR_SUCCESS).
<P>
If the return value can not be allocated the macro returns with COMMAND_ERROR_MEMORY_LOW.
<P>
The macro evaluates its argument twice.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.216."><H3>4.5.216. besRETURN_POINTER(X)</H3></A>

Use this macro to return a pointer. The argument of the macro should be the pointer to return. The
BASIC program will see this value as a string of four (32 bit machines) or eight (64bit machines)
characters. The BASIC program should not alter the value but pass it back to the module wherever
the program needs. In other words the program should treat the value as an abstract handle
and not try to manipulate it.
<P>
The macro allocates the return string, copies the pointer into the string and returns from the function
using the macro with no error (COMMAND_ERROR_SUCCESS).
<P>
If the return value can not be allocated the macro returns with COMMAND_ERROR_MEMORY_LOW.
<P>
If the pointer is <font size="3"><tt>NULL</tt></font> the function will return the BASIC value <font size="3"><tt>undef</tt></font>. This way you can not pass a
<font size="3"><tt>NULL</tt></font> pointer back to the BASIC program stored as four (or eight) zero characters in a string. On the other
hand this is usually not what you really want and the BASIC program can check <font size="3"><tt>undef</tt></font>indeness of the value.
When <font size="3"><tt>undef</tt></font> is passed back to the module the argument handling functions convert it back to <font size="3"><tt>NULL</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.217."><H3>4.5.217. besRETURN_LONG(X)</H3></A>

Use this macro to return a long value. The argument should be a <font size="3"><tt>long</tt></font> value to return.
<P>
The macro allocates the BASIC variable to return the value, sets the value to it to the actual
value of the macro argument and returns from the funcion using the macro with no error (COMMAND_ERROR_SUCCESS).
<P>
If the return value can not be allocated the macro returns with COMMAND_ERROR_MEMORY_LOW.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.218."><H3>4.5.218. besRETURN_DOUBLE</H3></A>

<P>
Use this macro to return a double value. The argument should be a <font size="3"><tt>double</tt></font> value to return.
<P>
The macro allocates the BASIC variable to return the value, sets the value to it to the actual
value of the macro argument and returns from the funcion using the macro with no error (COMMAND_ERROR_SUCCESS).
<P>
If the return value can not be allocated the macro returns with COMMAND_ERROR_MEMORY_LOW.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.219."><H3>4.5.219. besSETCOMMAND(X,Y)</H3></A>
Use this macro to alter the command table. <font size="3"><tt>X</tt></font> is the command code and <font size="3"><tt>Y</tt></font> is the
new function implementing the command.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.220."><H3>4.5.220. besGETCOMMAND(X)</H3></A>
Use this macro to get the command function currently assigned to the command <font size="3"><tt>X</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.221."><H3>4.5.221. INTERFACE_VERSION</H3></A>
The current external module interface version. This is an integer number.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.222."><H3>4.5.222. besHOOK_FILE_ACCESS</H3></A>
This macro calls the function <a href="#2.12.2.">hook_file_access</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.223."><H3>4.5.223. besHOOK_FOPEN</H3></A>
This macro calls the function <a href="#2.12.3.">hook_fopen</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.224."><H3>4.5.224. besHOOK_FCLOSE</H3></A>
This macro calls the function <a href="#2.12.4.">hook_fclose</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.225."><H3>4.5.225. besHOOK_SIZE</H3></A>
This macro calls the function <a href="#2.12.5.">hook_size</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.226."><H3>4.5.226. besHOOK_TIME_ACCESSED</H3></A>
This macro calls the function <a href="#2.12.6.">hook_time_accessed</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.227."><H3>4.5.227. besHOOK_TIME_MODIFIED</H3></A>
This macro calls the function <a href="#2.12.7.">hook_time_modified</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.228."><H3>4.5.228. besHOOK_TIME_CREATED</H3></A>
This macro calls the function <a href="#2.12.8.">hook_time_created</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.229."><H3>4.5.229. besHOOK_ISDIR</H3></A>
This macro calls the function <a href="#2.12.9.">hook_isdir</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.230."><H3>4.5.230. besHOOK_ISREG</H3></A>
This macro calls the function <a href="#2.12.10.">hook_isreg</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.231."><H3>4.5.231. besHOOK_EXISTS</H3></A>
This macro calls the function <a href="#2.12.11.">hook_fileexists</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.232."><H3>4.5.232. besHOOK_TRUNCATE</H3></A>
This macro calls the function <a href="#2.12.12.">hook_truncate</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.233."><H3>4.5.233. besHOOK_FGETC</H3></A>
This macro calls the function <a href="#2.12.13.">hook_fgetc</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.234."><H3>4.5.234. besHOOK_FREAD</H3></A>
This macro calls the function <a href="#2.12.15.">hook_fread</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.235."><H3>4.5.235. besHOOK_FWRITE</H3></A>
This macro calls the function <a href="#2.12.19.">hook_fwrite</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.236."><H3>4.5.236. besHOOK_FERROR</H3></A>
This macro calls the function <a href="#2.12.14.">hook_ferror</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.237."><H3>4.5.237. besHOOK_PUTC</H3></A>
This macro calls the function <a href="#2.12.20.">hook_fputc</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.238."><H3>4.5.238. besHOOK_FLOCK</H3></A>
This macro calls the function <a href="#2.12.21.">hook_flock</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.239."><H3>4.5.239. besHOOK_LOCK</H3></A>
This macro calls the function <a href="#2.12.22.">hook_lock</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.240."><H3>4.5.240. besHOOK_FEOF</H3></A>
This macro calls the function <a href="#2.12.23.">hook_feof</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.241."><H3>4.5.241. besHOOK_MKDIR</H3></A>
This macro calls the function <a href="#2.12.24.">hook_mkdir</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.242."><H3>4.5.242. besHOOK_RMDIR</H3></A>
This macro calls the function <a href="#2.12.25.">hook_rmdir</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.243."><H3>4.5.243. besHOOK_REMOVE</H3></A>
This macro calls the function <a href="#2.12.26.">hook_remove</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.244."><H3>4.5.244. besHOOK_DELTREE</H3></A>
This macro calls the function <a href="#2.12.27.">hook_deltree</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.245."><H3>4.5.245. besHOOK_MAKEDIRECTORY</H3></A>
This macro calls the function <a href="#2.12.28.">hook_MakeDirectory</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.246."><H3>4.5.246. besHOOK_OPENDIR</H3></A>
This macro calls the function <a href="#2.12.29.">hook_opendir</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.247."><H3>4.5.247. besHOOK_READDIR</H3></A>
This macro calls the function <a href="#2.12.30.">hook_readdir</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.248."><H3>4.5.248. besHOOK_CLOSEDIR</H3></A>
This macro calls the function <a href="#2.12.31.">hook_closedir</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.249."><H3>4.5.249. besHOOK_SLEEP</H3></A>
This macro calls the function <a href="#2.12.32.">hook_sleep</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.250."><H3>4.5.250. besHOOK_CURDIR</H3></A>
This macro calls the function <a href="#2.12.33.">hook_curdir</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.251."><H3>4.5.251. besHOOK_CHDIR</H3></A>
This macro calls the function <a href="#2.12.34.">hook_chdir</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.252."><H3>4.5.252. besHOOK_CHOWN</H3></A>
This macro calls the function <a href="#2.12.35.">hook_chown</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.253."><H3>4.5.253. besHOOK_SETCREATETIME</H3></A>
This macro calls the function <a href="#2.12.36.">hook_SetCreateTime</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.254."><H3>4.5.254. besHOOK_SETMODIFYTIME</H3></A>
This macro calls the function <a href="#2.12.37.">hook_SetModifyTime</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.255."><H3>4.5.255. besHOOK_SETACCESSTIME</H3></A>
This macro calls the function <a href="#2.12.38.">hook_SetAccessTime</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.256."><H3>4.5.256. besHOOK_GETHOSTNAME</H3></A>
This macro calls the function <a href="#2.12.39.">hook_GetHostName</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.257."><H3>4.5.257. besHOOK_GETHOST</H3></A>
This macro calls the function <a href="#2.12.40.">hook_GetHost</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.258."><H3>4.5.258. besHOOK_TCPCONNECT</H3></A>
This macro calls the function <a href="#2.12.41.">hook_TcpConnect</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.259."><H3>4.5.259. besHOOK_TCPSEND</H3></A>
This macro calls the function <a href="#2.12.42.">hook_TcpSend</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.260."><H3>4.5.260. besHOOK_TCPRECV</H3></A>
This macro calls the function <a href="#2.12.43.">hook_TcpRecv</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.261."><H3>4.5.261. besHOOK_TCPCLOSE</H3></A>
This macro calls the function <a href="#2.12.44.">hook_TcpClose</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.262."><H3>4.5.262. besHOOK_KILLPROC</H3></A>
This macro calls the function <a href="#2.12.45.">hook_KillProc</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.263."><H3>4.5.263. besHOOK_GETOWNER</H3></A>
This macro calls the function <a href="#2.12.46.">hook_GetOwner</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.264."><H3>4.5.264. besHOOK_CREATEPROCESS</H3></A>
This macro calls the function <a href="#2.12.48.">hook_CreateProcess</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.265."><H3>4.5.265. besHOOK_CALLSCRIBAFUNCTION</H3></A>
This macro calls the function <a href="#2.12.51.">hook_CallScribaFunction</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.266."><H3>4.5.266. besSETHOOK(X,Y)</H3></A>
Use this macro to alter the hook function table.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.267."><H3>4.5.267. besDLL_MAIN</H3></A>

process header macro makes UNIX like dll loading and unloading
on Win32. This just defines a wrapper DllMain that calls _init() and
_fini() that a the default library loading and unloading functions
under UNIX.
<P>
Use of this macro may be needed for modules that serve multi thread
interpreters and share resources on the process level<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.268."><H3>4.5.268. INITLOCK</H3></A>

Whent he process first time loads an extension and the extension wants to decide whether
to unload it or keep in memory it needs a counter and a mutex to access the counter
to declare the counter the extension should use the macro SUPPORT_MULTITHREAD and
to initialize it it should use the macro INIT_MULTITHREAD
<P>
Note that the call-back functions to handle the mutexes OS independant are not available
by the time when the OS calls DllMain on NT or _init on UNIX, thus the code should call
system dependant functions directly
<P>
IsThisTheVeryFirstThreadCallingTheModule &lt;- name of the function
 <P><a href="#contents">[Contents]</A><BR>
<P>
<A name="4.5.269."><H3>4.5.269. basext_GetArgsF()</H3></A>

This function can be used to get arguments simple and fast in extension modules.
All functionality of this function can be individually programmed using the
<font size="3"><tt>besXXX</tt></font> macros. Here it is to ease the programming of extension modules for most of
the cases.
<P>
This function should be called like
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
  iError = besGETARGS "ldz",&amp;l1,&amp;d1,&amp;s besGETARGE
</PRE></FONT>
<P>
The macro <font size="3"><tt>besGETARGS</tt></font> (read GET ARGument Start) hides the complexity of the
function call and the macro <font size="3"><tt>besGETARGE</tt></font> (read Get ARGument End) simply closes the
function call.
<P>
The first argument is format string. Each character specifies how the next argument
should be treated.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int basext_GetArgsF(pSupportTable pSt,
                    pFixSizeMemoryObject pParameters,
                    char *pszFormat,
                    ...
  )@{
</PRE></FONT>
The following characters are recognized:
<P>
<UL>
<LI> <font size="3"><tt>i</tt></font> the next argument of the function call should point to a <font size="3"><tt>long</tt></font> variable.
           The ScriptBasic argument will be converted to <font size="3"><tt>long</tt></font> using the macro
           <font size="3"><tt>besCONVERT2LONG</tt></font> and will be stored in the <font size="3"><tt>long</tt></font> variable.
<LI> <font size="3"><tt>r</tt></font> the same as <font size="3"><tt>l</tt></font> except that the argument should point a <font size="3"><tt>double</tt></font> and the
           basic argument is converted to <font size="3"><tt>double</tt></font> using <font size="3"><tt>besCONVERT2DOUBLE</tt></font>.
<LI> <font size="3"><tt>z</tt></font> the next argument should point to a <font size="3"><tt>char *</tt></font> pointer. The function takes
           the next BASIC argument as string, converts it to zero terminated string
           allocating space for it. These variables SHOULD be released by the caller
           using the macro <font size="3"><tt>besFREE</tt></font>.
<LI> <font size="3"><tt>s</tt></font> the next argument should point to a <font size="3"><tt>unsigned char *</tt></font> pointer. The function takes
           the next BASIC argument as string, converting it in case conversion is needed, and
           sets the <font size="3"><tt>unsigned char *</tt></font> pointer to point to the string. This format character
           should be used together with the character <font size="3"><tt>l</tt></font>
<LI> <font size="3"><tt>l</tt></font> the next argument should point to a <font size="3"><tt>long</tt></font> and the value of the variable
           will be the length of the last string atgument (either <font size="3"><tt>z</tt></font> or <font size="3"><tt>s</tt></font>).
           If there was no previous string argument the value returned will be zero.
<LI> <font size="3"><tt>p</tt></font> the next argument should point to a <font size="3"><tt>void *</tt></font> pointer. The BASIC argument value
           should be a string of <font size="3"><tt>sizeof(void *)</tt></font> characters that will be copied into the
           pointer argument. If the argument is not string or has not the proper size the function
           returns <font size="3"><tt>COMMAND_ERROR_ARGUMENT_RANGE</tt></font>.
<LI> <font size="3"><tt>[</tt></font> The arguments following this character are optional. Optional arguments may be
           unspecified. This is the case when the BASIC function call has less number of
           arguments or when the actual argument value is <font size="3"><tt>undef</tt></font>. In case of optional
           arguments the <font size="3"><tt>undef</tt></font> values are converted to zero value of the appropriate
           type. This means 0 in case of long, 0.0 in case of double, NULL in case of pointer
           and zero length string in case of strings.
<LI> <font size="3"><tt>]</tt></font> Arguments following this character are mandatory (are not optional). When the
           function starts to process the arguments they are mandatory by default. Using this
           notation you can enclode the optional arguments between <font size="3"><tt>[</tt></font> and <font size="3"><tt>]</tt></font>. For example
           the format string <font size="3"><tt>"ii[z]"</tt></font> means two long arguments and an optional zero terminated
           string argument.
<LI> <font size="3"><tt>*</tt></font> The argument is skipped. This may be used during development of a function.
@end itemize
<P>
The return value of the function is zero in case there is no error or the error code.
 
<P>

<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5."><H1>5. Preprocessors</H1></A>

ScriptBasic is capable handling two kind of preprocessors. One is external preprocessors, the other one is internal preprocessor. The names <I>external</I> and the <I>internal</I> distinguish between the execution type of these preprocessors. External preprocessors are executed in a separate process. Internal preprocessors run in the interpreter thread.
<P>
Because of this external preprocessors are standalone command line tools, which may be written for any application and not specifically for ScriptBasic. You can edit the ScriptBasic configuration file so that you can use the C preprocessor, <font size="3"><tt>m4</tt></font> or <font size="3"><tt>jamal</tt></font> as a preprocessor. It is fairly easy to write an external preprocessor compared to internal preprocessors. External preprocessor reads a file and creates an output file. It need not know anything about the internal structures of ScriptBasic. Then only thing a ScriptBasic external preprocessor writer has to know is what it wants to do and how to read and write files.
<P>
Internal preprocessors are implemented in dynamic link libraries, work closely together with ScriptBasic and can not be started standalone. Internal preprocessors are written specifically for ScriptBasic and can and should access many of ScriptBasic internal structures.
<P>
From this you can see that external preprocessors are much easier to write, while internal preprocessors have much more possibilities. An internal preprocessor can never started as external and vice versa.
<P>
Before starting to write a preprocessor you have to carefully check what you want to gain and decide if you want to write an external preprocessor or an internal.
<P>
Because external preprocessors are just standalone programs and there is even a sample preprocessor HEB written in BASIC this chapter talks about the internal preprocessor capabilities. <a href="#2.1.">External Preprocessor</A><P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.1."><H2>5.1. Loading Preprocessor</H2></A>

Loading a preprocessor depends on the embedding application. To load an internal preprocessor the function <font size="3"><tt>ipreproc_LoadInternalPreprocessor</tt></font> is called (implemented in the file `<font size="3"><tt>ipreproc.c</tt></font>').
<P>
This function gets the name of an external preprocessor to load. The function searches the configuration information for the named preprocessor, loads the DLL/SO and invokes the initiation function of the preprocessor.
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int ipreproc_LoadInternalPreprocessor(pPreprocObject pPre,
                                      char *pszPreprocessorName);
</PRE></FONT>
<P>
The first argument is the pointer to the ScriptBasic preprocessor object to access the configuration information and the list of loaded preprocessors to put the actual one on the list.
<P>
The second argument is the name of the preprocessor as named in the configuration file, for example
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
preproc (
  internal (
    sample "C:\\ScriptBasic\\bin\\samplepreprocessor.dll"
    )
</PRE></FONT>
<P>
The return value is zero or the error code.
<P>
(Note that this documentation may not be up-to date about the precise functioning of this function. For most up-to date information see the source documentation that is extracted from the source comment using the tool `<font size="3"><tt>esd2html.pl</tt></font>'.)
<P>

In the code base of ScriptBasic this function is called by the reader `<font size="3"><tt>reader.c</tt></font>' in the function <font size="3"><tt>reader_LoadPreprocessors</tt></font>. This is called automatically when the source is read and include files were also included. This function (<font size="3"><tt>reader_LoadPreprocessors</tt></font>) goes through all the lines and searches for lines that start with the word <font size="3"><tt>preprocess</tt></font> and name a preprocessor. The function loads the preprocessor and deletes the source line.
<P>
The function <font size="3"><tt> ipreproc_LoadInternalPreprocessor</tt></font> is also called from the function <font size="3"><tt>scriba_LoadInternalPreprocessor</tt></font> in source file `<font size="3"><tt>scriba.c</tt></font>'
<P>
This function can and should be used by the embedding programs to load all internal preprocessors that are to be loaded based on some external conditions. For example the VARIATION STANDARD of ScriptBasic (aka. the command line embedding variation) loads all internal preprocessors that were named after the command line option `<font size="3"><tt>-i</tt></font>'.
<P>
Other embedding application may get the information of desired preprocessors from different sources, like environment variables, configuration files and so on.
<P>
Note that internal preprocessors are not used whenever an already compiled version of the program is executing. If there is a <font size="3"><tt>preprocess</tt></font> line in the source code and the program has generated a cache or any other binary format BASIC program and that file is used to execute the program the preprocessor will no effect. The interpreter will not load the preprocessor and thus it will act as it did not exist.
<P>
There are two kind of preprocessors:
<P>

<UL>
<LI> Altering preprocessors
<P>
The "altering" preprocessors act as conventional preprocessor altering the source code and/or altering the compilation environment during compilation that results finally a binary BASIC file. These preprocessors ask the ScriptBasic interpreter to unload the preprocessor before the actual execution of the program starts as they have nothing to do with the actual, executed program.
<P>
<LI> Debugger preprocessors
<P>
Debugger preprocessor collects symbolic information during the compilation phase and alters the hook functions <font size="3"><tt>HOOK_ExecBefore</tt></font>, <font size="3"><tt>HOOK_ExecAfter</tt></font>, <font size="3"><tt>HOOK_ExecCall</tt></font>, <font size="3"><tt>HOOK_ExecReturn</tt></font>.
<P>
During execution these "preprocessors" remain in the process and execute the functions that the altered hook pointers point to performing debugging, profiling or some other development support features.
<P>
The sample preprocessor <font size="3"><tt>dbg</tt></font> does this implementing a command line debugger.
<P>
<LI> Mixed preprocessors
<P>
It is possible, though I see no reason to write a preprocessor that belongs to both categories above.
<P>
</UL>
<P>
Altering preprocessors are BASIC program specific and are usually invoked because the program contains a line <font size="3"><tt>preprocess</tt></font>.
<P>
Debugger type preprocessors are loaded the way of the execution of the program requests it. For example the user uses the option `<font size="3"><tt>-i</tt></font>'. In this case the command line version of ScriptBasic does not use cache file to ensure that the program really does using the preprocessor and starts the debugger, for example.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.2."><H2>5.2. Skeleton of a Preprocessor</H2></A>

An internal preprocessor implemented as a <font size="3"><tt>.dll</tt></font> or <font size="3"><tt>.so</tt></font> file has to export a single function named <font size="3"><tt>preproc</tt></font>. The declaration of this function should look like this:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int DLL_EXPORT preproc(pPrepext pEXT,
                       long *pCmd,
                       void *p);
</PRE></FONT>
<P>
The first argument of the function is the preprocessor pointer. This pointer points to a structure. For each preprocessor loaded there is a separate structure of this type. This structure hold information on the preprocessor and there is some storage pointer in the structure that the preprocessor can access.
<P>
The definition of the structure is:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
typedef struct _Prepext {
  long lVersion;
  void *pPointer;
  void *pMemorySegment;
  struct _SupportTable *pST;
  } Prepext, *pPrepext;
</PRE></FONT>
<P>
The field <font size="3"><tt>lVersion</tt></font> is the version of the interface that ScriptBasic wants to use when communicating with the preprocessor. If this version is not the same as the interface version that the preprocessor was compiled for then the preprocessor has to ask ScriptBasic not to use it and may return an error code or zero indicating that no error has happened. This may be useful in some cases when the preprocessor is optional and in case the preprocessor can not be loaded the program still may function. Read on how the preprocessor has to do this.
<P>
The field <font size="3"><tt>pPointer</tt></font> is initialized to <font size="3"><tt>NULL</tt></font> and is never changed by ScriptBasic. This is a pointer that can be used by the preprocessor to access its own thread local variables.
<P>
The field <font size="3"><tt>pMemorySegment</tt></font> is initialized to point to a memory segment that can be used via the memory allocation routines of ScriptBasic. These routines, however need not be linked to the DLL, because they are already in the process loaded as part of the executable and can be reached via the function support table.
<P>
This support table is pointed by the field <font size="3"><tt>pST</tt></font> and is the same type of <font size="3"><tt>struct</tt></font> as the support table available for the extension modules. Although this support table is the same type of <font size="3"><tt>struct</tt></font> it is not the same <font size="3"><tt>struct</tt></font>. The fields pointing to the different functions are eventually pointing to the same function, but when the program starts to execute a new support table is allocated and initialized. Thus there is no reason for the preprocessor to alter this table, because altering the table will have no effect on the execution of the program. Also the preprocessor if decides to stay in memory while the program is executed (for example a debugger), may rely on this support table even if a module altering the run-time support table is used.
<P>
In case there are more than one internal preprocessors used they will share the same support table. This way a preprocessor altering the preprocessor support table may alter the behavior of another internal preprocessor. However doing that need deep and detailed information of both ScriptBasic code and the other preprocessor and may result code that closely depends on the different versions of the different programs that work together.
<P>
The next argument to the function <font size="3"><tt>pCmd</tt></font> is an input and output variable. When the function is called by ScriptBasic it contains the command that the preprocessor is expected to perform. In other words this value defines the reason why the preprocessor was loaded. There are numerous points when ScriptBasic calls the preprocessor and at each point it sets this variable differently.
<P>
When the function returns it is supposed to set the variable <font size="3"><tt>*pCmd</tt></font> to one of the following values:
<P>
<UL>
<P>
<LI>
  <font size="3"><tt>PreprocessorContinue</tt></font>
<P>
Returning this value means that the preprocessor has done what it was supposed to do and the program should go on.
<P>
<LI>
  <font size="3"><tt>PreprocessorDone</tt></font>
<P>
Returning this value means that the preprocessor has done what it was supposed to do and ScriptBasic should not, and indeed will not call any other preprocessors loaded for the actual "command".
<P>
<LI>
  <font size="3"><tt>PreprocessorUnload</tt></font>
<P>
Returning this value means that the preprocessor has done all tasks it had to do and ScriptBasic should close the preprocessor, release all memory that the preprocessor has allocated using the call-back function <font size="3"><tt>alloc_Alloc</tt></font> and should unload the dynamic load library.
<P>
</UL>
<P>
The preprocessors function <font size="3"><tt>preproc</tt></font> may at any call return an <font size="3"><tt>int</tt></font> value. This value will be used by the interpreter as error code. This code is zero in case there was no error. This value has to be returned to ensure that the interpreter goes on. The error code <font size="3"><tt>1</tt></font> is used at any code in ScriptBasic to signal memory allocation problems. The symbolic constant <font size="3"><tt>COMMAND_ERROR_PREPROCESSOR_ABORT</tt></font> can be used to tell the interpreter to stop. For example the sample debugger preprocessor uses this error code when the user gives the command <font size="3"><tt>q</tt></font> to quit debugging.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3."><H2>5.3. Preprocessor Entry Points</H2></A>

<P>
Lets recall the prototype of the preprocessor function, which has to be implemented in each preprocessor:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
int DLL_EXPORT preproc(pPrepext pEXT,
                       long *pCmd,
                       void *p);
</PRE></FONT>
<P>
This function has to be implemented in each internal preprocessor and is called when the preprocessor is loaded or when some the processing of the source program has reached a certain point. To inform the function about this point the argument <font size="3"><tt>pCmd</tt></font> is used. This argument points to a <font size="3"><tt>long</tt></font> that holds the a constant identifying the reason why the preprocessor function was called. The following subsections list these identifiers.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.1."><H3>5.3.1. PreprocessorLoad</H3></A>

This entry point is used when the preprocessor is loaded. The pointer <font size="3"><tt>p</tt></font> is <font size="3"><tt>NULL</tt></font>.
<P>
When the preprocessor function is called with this argument it can be sure that this is the very first call to the function within the actual interpreter thread. It also can depend on the support function table and on the preprocessor memory segment pointer being initialized and ready to allocate memory.
<P>
It has to check that the version the preprocessor was designed and compiled for is appropriate and works together with the ScriptBasic interpreter that invoked the preprocessor. This can easily be done checking the version information in the preprocessor structure. Sample code:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
      if( pEXT-&gt;lVersion != IP_INTERFACE_VERSION ){
        *pCmd = PreprocessorUnload;
        return 0;
        }
</PRE></FONT>
<P>
This code is the appropriate place to allocate space for the preprocessor structure that hold the thread local variables. For example:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
      pDO = pEXT-&gt;pST-&gt;Alloc(sizeof(DebuggerObject),pEXT-&gt;pMemorySegment);
      *pCmd = PreprocessorUnload;
      if( pDO == NULL )return 1;
</PRE></FONT>
<P>
Note that this example is a simplified version of the one that you can find in the sample debugger preprocessor. This example uses the <font size="3"><tt>Alloc</tt></font> support function that is usually points to the function <font size="3"><tt>alloc_Alloc</tt></font> implemented in the file `<font size="3"><tt>myalloc.c</tt></font>'. When coding an external preprocessor you can rely on ScriptBasic that as soon as the preprocessor is unloaded the memory allocated using this function with the memory segment initiated for the preprocessor (like above) will be released.
<P>
The preprocessor has to return the error code or zero and may alter the value of the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font> or <font size="3"><tt>PreprocessorUnload</tt></font>.
<P>
Although the calling code ignores the value returned in <font size="3"><tt>*pCmd</tt></font> unless it is <font size="3"><tt>PreprocessorUnload</tt></font> it is required by principle to set a value in this variable. The value <font size="3"><tt>PreprocessorDone</tt></font> can not be used when returning from this entry.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.2."><H3>5.3.2. PreprocessorReadStart</H3></A>

This entry point is used before the source file reading starts. The pointer <font size="3"><tt>p</tt></font> points to the <font size="3"><tt>ReadObject</tt></font> used to read the source files. There is few uses of this entry point. You may alter the file handling function pointers or the memory allocation function pointers in the <font size="3"><tt>ReadObject</tt></font>.
<P>
This entry point is invoked only when the preprocessor load was initiated by external conditions, like command line option `<font size="3"><tt>-i</tt></font>' and never if the source code contained the preprocessor loading directive. This is because when the reader realizes that the preprocessor has to be loaded it is far over this point.
<P>

<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.3."><H3>5.3.3. PreprocessorReadDone0</H3></A>

This entry point is used when the reader has done the reading of the source file, but did not do any processing further. The parameter <font size="3"><tt>p</tt></font> points to the <font size="3"><tt>ReadObject</tt></font>. The preprocessor at this point can access the lines of the core BASIC program file without the included files and the very first line of the program that may be a Windows NT or UNIX special line (like <font size="3"><tt>#!/usr/bin/scriba</tt></font>) is still in the input lines.
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.4."><H3>5.3.4. PreprocessorReadDone1</H3></A>

This entry point is used when the reader has done the reading the source file and unhooked the optional first Windows NT or UNIX start line (like <font size="3"><tt>#!/usr/bin/scriba</tt></font>), but did not process the included files. The preprocessor at this point can access the lines of the core BASIC program file without the included files. The parameter <font size="3"><tt>p</tt></font> points to the <font size="3"><tt>ReadObject</tt></font>.
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.5."><H3>5.3.5. PreprocessorReadDone2</H3></A>

This entry point is used when the reader has done the reading the source file and unhooked the optional first Windows NT or UNIX start line (like <font size="3"><tt>#!/usr/bin/scriba</tt></font>), and has processed the included files. The preprocessor at this point can access the lines of the full BASIC program file with the included files. The parameter <font size="3"><tt>p</tt></font> points to the <font size="3"><tt>ReadObject</tt></font>.
<P>
This is the last point before the source code directive loaded preprocessors are invoked.
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.6."><H3>5.3.6. PreprocessorReadDone3</H3></A>

This point is used when the reader has done all reading tasks, processed and linked the include files, has removed the first Windows NT or UNIX specific line, and loaded the preprocessors that were to be loaded by program directive. The parameter <font size="3"><tt>p</tt></font> points to the <font size="3"><tt>ReadObject</tt></font>.
<P>
At this point the preprocessor may check the source code and alter it according to its need. All processing should be done here that needs the characters of the source file. Careful decision has to be made whether using this point of entry to alter the source file or the entry point <font size="3"><tt>PreprocessorLexDone</tt></font> when the source file is already tokenized.
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.7."><H3>5.3.7. PreprocessorLexInit</H3></A>

This entry point is used when the lexer object was allocated and initialized. The pointer <font size="3"><tt>p</tt></font> points to the <font size="3"><tt>LexObject</tt></font>.
<P>
The preprocessor at this point may alter the <font size="3"><tt>LexObject</tt></font> parameters. Here is a copy of the function <font size="3"><tt>lex_InitStructure</tt></font> from ScriptBasic v1.0build26. (other versions may slightly differ).
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
void lex_InitStructure(pLexObject pLex
  ){
/*noverbatim
CUT*/
  pLex-&gt;pfGetCharacter = NULL;
  pLex-&gt;pfFileName = _MyFileName;
  pLex-&gt;pfLineNumber = _MyLineNumber;
  pLex-&gt;SSC = "QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm_:$";
  pLex-&gt;SCC = "QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm_1234567890:$";
  pLex-&gt;SFC = "QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm_1234567890$";
  pLex-&gt;SStC = "\"";
  pLex-&gt;ESCS = "\\n\nt\tr\r\"\"\'\'";
  pLex-&gt;fFlag = LEX_PROCESS_STRING_NUMBER       |
                LEX_PROCESS_STRING_OCTAL_NUMBER |
                LEX_PROCESS_STRING_HEX_NUMBER   |
                0;
  pLex-&gt;SKIP = " \t\r"; /* spaces to skip 
                           \r is included to ease compilation of DOS edited 
                           binary transfered files to run on UNIX */
  pLex-&gt;pNASymbols = NULL;
  pLex-&gt;pASymbols  = NULL;
  pLex-&gt;pCSymbols  = NULL;
  pLex-&gt;cbNASymbolLength = 0; /* it is to be calculated */
<P>
  pLex-&gt;buffer = lexALLOC(BUFFERINCREASE*sizeof(char));
<P>
  if( pLex-&gt;buffer )
    pLex-&gt;cbBuffer = BUFFERINCREASE;
  else
    pLex-&gt;cbBuffer = 0;
<P>
  CALL_PREPROCESSOR(PreprocessorLexInit,pLex);
  }
</PRE></FONT>
<P>
(Note <font size="3"><tt>CALL_PREPROCESSOR</tt></font> is a macro that call the preprocessor with appropriate arguments.)
<P>
The preprocessor may decide for example to alter the string <font size="3"><tt>SSC</tt></font> that contains all characters that may start a symbol, or <font size="3"><tt>SCC</tt></font> that contains all characters that can part a symbol or <font size="3"><tt>SFC</tt></font> that contains all characters that can be the final character of a symbol. This way for example a preprocessor may set these strings that allows Hungarian programmers to use ISO-Latin-2 accented letters in their variables. (However those characters are going to be case sensitive.)
<P>
The preprocessor may also set the pointers that point to the tables that contains the alphanumeric symbols (<font size="3"><tt>pASymbols</tt></font>), non-alpha symbols (<font size="3"><tt>pNASymbols</tt></font>) and the table used for some ScriptBasic internal debugging purpose (<font size="3"><tt>pCSymbols</tt></font>).
<P>
The preprocessor may also release and reallocate a smaller or larger <font size="3"><tt>buffer</tt></font> if wishes. (I personally see no reason.)
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.8."><H3>5.3.8. PreprocessorLexDone</H3></A>

This entry point is used when the lexer has finished the lexical analysis and the list of tokens is already in the memory. The pointer <font size="3"><tt>p</tt></font> points to the <font size="3"><tt>LexObject</tt></font>.
<P>
At this point the preprocessor may alter the tokenized form of the BASIC program. The list of tokens still contains the comment lines (also tokenized although it may make no sense), and the continuation lines are still being split containing the <font size="3"><tt>_</tt></font> character and the new-line token.
<P>
The preprocessor may gain information from comments in case the some comments provide information for the preprocessor.
<P>
If the preprocessor uses some special symbols that drive the preprocessor processing but should be removed from the token list the preprocessor at this point may unlink the token from the list or just set the <font size="3"><tt>type</tt></font> of the token to <font size="3"><tt>LEX_T_SKIP</tt></font> or <font size="3"><tt>LEX_T_SKIP_SYMBOL</tt></font>.
<P>

If you do not or do not want to understand the difference between the two possibilities described soon then the rule of thumb is to use <font size="3"><tt>LEX_T_SKIP</tt></font> and you are safe.
<P>
The type <font size="3"><tt>LEX_T_SKIP</tt></font> should be used in case the token is handled due to <font size="3"><tt>ProcessLexSymbol</tt></font> preprocessor command and <font size="3"><tt>LEX_T_SKIP</tt></font> otherwise.
<P>
When the type is set <font size="3"><tt>LEX_T_SKIP_SYMBOL</tt></font> the lexical analyzer knows to release the string holding the symbol. If the type is <font size="3"><tt>LEX_T_SKIP</tt></font> only the token record is released.
<P>
If the symbol string is not released due to erroneously setting the type to <font size="3"><tt>LEX_T_SKIP</tt></font> instead <font size="3"><tt>LEX_T_SKIP_SYMBOL</tt></font> the memory will not be released until the interpreter finishes pre execution steps. So usually if you do not know how to set the type to skip a token <font size="3"><tt>LEX_T_SKIP</tt></font> is safe.
<P>
When processing comments the preprocessor should either use only the comments starting with the keyword <font size="3"><tt>rem</tt></font> or should carefully detect the comments starting with <font size="3"><tt>'</tt></font>.
<P>
For more information how to do it you really have to look at the function <font size="3"><tt>lex_RemoveComments</tt></font> in the file `<font size="3"><tt>lexer.c</tt></font>'.
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.9."><H3>5.3.9. PreprocessorLexNASymbol</H3></A>

This entry point is used when the lexer has found a non alpha symbol. Non alpha symbols are predefined character strings, like <font size="3"><tt>&lt;&gt;</tt></font> or <font size="3"><tt>&lt;=</tt></font> that contain more than one character but are not alpha characters.
<P>

<P>
When this entry point is called the pointer <font size="3"><tt>p</tt></font> points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.
<P>
When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type <font size="3"><tt>Lexeme</tt></font>. The lexer object field <font size="3"><tt>pLexResult</tt></font> points to the first element of this list. The lexer code uses a local variable named <font size="3"><tt>plexLastLexeme</tt></font> that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.
<P>
When the preprocessor is called using this entry point this variable passed in the argument <font size="3"><tt>p</tt></font> "by value". Through this pointer you can 
<P>
<UL>
<LI> alter the last token fields
<LI> unhook the last token and optionally hook something else on it or even
<LI> unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
</UL>
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.10."><H3>5.3.10. PreprocessorLexASymbol</H3></A>

This entry point is used when the lexer has found an alpha symbol. Alpha symbols are the keywords that are predefined in ScriptBasic.
 
When this entry point is called the pointer <font size="3"><tt>p</tt></font> points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.
<P>
When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type <font size="3"><tt>Lexeme</tt></font>. The lexer object field <font size="3"><tt>pLexResult</tt></font> points to the first element of this list. The lexer code uses a local variable named <font size="3"><tt>plexLastLexeme</tt></font> that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.
<P>
When the preprocessor is called using this entry point this variable passed in the argument <font size="3"><tt>p</tt></font> "by value". Through this pointer you can 
<P>
<UL>
<LI> alter the last token fields
<LI> unhook the last token and optionally hook something else on it or even
<LI> unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
</UL>
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.11."><H3>5.3.11. PreprocessorLexSymbol</H3></A>

This entry point is used when the lexer finds a symbol that is alphanumeric but is not predefined by ScriptBasic. These are the variables and symbols (like the statement <font size="3"><tt>OPEN</tt></font> opening modes.)
<P>
When this entry point is called the pointer <font size="3"><tt>p</tt></font> points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.
<P>
When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type <font size="3"><tt>Lexeme</tt></font>. The lexer object field <font size="3"><tt>pLexResult</tt></font> points to the first element of this list. The lexer code uses a local variable named <font size="3"><tt>plexLastLexeme</tt></font> that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.
<P>
When the preprocessor is called using this entry point this variable passed in the argument <font size="3"><tt>p</tt></font> "by value". Through this pointer you can 
<P>
<UL>
<LI> alter the last token fields
<LI> unhook the last token and optionally hook something else on it or even
<LI> unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
</UL>
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.12."><H3>5.3.12. PreprocessorLexString</H3></A>

This entry point is used when the preprocessor has processed a single-line string.
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.13."><H3>5.3.13. PreprocessorLexMString</H3></A>

<P>
This entry point is used when the preprocessor has processed a multi-line string.
 
When this entry point is called the pointer <font size="3"><tt>p</tt></font> points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.
<P>
When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type <font size="3"><tt>Lexeme</tt></font>. The lexer object field <font size="3"><tt>pLexResult</tt></font> points to the first element of this list. The lexer code uses a local variable named <font size="3"><tt>plexLastLexeme</tt></font> that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.
<P>
When the preprocessor is called using this entry point this variable passed in the argument <font size="3"><tt>p</tt></font> "by value". Through this pointer you can 
<P>
<UL>
<LI> alter the last token fields
<LI> unhook the last token and optionally hook something else on it or even
<LI> unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
</UL>
 
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.14."><H3>5.3.14. PreprocessorLexInteger</H3></A>

This entry point is called when the lexer has processed an integer.
<P>
When this entry point is called the pointer <font size="3"><tt>p</tt></font> points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.
<P>
When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type <font size="3"><tt>Lexeme</tt></font>. The lexer object field <font size="3"><tt>pLexResult</tt></font> points to the first element of this list. The lexer code uses a local variable named <font size="3"><tt>plexLastLexeme</tt></font> that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.
<P>
When the preprocessor is called using this entry point this variable passed in the argument <font size="3"><tt>p</tt></font> "by value". Through this pointer you can 
<P>
<UL>
<LI> alter the last token fields
<LI> unhook the last token and optionally hook something else on it or even
<LI> unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
</UL>
 
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.15."><H3>5.3.15. PreprocessorLexReal</H3></A>

This entry point is called when the lexer has processed an real number.
<P>
When this entry point is called the pointer <font size="3"><tt>p</tt></font> points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.
<P>
When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type <font size="3"><tt>Lexeme</tt></font>. The lexer object field <font size="3"><tt>pLexResult</tt></font> points to the first element of this list. The lexer code uses a local variable named <font size="3"><tt>plexLastLexeme</tt></font> that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.
<P>
When the preprocessor is called using this entry point this variable passed in the argument <font size="3"><tt>p</tt></font> "by value". Through this pointer you can 
<P>
<UL>
<LI> alter the last token fields
<LI> unhook the last token and optionally hook something else on it or even
<LI> unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
</UL>
 
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.16."><H3>5.3.16. PreprocessorLexCharacter</H3></A>

This entry point is called when the lexer has processed a character.
<P>
When this entry point is called the pointer <font size="3"><tt>p</tt></font> points to a pointer that point to a pointer pointing to the last processed lexeme. This seems to be quite complex and uselessly complex to pass such a pointer at the firstglance. However it is not.
<P>
When the lexer builds the list of the lexemes reading the characters it creates a linked list of structures of type <font size="3"><tt>Lexeme</tt></font>. The lexer object field <font size="3"><tt>pLexResult</tt></font> points to the first element of this list. The lexer code uses a local variable named <font size="3"><tt>plexLastLexeme</tt></font> that first points to this pointer, and later it always points to the forward link pointer of the last element of the list.
<P>
When the preprocessor is called using this entry point this variable passed in the argument <font size="3"><tt>p</tt></font> "by value". Through this pointer you can 
<P>
<UL>
<LI> alter the last token fields
<LI> unhook the last token and optionally hook something else on it or even
<LI> unhook any number of elements from the list that were already hooked and set the last forward link pointer as you wish
</UL>
 
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.17."><H3>5.3.17. PreprocessorExStart</H3></A>

This entry point is used when the syntax analyzer starts. 
<P>
The argument <font size="3"><tt>p</tt></font> points to the actual <font size="3"><tt>peXobject</tt></font> syntax analysis object structure.
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.18."><H3>5.3.18. PreprocessorExStartLine</H3></A>

This entry point is used when the syntax analyzer starts to analyze a program line.
The argument <font size="3"><tt>p</tt></font> points to the actual <font size="3"><tt>peXobject</tt></font> syntax analysis object structure.
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.19."><H3>5.3.19. PreprocessorExEnd</H3></A>

This entry point is used when the syntax analyzer has finished analyzing the basic program.
The argument <font size="3"><tt>p</tt></font> points to the actual <font size="3"><tt>peXobject</tt></font> syntax analysis object structure.
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.20."><H3>5.3.20. PreprocessorExFinish</H3></A>

This entry point is called from the function <font size="3"><tt> scriba_DoSyntaxAnalysis</tt></font> implemented in the file `<font size="3"><tt>scriba.c</tt></font>' when the syntax analyzer has finished.
<P>
The only difference between this entry point and the entry point <font size="3"><tt>PreprocessorExEnd</tt></font> is that at this point the field <font size="3"><tt>pCommandList</tt></font> in the <font size="3"><tt>peXobject</tt></font> object structure already points to the list of nodes.
<P>
The argument <font size="3"><tt>p</tt></font> points to the actual <font size="3"><tt>peXobject</tt></font> syntax analysis object structure.
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.21."><H3>5.3.21. PreprocessorExStartLocal</H3></A>

This entry point is used when the syntax analyzer starts a new local scope. This is when a function or a sub starts.
<P>
The argument <font size="3"><tt>p</tt></font> points to the actual <font size="3"><tt>peXobject</tt></font> syntax analysis object structure.
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.22."><H3>5.3.22. PreprocessorExEndLocal</H3></A>

This entry point is used when the syntax analyzer exists a local scope. This is when a function or a sub ends.
<P>
The argument <font size="3"><tt>p</tt></font> points to the actual <font size="3"><tt>peXobject</tt></font> syntax analysis object structure.
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.23."><H3>5.3.23. PreprocessorExLineNode</H3></A>

This entry point is used when the syntax analyzer creates a new node for a basic program line.
<P>
The argument <font size="3"><tt>p</tt></font> points to the actual <font size="3"><tt>peXobject</tt></font> syntax analysis object structure.
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.24."><H3>5.3.24. PreprocessorExeStart</H3></A>

This entry point is used from the function <font size="3"><tt>scriba_Run</tt></font> implemented in the file `<font size="3"><tt>scriba.c</tt></font>' before the execution of the basic program starts.
<P>
The argument <font size="3"><tt>p</tt></font> points to the execution context of the basic program.
<P>

<P>
By this time most of the preprocessors should have asked the basic interpreter to unload. Only preprocessors implementing debugger, profiler or other development support functions may remain in memory and active.
<P>

At this very point debugger or other development support preprocessors may and should access the execution hook functions, like the sample debugger preprocessor does:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
  case PreprocessorExeStart:
<P>
    { pExecuteObject pEo = p;
      pDebuggerObject pDO = pEXT-&gt;pPointer;
      pEo-&gt;pHookers-&gt;hook_pointer = pEXT;
      pDO-&gt;CallStackDepth = 0;
      pDO-&gt;DbgStack = NULL;
      pDO-&gt;StackTop = NULL;
      pEo-&gt;pHookers-&gt;HOOK_ExecBefore = MyExecBefore;
      pEo-&gt;pHookers-&gt;HOOK_ExecAfter = MyExecAfter;
      pEo-&gt;pHookers-&gt;HOOK_ExecCall = MyExecCall;
      pEo-&gt;pHookers-&gt;HOOK_ExecReturn = MyExecReturn;
      *pCmd = PreprocessorContinue;
      return 0;
      }
</PRE></FONT>
<P>
(Note that this is an example only and not the actual code. The actual code performs other tasks as well.)
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.25."><H3>5.3.25. PreprocessorExeFinish</H3></A>

This entry point is used from the function <font size="3"><tt>scriba_Run</tt></font> implemented in the file `<font size="3"><tt>scriba.c</tt></font>' after the execution of the basic program finished.
<P>
The argument <font size="3"><tt>p</tt></font> points to the execution context of the basic program.
<P>
By this time most of the preprocessors should have asked the basic interpreter to unload. Only preprocessors implementing debugger, profiler or other development support functions may remain in memory and active.
<P>
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="5.3.26."><H3>5.3.26. PreprocessorExeNoRun</H3></A>

This entry point is used from the function <font size="3"><tt>scriba_NoRun</tt></font> implemented in the file `<font size="3"><tt>scriba.c</tt></font>' before the execution of the basic program is not started. (Note that <font size="3"><tt>scriba_NoRun</tt></font> performs initialization for the execution but does not start the execution.)
<P>
By this time most of the preprocessors should have asked the basic interpreter to unload. Only preprocessors implementing debugger, profiler or other development support functions may remain in memory and active.
 
The function has to return zero or the error code and should set the parameter <font size="3"><tt>*pCmd</tt></font> to <font size="3"><tt>PreprocessorContinue</tt></font>, <font size="3"><tt>PreprocessorDone</tt></font>, or <font size="3"><tt>PreprocessorUnload</tt></font>.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="6."><H1>6. Compilation</H1></A>

ScriptBasic is written in C and thus there is a need for some C compiler to successfully install it from source. However some of the code is not maintained in C but rather in some higher level language (what an exaggeration!), which is compiled to C. To compile all the code from source you also need a functional Perl interpreter executing the version 5 of the language Perl.
<P>
Compilation is automated as much as it is possible and was highly tested on Windows NT and under Linux (Debian). Under other operating systems resembling to UNIX the compilation should be quite straight forward though may not be so seamless as it is for the ones I tested.<P><a href="#contents">[Contents]</A><BR>
<P>
<A name="6.1."><H2>6.1. Compilation under UNIX</H2></A>

Compilation starts from the clean source package. You unzip it or gunzip untar it into the source directory. To be safe you can run
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
sh convert.sh
</PRE></FONT>
<P>
that converts all text files from Windows line feed convention to UNIX convention. If you have a tarball rather than a ZIP file then you may already have the correct line ending, but running the conversion does not hurt. Well, if you feel better by that you can run it many times. On the other hand if you uploaded the Windows source package you will not get along compiling the package without this conversion.
<P>
To compile the code you have to issue the command
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
./setup
</PRE></FONT>
<P>
This will run all the commands that are needed before compilation to generate the C source files from the real source files and also compiles the make files from their macro source. Finally it runs the compilation processes.
<P>
The program `<font size="3"><tt>setup.pl</tt></font>' started by the shell script `<font size="3"><tt>setup</tt></font>' is a huge Perl script that automates the compilation under UNIX and under Windows NT as well.
<P>
To install the compiled code the script `<font size="3"><tt>setup.pl</tt></font>' has to be started again, this time using the argument:
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
./setup -install
</PRE></FONT>
<P>
Although its use may imply it does not install ScriptBasic. It only creates the file `<font size="3"><tt>install.sh</tt></font>' that you can run later any time
<P>
<FONT SIZE="3" COLOR="BLUE"><PRE>
$ su
Password: **********
# ./install.sh
</PRE></FONT>
<P>
from the root account. It is recommended that you examine and understand the content of the script before executing it. It actually installs ScriptBasic, compiles the configuration information, stops the Eszter SB Application Engine and many other things.
<P>
I said &gt;&gt;only creates the file ...&lt;&lt; in double quotes, because it does many things before actually creating the file. It interactively asks you about the destination directories, installs an experimental installation of ScriptBasic locally to run some test programs, examines which modules were compiled fine and so on. It even tests the possible maximal value for the configuration key <font size="3"><tt>maxlevel</tt></font> that limits the maximal recursive function call level inside ScriptBasic. To do so it creates a configuration that does not limit the depth and runs a test program until it crashes. The test program in each level of depth opens a file and appends a single byte to the file. Finally the length of the file gives the maximal possible recursive function depth on your installation.
<P>

